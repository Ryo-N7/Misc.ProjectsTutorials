---
title: "sakura_bloom.r"
author: "Ryo Nakagawara"
date: "Sun Sep 10 15:13:11 2017"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

April in Japan is a time of new beginnings. Unlike most countries, the school year starts in April ...  asdfljasldf
asdfasdfl
asdfasdf...

Let's get started by loading up our trusty packages and data:

```{r warning=FALSE, message=FALSE}
# Sakura data
library(tidyverse)
library(stringr)
library(scales)

# Load data ---------------------------------------------------------------

sakura <- read.csv("~/R_materials/Kyoto_Flowers.csv")
glimpse(sakura)
```

From looking at the raw data, it appears that data is missing from a number of rows until 812 AD. Along with many other rows throughout the years. We might as well cut those rows out and specify our own starting date in the plot later on.

``` {r}
# Tidy and Clean ----------------------------------------------------------

# remove rows without flowering date
sakura <- sakura %>% filter(!is.na(Full.flowering.date))

colnames(sakura)   # look at the column names
```

from looking at the column names... they don't look very neat or tidy.

```{r}
# colnames don't look very neat and tidy...
colnames(sakura) <- sakura %>% 
  colnames() %>% 
  str_to_lower() %>%                  # to lower case letters
  str_replace_all("\\.", "_")         # replace . with _

colnames(sakura)
```

Much better! However there are two columns with names that need some manual fixing:

``` {r}
colnames(sakura)[1] <- "year"
colnames(sakura)[2] <- "full_flowering_day_of_year"

colnames(sakura)
```

OK! Now let's separate the column containing our three-digit date data into individual `month` and `day` columns. We can use regular expressions (**regex**) to parse the character strings of the date (converted from the numeric format first) and then separate the `month` digits and `day` digits with a `.` period symbol. 

```{r}
# turn three digit number into month and day values.
# split into two backreferences on the first digit, then place a .
date_sep <- as.character(sakura$full_flowering_date) %>% 
  str_replace_all("(.{1})(.*)", "\\1.\\2") %>%            

colnames(date_sep)[1] <- "date_fl"                        # properly name column
colnames(date_sep)

date_sep <- date_sep %>% separate(date_fl, c("month", "day"), "\\.")    # separate into 'month' and 'day' columns on .
```



```{r}
sakura <- bind_cols(date_sep, sakura)   # combine date_sep into sakura
sakura <- sakura %>% select(-full_flowering_date, -full_flowering_day_of_year, -x, -data_type_code, -reference_name, -source_code)  # remove extraneous columns
```

Using the `lubridate` package we can create a separate variable in YYYY/MM/DD format as well as format the individual date components into their own variables.

```{r}
library(lubridate)
# ?make_date()
# ?format()
# use make_date function to create separate variable in full date format
sakura <- sakura %>% 
  mutate(bloom = make_date(year, month, day))

# Reformat date variables into specific date formats:
sakura$Day_Of_Year <- as.numeric(format(sakura$bloom, "%j"))   #  %j: decimal day of the year
sakura$Year <- format(sakura$bloom, "%Y")                      #  %Y: 4 digit year
sakura$Month <- format(sakura$bloom, "%b")                     #  %b: abbreviated month
sakura$Day <- format(sakura$bloom, "%d")                       #  %d: decimal date

glimpse(sakura)
# date format are all in <chr>
```

Now we are ready to plot!

```{r}
# Plotting ----------------------------------------------------------------

ggplot(sakura, aes(x = Year, y = Day_Of_Year)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(labels = function(x) format(as.Date(as.character(x), "%j"), "%d-%b"))
```

Does not look very clear...

```{r}
ggplot(sakura, aes(x = year, y = Day_Of_Year)) +  # or just use original 'year' variable...
  geom_point() +
  geom_smooth(span = 0.2, size = 3) +
  scale_y_continuous(labels = function(x) format(as.Date(as.character(x), "%j"), "%b-%d"),
                     limits = c(84, 125))
```

Slightly better, but could we make it more... sakura-y?

```{r}
ggplot(sakura, aes(x = year, y = Day_Of_Year)) +  # or just use original 'year' variable...
  geom_point(shape = 8, size = 5, color = "pink") +
  geom_smooth(span = 0.2, color = "#dd1c77", fill = "red", size = 3) +
  scale_y_continuous(labels = function(x) format(as.Date(as.character(x), "%j"), "%b-%d"),
                     limits = c(84, 125))
```

Better! but does not look good on a drab grey background...  
So let's add a background image!

``` {r}
#### With background image!
library(jpeg)
library(grid)
library(gridExtra)
library(cowplot)

sakura_r <- function(df = sakura, xvar = 'as.numeric(Year)', yvar = 'Day_Of_Year') {
  img_url <- 'https://i.imgur.com/CgwU1zb.jpg'
  tmp_file <- tempfile()
  download.file(img_url, tmp_file, mode = "wb")
  img <- readJPEG(tmp_file)
  file.remove(tmp_file)
  
  rstr <- rasterGrob(img, width = unit(1,"npc"), height = unit(1,"npc"), interpolate = FALSE)
  
  g <- ggplot(data = df)  + annotation_custom(rstr, -Inf, Inf, -Inf, Inf)
  g <- g + geom_point(aes_string(x = xvar, y = yvar), alpha = 0.8, color = "pink", shape = 8)
  g <- g + geom_smooth(aes_string(x = xvar, y = yvar), color = "#dd1c77", span = 0.2, size = 2.5, fill = "#f768a1", alpha = 0.7)
  g <- g + scale_y_continuous(labels = function(x) format(as.Date(as.character(x), "%j"), "%d-%b"))
  g <- g + scale_x_continuous(limits = c(800, 2020), breaks = seq(800, 2000, 200))
  g <- g + labs(x = "Year", y = "Date of peak sakura bloom")
  g <- g + ggtitle("Sakura blooming", subtitle = "Date of sakura blossoming in Kyoto (800-2015 CE)")
  g <- g + theme(legend.position = "top", legend.background = element_rect(color = "black"),
                 axis.text.x = element_text(angle = 45, hjust = 1))
  return (g)
}
sakura_r()
```

