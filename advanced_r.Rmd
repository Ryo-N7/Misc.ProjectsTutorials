---
title: "Untitled"
author: "RN7"
date: "9/7/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r}
pacman::p_load(lobstr, rlang, dplyr, magrittr, 
               purrr, ggplot2, scales, sloop)
```


# 2. Names & Values

```{r}
set.seed(1014)
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)

str(df)

df$`3` <- df$`1`+ df$`2`

str(df)
```

```{r}
x <- runif(1e6)
y <- list(x, x, x)

# object.size(y) WRONG
lobstr::obj_size(y)
```




```{r}
a <- c(1, 5, 3, 2)
a

b <- a
b
a

b[[1]] <- 10

b

## a is copied when b is modified at line 3
```







```{r}
lobstr::obj_addr(mean)
lobstr::obj_addr(base::mean)
lobstr::obj_addr(get("mean"))
lobstr::obj_addr(evalq(mean))
lobstr::obj_addr(match.fun("mean"))
```


```{r}
read.csv(check.names = FALSE)
```




```{r}
x <- c(1L, 2L, 3L)
x
tracemem(x)

x[[3]] <- 4
untracemem(x)
```





# 3. Vectors

## 3.2: Atomic Vectors

4 common types of vectors: double, character, logical, integer
2 rare types of vectors: complex, raw

Attributes: associate arbitrary additional metadata to object

```{r}
attr()
attributes()
```

List vs. atomic vector: elements of LIST can be ANY type, elements of atomic vector must be the same

Matrix vs. data frame:  element of matrix must be same, element of data frame can be ANY type

List as matrix? Assign dimension to list
Data frame have column == matrix? Assign matrix to column of df with `<- matrix()` or `I()`

Difference between tibbles vs. data frame: tibbles have enhanced print method, NEVER coerces string to factors, provide stricter subsetting methods

### 3.2.1: Scalars

Scalar: individual value for the primary types of vectors
- Logical: TRUE / FALSE, T / F
- Doubles: decimal, scientific, hexadecimal forms. Special values (Inf, -Inf, NaN)
- Integers: no fractional values, use of `L` at end
- Strings: `"blah"`, special characters escaped with `\`



### 3.2.2: Longer vectors with `c()`

`c()`: combine

```{r}
lgl_var <- c(TRUE, FALSE)
lgl_var

int_var <- c(1L, 6L, 104L)
int_var

dbl_var <- c(1, 2.5, 6.45)
dbl_var

chr_var <- c("these are", "some strings")
chr_var
```
If inputs == atomic vectors >> `c()` creates another atomic vector >> flattens

```{r}
c(c(1, 2), c(3, 4))
```
`type_of()`: determine type of vector 



### 3.2.3: Missing Values

Missing/unknown: `NA`, most computations with missing value return missing value!

```{r}
NA > 5
10 * NA
!NA
```

Exceptions: when identity holds for all possible inputs

```{r}
NA ^ 0
NA | TRUE
NA & FALSE
```
Common mistake: 

```{r}
x <- c(NA, 5, NA, 10)
x == NA

## use is.na() instead for testing presence of missingness!
is.na(x)
```
NA types: `NA`, `NA_integer_`, `NA_real_`, `NA_character_`
- `NA` usually coerced to correct type

### 3.2.4: Testing and coercion

`is.*()`: test for type of vector. 
- AVOID: `is.vector()` + `is.atomic()` + `is.numeric()`
- When attempt to combine different vector types >>> coercion
- Coercion order: character >>> double >>> integer >>> logical
Ex. combine character + integet == character

```{r}
str(c("A", 1))
```
- Most mathematical functions coerc to numeric (`+`, `log()`, `abs()`, etc.)
- `TRUE` == `1` & `FALSE` == `0` 

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

## total number of TRUE
sum(x)

## proportion that are TRUE
mean(x)
```

`as.*()`: directly coerce vector type: `as.logical()`, `as.integer()`, `as.double()`, `as.character()`.

Ex. failed coercion:

```{r}
as.integer(c("1", "1.5", "a"))
```

### exercise

1. 
scalars == represented as vectors of length == 1
scalars of type raw:

```{r}
raw(1)
as.raw(42)
```

scalars of type complex:

```{r}
complex(1)
complex(length.out = 1, real = 1, imaginary = 1)
```

2. Vector coercion rules:

```{r}
c(1, FALSE)  ## double
c("a", 1)    ## character
c(TRUE, 1L)  ## integer
```

3. 

```{r}
1 == "1"    ## coerces to character
## TRUE because `1` is coerced to "1"

-1 < FALSE  ## coerces to double
## TRUE because `FALSE` coerces to double >> `0`

"one" < 2   ## coerces to character
## FALSE because `2` coerces to character "2"
## numerals precede letters but depends on locale
```
4. 

DEFAULT missing NA == logical vector: due to hierarchy of type coercion, when combining `NA` with other atomic vector types then will be coerced in order integer, numeric, character. IF `NA` was character than all other values in set would be coerced to characters as well which would be problematic.

5. 

`is.atomic()`: test if atomic vector or NULL
`is.numeric()`: test if object has type "integer"/"double" and NOT "factor", "Date", "POSIXt", "difftime"
`is.vector()`: test if object is vector and NO attributes besides names

## 3.3 Attributes

Atomic vectors != `matrices`, `arrays`, `factors`, `date-times`
- Built on top of atomic vectors by adding ATTRIBUTES

### 3.3.1: Getting & Setting

Attributes: name-value pairs >>> attach metadata on object
- `attr()`: retrieve/modify individual attributes
- `attributes()`: retrieve en masse
- `structure()`: set en masse

```{r}
a <- 1:3
attr(a, "asd49824-blahblah") <- "abcdef23blargh-attribute"
attr(a, "asd49824-blahblah")
```

```{r}
attr(a, "y") <- 4:6
str(attributes(a))
```

```{r}
a <- structure(
  1:3,
  x = "abcdef",
  y = 4:6
)

str(attributes(a))
```

Most attributes lost by operations:

```{r}
attributes(a[1])
attributes(sum(a))
```

Two attributes usually preserved:
- `names`: character vector giving each element a name
- `dim`: dimensions, integer vector used to turn vectors into matrices/arrays

To preserve others, need to create S3 class.

### 3.3.2: Names

```{r}
## Upon creation
x <- c(a = 1, b = 2, c = 3)
x

## Assigning character vector to `names()`
x <- 1:3
names(x) <- c("a", "b", "c")
x

## Inline via `setNames()`
x <- setNames(1:3, c("a", "b", "c"))
x
```

```{r}
unname(x)
names(x) <- NULL
```

Missing names either "" or `NA_character_`. If all names missing == `NULL`

### 3.3.3: Dimensions

`dim`: Add to vector for it to behave like 2D matrix or multi-D array. 

```{r}
## 2 scalar arguments specifying row + column size
a <- matrix(1:6, nrow = 2, ncol = 3)
a

## 1 vector argument to describe all dimensions
b <- array(1:6, c(2, 3, 1))
b

## modify object in palce with `dim()`
c <- 1:6
dim(c) <- c(2, 3)
c
```

- Vector with no `dim` attributes == NULL dimensions


### exercise

1. How are `setNames()` and `unname()` implemented?

- `setNames()`: uses `names()` and assigns input to the object
- `unname()`: removes existing names and sets to `NULL`

2. `dim()` to 1d vector? When use `NROW()` and `NCOL()`?

- `dim()`: returns NULL when applied to 1d vector

```{r}
x <- 1:10
nrow(x)
ncol(x)

## use for when handle atomic vectors, lists, NULLs similar to 1 column matrices/data frames
NROW(x)
NCOL(x)
```

3. 

```{r}
x1 <- array(1:5, c(1, 1, 5)) ## 1 row 1 col 5 z
x2 <- array(1:5, c(1, 5, 1)) ## 1 row 5 col 1 z
x3 <- array(1:5, c(5, 1, 1)) ## 5 rows 1 col 1 z
```

4. `structure()`

```{r}
foo <- structure(1:5, comment = "my attribute")

attributes(foo)

attr(foo, which = "comment")
```


## 3.4: S3 Atomic vectors

Class: vector attribute >>> S3 object system
S3 object: Object with a class attribute, behaves differently from regular ector when passed to a generic function. Every S3 object is built on top of a base type, stores additional info about other attributes.

### 3.4.1: Factors

Factor: Vector containing only pre-defined values for storing categorical data. Built on top of integer vector with 2 attributes
- Class "factor": behave differently from regular integer vectors
- levels: Defines the set of allowed values

```{r}
x <- factor(c("a", "b", "b", "a"))
x

typeof(x)
attributes(x)
```

Tabulating factors: Get counts of all categories, even if unobserved

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_factor)
```
Ordered: Order of levels is meaningful (ex. low, medium, high)

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
```

Careful when using string methods on factors, as they are built on integer vectors NOT character.

### 3.4.2: Dates

Date: Built on top of double vectors. 
- Class "Date", no other attributes

```{r}
today <- Sys.Date()

today

typeof(today)

attributes(today)

## value of double represents # of days since 1970-01-01
date <- as.Date("1970-02-01")
unclass(date)
```

### 3.4.3: Date-times


POSIXct: calendar time >> atomic vector, appropriate for data frames
POSIXlt: local time

```{r}
now_ct_DLT <- as.POSIXct("2018-07-22 09:00", tz = "America/New_York")
now_ct <- as.POSIXct("2018-11-22 09:00", tz = "America/New_York")

now_ct

typeof(now_ct)

attributes(now_ct)

structure(now_ct_DLT, tzone = "Asia/Tokyo")
structure(now_ct, tzone = "Asia/Tokyo")
```

### 3.4.4: Durations

Durations: Amount of time between pairs of dates or date-times. >>> `difftimes`
- Built on top of doubles, `units` attribute for how integer is interpreted

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

### exercise 

1. `table()` object? Type? Attributes? Dimension changes as add more variables?

Class: `table`
array of integers with attributes `dim` and `dimnames`
Dimensions correspond to # of unique values in each variable

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

tabobj <- table(sex_char)

typeof(tabobj)
attributes(tabobj)


```

2. What happens to factor when modify its levels?

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

levels(f1)
as.integer(f1)
```
Underlying integer values remain same but levels change!





### exercise 

`table()` returns type integer, class "table", with "dim" and "dimnames" attributes, represented internally as array of integers

```{r}
typeof(table(cars))
```


2. What happens to factor when you modify levels?

```{r}
f1 <- factor(letters)
levels(f1)
as.integer(f1)

levels(f1) <- rev(levels(f1))
levels(f1)
as.integer(f1)
```

underlying integer values stay the same but levels == changed!

3. How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))

f3 <- factor(letters, levels = rev(letters))

f1
f2
f3
```
f1: BOTH order of factor elements AND order of levels reversed!
f2: order of factor elements reversed
f3: order of levels reversed


## 3.5: Lists

- Each element can be ANY type, not just ectors. 

### 3.5.1: Creating

```{r}
l1 <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9)
)

typeof(l1)
str(l1)
```

Elements of list are references >>> Creating a list does NOT involve copying components INTO the list!

```{r}
lobstr::obj_size(mtcars)
l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
```


Lists: recursive vectors as list can contain other lists

```{r}
l3 <- list(list(list(1)))
str(l3)
```

`c()` combines several lists into 1. If combo of atomic vectors and lists, coerce vectors to lists before combining.

```{r}
l4 <- list(list(1, 2), c(3, 4))
l5 <- c(list(1, 2), c(3, 4))

str(l4)
str(l5)
```


### 3.5.2: Testing & coercion

`is.list()`, `as.list()`, `unlist()` for list >> atomic vector

```{r}
list(1:3)
as.list(1:3)
```

### 3.5.3: Matrices & arrays

- For atomic vectors, dimension attribute used for creating matrices
-- Lists: dimension attribute to create list-matrices and list-arrays

```{r}
l <- list(1:3, "a", TRUE, 1.0)
l

dim(l) <- c(2, 2)
l

l[1]
l[[1, 1]]
```

### exercise

1. List all ways list different from atomic vector

List: Can be heterogenous (elements of different types allowed), contain separate references for each element, subsetting out-of-bound values or NAs == `NULL`

Atomic vector: Always homogenous (all elements == same type), point to one address in memory, subsetting out-of-bound values or NAs == `NA`

```{r}
lobstr::ref(1:2)

lobstr::ref(list(1:2, 2))
```



2. Why use `unlist()` to convert list to atomic vector? Why `as.vector()` NOT work?

- List is already a vector (but not an atomic vector)
- `as.vector()` != `is.vector()`


3. Compare/contrast `c()` and `unlist()` when combining date and date-time into a single vector.

Date + date-time built on doubles. Dates == days, date-time (POSIXct) == seconds.

Generic function dispatches based on class of its first argument.

`c()` coerces types >> errors occur due to inappropriate method dispatch (avoid by explicit conversion of classes)
`unlist()` strips attributes

## 3.6 Data Frames and Tibbles

Data frame: Named list of vectors with attributes for column names, `row.names`, class: "data.frame"

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])

typeof(df1)

attributes(df1)
```

Dataframe additional constraint vs. regular list: Length of each vector must be the same >>> rectangular structure, reason why share properties of matrices + lists
- df: `rownames()` + `colnames()`. `names()` of df == column names
- df: `nrow()` + `ncol()`. `length()` of df == # of columns

Tibbles: modern re-imagining of data frames.

```{r}
library(tibble)

df2 <- tibble(x = 1:3, y = letters[1:3])
typeof(df2)
attributes(df2)
```

### 3.6.1: Creating

Supply name-vector pairs to `data.frame(0`)
- default conversion of strings to factors >> `stringsAsFactors = FALSE`

```{r}
df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c")
)

str(df)
```

Tibble: never coerces input

Data farames: automatically transform non-syntactic names (unless `check.names = FALSE`)

Tibble: NOT auto-transform non-syntactic names

```{r}
names(data.frame(`1` = 1))

names(tibble(`1` = 1))
```
- Every element must have same length, can recycle shorter inputs.
- df: recycle cols that are integer multiple of longest column
- tibble: only recycle vectors of length one

```{r}
data.frame(x = 1:4, y = 1:2)

data.frame(x = 1:4, y = 1:3)

tibble(x = 1:4, y = 1)

tibble(x = 1:4, y = 1:2)
```

tibbles: allow referencing variables created during construction (inputs evaluated left-to-right)

```{r}
tibble(x = 1:3,
       y = x * 2)
```



### 3.6.2: Row names

Label each row with character vector of unique values >>> `rownames()`

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)

df3
df3["Bob", ]
```

Can NOT transpose data frame as you would a matrix.

- Metadata == still data. 
- Row names are bad abstraction for labelling rows as only ID by single string (what about time or multiple vectors?).
- Unique: duplication of rows will create new row names. Matching rows == complicated regex

```{r}
df3[c(1, 1, 1), ]
```

Tibbles: NO row names >> convert row names to regular columns
- `rownames_to_column()` or specify in `rownames` argument in `as_tibble()`

### 3.6.3: Printing

Tibbles: First 10 rows and al columns that can fit on screen.
- Each column labelled with type
- Wide cols truncated

### 3.6.4: Subsetting

Data frames: Subset with `[` will return vector if only 1 variable selected, otherwise data frame
- Extract single column >>> if none then select any that starts with letter, then NULL

Tibble: `[` always returns tibble, `$` not do any partial matching + warning if none

### 3.6.5: Testing and coercing

`is.data.frame()` + `as.data.frame()` <> `is_tibble()` + `as_tibble()`

### 3.6.6: List columns

Data frames: Only created added after creation or wrap list with `I()`
Tibble: Directly included inside tibble creation

### 3.6.7: Matrix and data frame columns 

- Most functions assume data frame columns are vectors 



### exercise

1. Data frame with 0 rows? 0 columns?

```{r}
iris[0, ]
iris[, 0]
iris[0, 0]

data.frame()
```


2. Set rownames that are NOT unique?

- error if `row.names()`
- if subsetting with `[`, automatically de-duplicates


3. Transpose data frame?

returns matrix! output columns coerced to same type!

```{r}
class( t(t(data.frame(mtcars)))  )
```

4. `as.matrix()` to a data frame with different type columns? `data.matrix()`?

`as.matrix()` will coerce column types based on type hierarchy

`data.matrix()` converts to numeric >>> replace characters/factors with internal codes


## 3.7: NULL

NULL: Unique type, always length == 0, no attributes
- `is.null()`



# 4. Subsetting

- 6 ways to subset atomic vectors
- 3 subsetting operators: `[[`, `[`, `$`, interact differently with vector types
- Subsetting can be combined with assignment


## 4.2 Selecting multiple elements

`[`: Select any number of elements from a vector.

### 4.2.1: Atomic vectors

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

Postiive integers: return elements at specified positions:

```{r}
x[c(3, 1)]

x[order(x)]

x[c(1, 1)] ## duplicate indcies == duplicate values

x[c(2.1, 2.9)] ## real numbers truncated to integers
```

Negative integers: exclude elements at specified positions

```{r}
x[-c(3, 1)]
```


Can NOT mix pos and neg in single subset

Logical vectors: Select elements where corresponding logical value == TRUE

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]

x[x > 3]
```

IF `x[y]`, x & y are different lengths >>> recycling rules: shorter of two is recycled to the length of longer

```{r}
x[c(TRUE, FALSE)]
x[c(TRUE, FALSE, TRUE, FALSE)]
```

Missing value >>> NA in output


Nothing: returns original vector

Zero: returns zero-length vector

If named vector >>> character vectors: return elements with matching names


```{r}
(y <- setNames(x, letters[1:4]))

y[c("d", "c", "a")]

y[c("a", "a", "a")]

## names must be matched exactly:
z <- c(abc = 1, def = 2)
z[c("a", "d")]
```

Avoid subsetting with factors as use underlying integer vector and NOT the character levels.


### 4.2.2: Lists

`[`: always returns list
`[[` & `$`: pull elements from list

### 4.2.3: Matrices and arrays

Subset matrices & arrays:

- Multiple vectors
- Single vector
- Matrix

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ]

a[c(TRUE, FALSE, TRUE), c("B", "A")]
```
`[` simplifies results to lowest possible dimension. 

```{r}
a[1, ]
a[1, 1]
```

Single vector subsetting: Matrices + arrays are just vectors with special attributes

Arrays in R: column-major order ![](https://en.wikipedia.org/wiki/Row-_and_column-major_order#/media/File:Row_and_column_major_order.svg)

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals

vals[c(4, 15)]
```

Subset with integer matrix or character matrix (if named)" Each row in matrix  = location of one value, each column = dimension in array

```{r}
select <- matrix(ncol = 2, byrow = TRUE,
                 c(1, 1,
                   3, 1,
                   2, 4))

vals[select]
```

### 4.2.4: Data frames and tibbles

Single index: behave as lists >> index columns `df[1:2]` selects first two cols
Two indices: behave as matrices >> `df[1:3, ]` selects first three rows + all cols

Matrix subsetting simplifies by default, list does NOT.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2,]
df[c(1, 3), ]

df[c("x", "z")] ## list
df[, c("x", "z")] ## matrix

str(df["x"]) ## list
str(df[, "x"]) ## matrix

```

Subsetting tibble with `[` always returns tibble:

```{r}
df <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])

str(df["x"])
str(df[, "x"])
```

### 4.2.5: Preserving dimensionality

Preserve original dimensions >>> set `drop = FALSE`

Matrices + arrays: any dimensions with length 1 will be dropped

```{r}
a <- matrix(1:4, nrow = 2)
str(a[1, ])

str(a[1, , drop = FALSE])
```

Data frames with single column: return single column

```{r}
df <- data.frame(a = 1:2, b = 1:2)
str(df[, "a"])

str(df[, "a", drop = FALSE])
```

Tibble: defaults to using `drop = FALSE`

Factors: `drop` argument controls for levels (NOT dimensions) preserved, defaulting to `FALSE`. 

```{r}
z <- factor(c("a", "b"))

z[1]
z[1, drop = TRUE]
```

### exercise

1. Fix errors

```{r}
mtcars[mtcars$cyl = 4, ]
## need double ==
mtcars[mtcars$cyl == 4, ]

mtcars[-1:4, ]
## need to concatenate multiple selection
mtcars[-c(1:4), ]

mtcars[mtcars$cyl <= 5]
## need comma for all cols
mtcars[mtcars$cyl <= 5, ]

mtcars[mtcars$cyl == 4 | 6, ]
## separate filters need to be concatenated
mtcars[mtcars$cyl %in% c(4, 6), ]
```

2. 

```{r}
x <- 1:5
x[NA]

x[NA_real_] # returns single NA
```

`NA` is type: logical, logical vectors are recycled to the same length as vector being subsetted, so 5 `NA` returned.

3. 

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x

x[upper.tri(x)]
```

`upper.tr()` returns logical matrix with `TRUE` for all upper diagonal elements & `FALSE` else.

Subsetting behavior identical to subsetting with logical matrices.

4. `mtcars[1:20]` returns error? How differ from `mtcars[1:20, ]`

```{r}
mtcars[1:20]

mtcars[1:20,]
```

Subsetting a data frame with a single vector: behaves similarly to subsetting a list of cols. When `mtcars[1:20]` >>> return df with first 20 cols. BUT `mtcars` only have 11 cols so error due to index out of bounds. `mtcars[1:20, ]` is subsetted with 2 vectors == 2d subsetting so first index will refer to the rows.


5.



6. `df[is.na(df)] <- 0`?

```{r}
df[is.na(df)] <- 0
```





## 4.3: Selecting a single element

extract single items: `[[` 
shorthand for `x[["y"]]`: `$`   >>> `x$y`



### 4.3.1: `[[`

Ex.

If list `x` is a train carrying objects 
->> `x[[5]]` is the object inside car 5.
->> `x[4:6]` is a train of cars 4-6.

When extracting a single element: 
- Create a smaller train: `x[1]`
- Extract contents of a particular carriage in train: `x[[1]]`

For extracting multiple or zero elements >>> always need to make a smaller train, `[`.

`[[` only returns a single item. Must use single positive integer or single string.
- Vector: subset recursively: `x[[c(1, 2)]]` == `x[[1]][[2]]` >>> use `purrr::pluck()` instead
- Use also for atomic vectors for extrating single values


### 4.3.2: `$`


- Often used to access variables in a df.
- `$` does partial matching
Ex. 

```{r}
x <- list(abc = 1)
x$a
x[["a"]]
```

To avoid >>> set global option: `warnPartialMatchDollar == TRUE`

- tibbles never do partial matching!


### 4.3.3: Missing and out-of-bounds indices

Some inconsistencies when subsetting with `[[` with an invalid index.

`purrr::pluck()` + `purrr::chuck()`

When element is missing: `pluck()` ALWAYS returns `NULL`, `chuck()` throws `Error`

`pluck()` behavior is good for indexing into deeply nested data structures where component that you want may not exist (ex. JSON data from web APIs).

`pluck()` allows for mixed integer + character indices, and alt default value if item does not exist

```{r}
x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

purrr::pluck(x, "c", 1)
purrr::pluck(x, "c", 1, .default = NA)
```

### 4.3.4: `@` and `slot()`

Subsetting for S4 objects.

`@` equivalent to `$` (more restrictive and will return error if slot not exist) and `slot()` equivalent to `[[`


### exercise

1.

```{r}
mtcars

mtcars$cyl[[3]]

mtcars[3, 2]
mtcars[[c(2, 3)]]

mtcars[["cyl"]][[3]]

with(mtcars, cyl[[3]])

mtcars[3, ]$cyl

mtcars[3, "cyl"]

mtcars[3, ][ , "cyl"]
mtcars[3, ][["cyl"]]
```

2.

```{r}
mod <- lm(mpg ~ wt, data = mtcars)

mod$df.residual
mod$df.res

mod["df.residual"]
mod[["df.residual"]]

summary(mod)$r.squared
```

## 4.4: Subsetting and assignment

Subassignment: All subsetting operators can be combined with assignment values of an input vector

`x[i] <- value`

```{r}
x <- 1:5

x

x[c(1, 2)] <- c(101, 102)

x
```

Make sure that `length(value)` == `length(x[i])`. If not, recycle and may cause problems.

Lists: `x[[i]] <- NULL` to remove components, to add NULL: `x[i] <- list(NULL)`

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

y <- list(a = 1, b = 2)
y["b"] <- list(NULL)
str(y)
```

Subsetting with nothing can be useful in assignment as it preserves the structure of the original object.

```{r}
mtcars[] <- lapply(mtcars, as.integer)
mtcars

mtcars <- lapply(mtcars, as.integer)
mtcars
```

## 4.5: Applications

### 4.5.1: Lookup tables (character subsetting)

Ex. convert abbreviations

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x])
```

### 4.5.2: Matching and merging by hand (integer subsetting)


```{r}
grades <- c(1, 2, 2, 3, 1)
info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

grades

info
```

Duplicate `info` so that one row for each value in `grades`

```{r}
id <- match(grades, info$grade)
id

info[id, ]
```

For multiple cols, collapse with `interaction()` or join functions like `merge()` or `dplyr::left_join()`.

### 4.5.3: Random samples and bootstraps (integer subsetting)

Use integer indices to randomly sample/bootstrap a vector/dataframe.

`sample(n)` to generate random permutation of `1:n` then use results to subset values.

```{r}
df <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])

## Randomly reorder
df[sample(nrow(df)), ]

## Select 3 random rows
df[sample(nrow(df), 3), ]

## Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]


```

### 4.5.4: Ordering (integer subsetting)

`order()`: vector input >>> integer vector describing how to order subsetted vector

```{r}
x <- c("b", "c", "a")
order(x)

x[order(x)]
```

Tie-breakers: supply additional variables to `order()`. `decreasing = TRUE/FALSE` option. 

Default: any missing values will be put last. Remove with `na.last = NA` or at front with `na.last = FALSE`.


For 2D or more dimensions >>> order either rows or cols of objects:

```{r}
df
df2 <- df[sample(nrow(df)), 3:1]
df2

df2[order(df2$x), ]

df2[, order(names(df2))]
```


Sort vectors with `sort()` or `dplyr::arrange()` for data frames


### 4.5.5: Expanding aggregated counts (integer subsetting)

Uncollapse identical rows with count columns.
- `rep()` >>> vectorization: `rep(x, y)` repeats `x[i] y[i]` times


```{r}
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

rep(1:nrow(df), df$n)

df[rep(1:nrow(df), df$n), ]
```


### 4.5.6: Removing cols from data frames (character subsetting)

Remove cols from df:
1. Set cols to `NULL`

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df$z <- NULL
df
```

2. Subset to return only columns needed

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[, c("x", "y")]
```


If only know columns you DONT want, use set operations to work out which cols to keep:

```{r}
df[setdiff(names(df), "z")]

df %>% select(-z)
```


### 4.5.7: Select rows based on condition (logical subsetting)

```{r}
mtcars[mtcars$gear == 5, ]
```


```{r}
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```


De Morgan's Laws:

- `!(X & Y) == !X | !Y`
- `!(X | Y) == !X & !Y`

### 4.5.8: Boolean algebra vs. sets

Set operations more effective:
- Searching for the first or last `TRUE`
- Have very few `TRUE` and many `FALSE`, set operation = faster + less storage
- `which()` allows convert boolean to integer representation

```{r}
x <- sample(10) < 4

which(x)

unwhich <- function(x, n) {
  out <- rep_len(FALSE, n)
  out[x] <- TRUE
  out
}

unwhich(which(x), 10)
```

- `X & Y` == `intersect(x, y)`
- `X | Y` == `union(x, y)`
- `X & !Y` == `setdiff(x, y)`
- `xor(X, Y)` == `setdiff(union(x, y), intersect(x, y))`

When logical vector contains `NA`, logical subsetting replaces with `NA` while `which()` drops values.

`x[-which(y)]` NOT equivalent to `x[!y]`: IF y == all FALSE, `which(y)` == `integer(0)`. `-integer(0)` is still `integer(0)` so no values returned.


### exercise

1. Randomly permute df cols? Permute rows and cols at same time?

```{r}
df[sample(ncol(df))]

df[sample(nrow(df)), sample(ncol(df))]
```

2. Select random sample of `m` rows from df.

```{r}
m <- 10
mtcars[sample(nrow(mtcars), m), , drop = FALSE]
mtcars[sample(nrow(mtcars), m), ]
```

Blocked sample:

```{r}
start <- sample(nrow(mtcars) - m + 1, 1)
end <- start + m - 1

start; end

mtcars[start:end, , drop = FALSE]
mtcars[start:end, ]
```

3. Cols in alphabetical order


```{r}
mtcars[order(names(mtcars))]

mtcars %>% select(order(colnames(.)))
mtcars %>% select(order(names(.)))
mtcars %>% select(sort(tidyselect::peek_vars()))
```


# 5. Control flow

- Choices: `if` statements, `switch()` calls >> run different code depending on input
- Loops: `for`, `while` >> repeatedly run code with changing options

1. Difference between `if` and `ifelse()`?

`if` works with scalars
`ifelse()` works with vectors

2.

```{r}
x <- TRUE
y <- if (x) 3
y

x <- FALSE
y <- if (x) 3
y

x <- NA
y <- if (x) 3
y
```

3. 

```{r}
switch("x", x = , y = 2, z = 3)
```

## 5.2 Choices

With single `if` statement, returns `NULL` if condition is `FALSE`. 
- `c()` and `paste()` drop `NULL` inputs: much more compact expressions

### 5.2.1: Invalid inputs

`condition` should evaluate to a SINGLE `TRUE` or `FALSE`

```{r}
if ("x") 1

if (logical()) 1

if (NA) 1
```

Logical vector of length > 1: generates warning

```{r}
if (c(TRUE, FALSE)) 1 
```

Can be turned into error via environment variable.

```{r}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
if (c(TRUE, FALSE)) 1 
```

### 5.2.2: Vectorized if

`ifelse()`: vector of logical values >>> `test`, `yes`, `no`

```{r}
x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))

ifelse(x %% 2 == 0, "EVEN", "ODD")
```

Use for SAME type >>> hard to predict output type if different vectors 

`dplyr::case_when()` 


### 5.2.3: `switch()` statement

```{r}
x_option <- function(x) {
  switch(x,
         a = "option 1",
         b = "option 2",
         c = "option 3",
         stop("Invalid 'x' value"))
}
```

Last component of `switch()` should always throw an error or otherwise unmatched inputs will invisibily return `NULL`

```{r}
(switch("c", a = 1, b = 2))
```

If multiple inputs have same output, leave right-hand side empty and input will fall through to next value.

Use `switch()` only for character inputs.

### exercise

1. 

```{r}
ifelse(TRUE, 1, "no") %>% class()
ifelse(FALSE, 1, "no") %>% class()

ifelse(NA, 1, "no") %>% class()
```

```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"

x <- numeric()

if (length(x)) "not empty" else "empty"
```

`length(x)` evaluates to 0 >>> FALSE


## 5.3 Loops

- Iterate over items in a vector.

`for` (item `in` vector) perform_action

For each item in vector >>> perform_action is called once, updating value of `item` every time.

```{r}
for (i in 1:3) {
  print(i)
}
```

`for` assigns `item` to the CURRENT ENVIRONMENT, overwrites any existing variables with the same name.

Terminate loop early:
- `next` exits current iteration
- `break` exits entire loop


```{r}
for (i in 1:10) {
  if (i < 3)
    next
  print(i)
  
  if (i >= 5) 
    break
}
```

### 5.3.1: Common pitfalls

- Pre-allocate output container for generating data.
- Iterating over `1:length(x)` not work if `x` of length == 0. Use `seq_along()` instead.

```{r}
means <- c(1, 50, 20)

out <- vector("list", length(means))

for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}

out
```

Iteration over S3 vectors >>> loops strip attributes so wrap around with `[[`

```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))

for (i in seq_along(xs)) {
  print(xs[[i]])
}
```

### 5.3.2: Related tools

- `while` (condition) action: performs action while condition == `TRUE`
- `repeat` (action): repeats action forever until `break`

- use `map()` and `apply()`


### exercise

```{r}
x <- numeric() 

out <- vector("list", length(x))

for (i in 1:length(x)) {
  out[i] <- x[i] ^ 2
}

out

for (i in seq_along(x)) {
  out[i] <- x[i] ^ 2
}

out
```


2. 

```{r}
x
xs <- c(1, 2, 3)

for (x in xs) {
  xs <- c(xs, x * 2)
}

xs
```


3. 

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i)
}
```

In a for-loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn’t affect the following iterations.






# 6. Functions


## 6.2 Function fundamentals

- Functions: arguments, body, environment
- Primitive "base" functions >>> C
- Functions are objects


### 6.2.1: Function components

- `formals()`: list of arguments that control how you call the function
- `body()`: code inside the function
- `environment()`: data structure that determines how function finds the values associated with the names

Formals + body specified explicitly, environment implictily (based on where function was defined). Function environment always exists, ONLY printed when function is NOT defined in the global environment.

```{r}
f02 <- function(x, y) {
  # blah
  x + y 
}

formals(f02)
body(f02)
environment(f02)
```

Functions can possess `attributes()`. 
- `srcref`: source reference, source code used to create the function. Contains code comments and other formatting

```{r}
attr(f02, "srcref")
```

### 6.2.2: Primitive functions

type `builtin` or `special`

```{r}
typeof(sum)
typeof(`[`)
```

Exist in C so formals, body, environment all `NULL`.

Only found in `base` package. Performance advantages but harder to write

### 6.2.3: First-class functions

R functions are objects >>> "first-class functions".

Create a function object with `function()` and assign with `<-`

```{r}
f01 <- function(x) {
  sin(1 / x ^ 2)
}
```

Anonymous function: function without name

```{r}
lapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
```

Functions can be placed inside lists.

```{r}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
```

### 6.2.4: Invoking a function

Arguments in data structure >>> use `do.call()` 

```{r}
args <- list(1:10, na.rm = TRUE)

do.call(mean, args)
```

### exercise

1.

NO one-to-one mapping between functions and names. Name points to a single object but object can have many names.


2. 

```{r}
(function(x) 3)()
```

Extra `()` separate function call from anonymous function body

3. Descriptive names for non-anonymous functions. Anonymous functions for conciseness.

4. 

Use `is.function()` to test if object is function. Use `is.primitive()` for specifically primitive functions.


5. 

List all functions in `base`

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```


```{r}
n_args <- funs %>% 
  map(formals) %>% map_int(length) 
  
n_args %>%   
  sort(decreasing = TRUE) %>% head()
```

`scan()` has most arguments.
```{r}
n_args2 <- funs %>% discard(is.primitive) %>% map(formals) %>% map_int(length)

sum(n_args2 == 0)
```

Most no arg functions are primitive functions.

6. body, formals, environment.

7. Primitive and functions created in global environment do NOT print their environment.

## 6.3 Function Composition

```{r}
square <- function(x) x^2
deviation <- function(x) x - mean(x)

## 1. nest function calls:
x <- runif(100)

sqrt(mean(square(deviation(x))))

## 2. save intermediate results as variables
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out

## 3. magrittr pipe 
x %>% 
  deviation() %>% 
  square() %>% 
  mean() %>% 
  sqrt()
```

- Nesting: concise, suited for short sequences. Longer == harder to read >>> inside out + right to left. 
- Intermediate objects: Need to name intermediary objects every time.
- Piping: Left-to-right. Only for linear sequences of transformation of a single object. 


## 6.4 Lexical scoping

Scoping: finding value associated with name.

```{r}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```

Lexical scoping: it looks up the values of names based on how a function is DEFINED, not CALLED. Scoping rules use a parse-time > run-time structure.

4 primary rules:
- Name masking
- Functions vs. variables
- Fresh start
- Dynamic lookup

### 6.4.1: Name masking

Names defined inside a function mask names defined outside a function.

```{r}
x <- 10
y <- 20

g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}

g02()
```

IF name not defined inside function, R looks one level up.

```{r}
x <- 2 

g03 <- function() {
  y <- 1
  c(x, y)
}

g03()

y
```

Functions defined another function. R first looks in the current function, then where function was defined, ..., global environment, other loaded packages.

```{r}
x <- 1
y <- 2084

g04 <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}

g04()
```

### 6.4.2: Functions vs. variables

Scoping rules also apply to functions themselves as functions are objects.

```{r}
g07 <- function(x) x + 1
g08 <- function() {
  g07 <- function(x) x + 100
  g07(10)
}

g08()
```

IF function and non-function share same name (in different environments):
- R ignores non-function objects when looking for value of function call.

```{r}
g09 <- function(x) x + 100
g10 <- function(x) {
  g09 <- 10
  g09(g09)
}
g10()
```

### 6.4.3: Fresh start

Values in between invocations of a function:

Run once, then again:

```{r}
g11 <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

g11()
g11()
```

Returns SAME value. Every time function is called, a NEW environment is created to host its execution! Each invocation is completely independent.

### 6.4.4: Dynamic lookup

R looks for values when function is run NOT when created. Output of function can differ depending on objects outside function environment.

```{r}
g12 <- function() x + 1 
x <- 15
g12()

x <- 20
g12()
```

Detect global environment variables, `codetools::findGlobals()`: Lists all external dependencies (unbound symbols) within function.

```{r}
codetools::findGlobals(g12)
```

Manually change function environment to `emptyenv()`. Empty environment.

```{r}
environment(g12) <- emptyenv()
g12()
```

R relies on lexical scoping to find ALL.

### exercise

1. 

```{r}
c <- 10
c(c = c)
```

c: function call `c()`
c: list name `c`
c: variable R object value `c`


2. 

Lexical scoping:
- Name masking, functions vs. variables, fresh start, dynamic lookup


3. 

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}

f(10)
```

Order of calculation from inside-to-outside!


## 6.5 Lazy evaluation

Functions arguments are lazily evaluated: only evaluated if accessed.

```{r}
h01 <- function(x) {
  10
}

## no erroras 'x' is never used.
h01(stop("This is an error"))
```

### 6.5.1: Promises

Lazy eval powered by `promise`/`thunk` data structure. 

3 components:
- Expression: ex. `x + y`, delayed computation
- Environment: Where expression is evaluated.
-- Variable is bound outside of function

```{r}
y <- 10

h02 <- function(x) {
  y <- 100
  x + 1 
}

h02(y)

h02(y <- 1000)
y
```

- Value: Computed & cached the first time a promise is accessed when expression evaluated in specified environment. Promise is evaluated at most once.

```{r}
double <- function(x) {
  message("Calculating...")
  x * 2
}

h03 <- function(x) {
  c(x, x)
}

h03(double(x))
```

Can not manipulate promises with R code.


### 6.5.2: Default arguments

Default values can be defined in terms of other arguments or variables defined later in function >>> NOT RECOMMENDED. Code harder to understand. 


```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  c(x, y, z)
}

h04()
```

Evaluation environment different between default vs. user-supplied arguments. Defaults are evaluated inside function.


### 6.5.3: Missing arguments

`missing()` to find if user or default:

```{r}
h06 <- function(x = 10) {
  list(missing(x), x)
}

str(h06())
str(h06(10))
```


### exercise

1. `&&` 

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)

x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```
We expect x_ok() to validate its input via certain criteria: it must not be NULL, but have length 1 and a value greater than 0. Meaningful outcomes for this assertion will be TRUE, FALSE or NA. The desired behaviour is reached by combining the assertions through && instead of &.

&& does not perform elementwise comparisons, instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from ?Logic). This means that the RHS of && won’t be evaluated if the LHS already determines the outcome of the comparision (e.g. evaluate to FALSE). This behaviour is also known as ‘shortcircuiting’. For some situations (x = 1) both operators will lead to the same result. But this is not always the case. For x = NULL, the &&-operator will stop after the !is.null-statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of &), the outcome would change. NULL > 0 returns logical(0), which is not helpful in this case.)

We can also see the difference in behaviour, when we set x = 1:3. The &&-operator returns the result from length(x) == 1, which is FALSE. Using & as the logical operator leads to the (vectorised) x > 0 condition being be evaluated and also returned.


2. What does `f2()` return? Why? 

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}

f2()
```

Return `100`. Default argument value can be lazy evaluated within function environment when `x` gets accessed where `x` == `z`.



```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()
y
```

The function returns c(2, 1) which is due to name masking. When x is accessed within c(), the promise x = {y <- 1; 2} is evaluated inside f1()’s environment. y gets bound to the value 1 and the return value of {() (2) gets assigned to x. When y gets accessed next within c(), it has already the value 1 and R doesn’t need to look it up any further. Therefore, the promise y = 0 won’t be evaluated. Also, as y is assigned within f1()’s environment, the value of the global variable y is left untouched.


4. 

```{r}
hist(mtcars$mpg, xlim = c(10, 55))
```

The xlim argument of hist() defines the range of the histogram’s x-axis. In order to provide a valid axis xlim must contain a numeric vector of exactly two unique values. Consequently for the default xlim = range(breaks)), breaks must evaluate to a vector with at least two unique values.

During execution hist() overwrites the breaks argument. The breaks argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore the specific behaviour depends highly on the input. But hist ensures that breaks evaluates to a numeric vector containing at least two unique elements before xlim is computed.




5. 

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
show_time(x = stop("Error!"))
```

Before show_time() accesses x (default stop("Error")), the stop() function is masked by function(...) Sys.time(). Because default arguments are evaluated in the function environment, print(x) will be evaluated as print(Sys.time()).

This function is confusing, because its behaviour changes when x’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of stop won’t affect the outcome any more.



6.

```{r}
library()
```



## 6.6 ...


Functions can have special argument `...`. Can take ANY number of additional arguments. "varargs", "variadic". Use `...` to pass additional arguments to another function. 


```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
```

Can use `..N` to refer to elements of `...` by position. 

`list(...)`: evaluates arguments and stores in list

```{r}
i04 <- function(...) {
  list(...)
}

str(i04(a = 1, b = 2))
```


Primary uses of `...`:

- If function takes a functio nas argument, use as means of passing additional arguments to that function.

Ex. `...` in `lapply()` to pass `na.rm` arg to `mean()`:

```{r}
x <- list(c(1, 3, NA), c(4, NA, 6))
str(lapply(x, mean, na.rm = TRUE))
```

- If function == S3 generic, use to allow methods to take arbitrary extra arguments. 
-- `print()`: different options for printing depending on type of object, no ay to pre-specify EVERY possible argument, so `...` allows individual methods to have different arguments.

```{r}
print(factor(letters), max.levels = 4)
print(y ~ x, showEnv = TRUE)
```

Downsides:

- Necessity to carefully explain where arguments go.
- Misspelled arguments will not raise error!

### exercise

1. 

```{r}
sum(1, 2, 3)
mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE) ## TRUE is evaluated as numeric `1` as 'na.omit' is not a real argument that can be passed on
mean(1, 2, 3, na.omit = TRUE)
```

However, in contrast to sum() the elements of ... are not “part” of the mean. The other supplied arguments are matched by their order, i.e. x = 1, trim = 2 and na.rm = 3. As x is of length 1 and not NA, the settings of trim and na.rm do not affect the calculation of the mean. Both calls (mean(1, 2, 3) and mean(1, 2, 3, na.omit = TRUE)) return 1.


2. 

```{r}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```


## 6.7 Exiting a function

Exit: return value (success) or error (failure). 

### 6.7.1: Implicit vs. explicit returns

Functions return values in 2 ways:

1. Implicitly: where last evaluated expression is return value

2. Explicitly: calling `return()`


### 6.7.2: Invisible values

Most functiosn return visibly: calling function in interactive context prints the result. Prevent automatic printing by applying `invisible()` to last value.

```{r}
j03 <- function() 1
j03()

j04 <- function() invisible(1)
j04()
```

To verify invisibly value actually exists, explicitly `print()`, wrap in `()`, or `withVisible()`

```{r}
print(j04())
(j04())
str(withVisible(j04()))
```

Most common function that returns invisibly `<-` 

```{r}
a <- 2
(a <- 2)

## chain assignments
a <- b <- c <- d <- 2
```

In general: any function called primarily for a SIDE EFFECT (`<-`, `print()`, `plot()`, etc.) should return an invisible value (typically value of first argument).


### 6.7.3: Errors

If function can not complete assigned task >>> error with `stop()`.

### 6.7.4: Exit handlers

Temporary changes to global state >> clean up can be painful esp. if error.

Use `on.exit()` to restore global state no matter how function exits.


```{r}
j06 <- function(x) {
  cat("Hello\n")
  on.exit(cat("Goodbye!\n"), add = TRUE)
  
  if (x) {
    return(10)
  } else {
    stop("Error")
  }
}

j06(TRUE)
j06(FALSE)
```

ALWAYS set `add = TRUE`: else each call to `on.exit()` will overwrite previous exit handler. 

R 3.4: `on.exit()` expressions run in order of creation.
R 3.5: control by setting `after = TRUE/FALSE`.


### exercise

1. `load()` return?

load() loads objects saved to disk in .Rdata files by save(). When run successfully, load() invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to TRUE or surround the call in parentheses to trigger R’s auto-printing mechanism.

2. 

```{r}
print(readr::write_csv(mtcars, here::here("mtcars.csv")))
```


3.

4. 

```{r}
plot_pdf <- function(code) {
  pdf("test.pdf")
  plot(code)
  on.exit(dev.off(), add = TRUE)
  code
}

plot_pdf(mtcars)
```


5. 


```{r}
body(capture.output)
```



## 6.8. Function forms


> Everything that exists is an object.
> Everything that happens is a function call.
- John Chambers

Function call varieties:

- prefix: function name comes before arguments.
-- ex. `footy(a, b, c)`

- infix: function name comes between arguments. Mainly mathematical operators, user-defined functions begin/end in `%`
-- ex. `x + y`

- replacement: functions that replace values by assignment.
-- ex. `names(df) <- c("a", "b", "c")`

- special: `if`, `for`, `[[`, etc.


### 6.8.1: Rewriting to prefix form

Every infix, replacement, special form can be rewritten in prefix form.



```{r}
x + y
`+`(x, y)

names(df) <- c("a", "b", "c")
`names<-`(df, c("a", "b", "c"))

for(i in 1:10) print(i)
`for`(i, 1:10, print(i))
```

Functional programming

```{r}
add <- function(x, y) x + y

lapply(list(1:3, 4:5), add , 3)
## or instead use `+`
lapply(list(1:3, 4:5), `+`, 3)
```


### 6.8.2: Prefix form

Prefix arguments:

- by position `help(mean)`
- by partial matching `help(top = mean)`
- by name `help(topic = mean)`



```{r}
k01 <- function(abcdef, bcde1, bcde2) {
  list (a = abcdef, b1 = bcde1, b2 = bcde2)
}

str(k01(1, 2, 3))
str(k01(2, 3, abcdef = 1))
str(k01(2, 3, a = 1))
```

In general: use positional matching only for first one~two arguments. NEVER use partial matching!

```{r}
options(warnPartialMatchArgs = TRUE)
```

### 6.8.3: Infix functions

Function comes inbetween arguments.

Ex.

`:`, `::`, `:::`, `$`, `^`, `*`, `!=`, `&&`, etc.

Can define own via `%____%`

```{r}
`%+%` <- function(a, b) paste0(a, b)

"new" %+% "string"
```

Need to excape special characters in string for defining function but not when actual call.

```{r}
`% %` <- function(a, b) paste(a, b)
`%/\\%` <- function(a, b) paste(a, b)

"a" % % "b"
"c" %/\% "z"
```
Infix operators are composed left-to-right.

`+` and `-` can be called with a single argument.


### 6.8.4 Replacement functions

Replacement functiosn act like they modify arguments in place >>> `xxx <-` 
- Must have arguments `x` and `value`, must return modified object.

```{r}
`second<-` <- function(y, value) {
  y[2] <- value
  y
}

y <- 1:10
second(y) <- 5L
y

y <- 1:10
tracemem(y)
second(y) <- 6L
```

Create modified copy rather than actually modify arguments in place. If replacement function needs additional arguments, place between `x` and `value`. The additional arguments should e supplied on the left. 

```{r}
`modify<-` <- function(y, position, value) {
  y[position] <- value
  y
}

modify(y, 1) <- 10
y
```


Replacement with other functions translated using `*tmp*` local variable which is removed post-execution.


### 6.8.5 Special forms

All special forms are implemented as primitive functions (in C)

Special forms also have prefix forms:

`(x)` == `(`x))
`{x}` == `{`x))

`x[i]` == (`[`x, i))
`x[[i]]` == (`[[`x, i))

if (cond) true == (`if`(cond, true))
for(var in seq) action == (`for`(var, seq, action))

etc.

Knowing name of function underlying special form is useful for getting docs. 

?`(` rather than ?(

### exercise 

1.

```{r}
1 + 2 + 3

`+`(`+`(1, 2), 3)

1 + (2 + 3)
`+`(1, `+`(2, 3))

x <- c(1, 2, 3, 4, 5, 6, 7)
n <- 3

if (length(x) <= 5) x[[5]] else x[[n]]

`if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, n))
```

2. 

```{r}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

Argument rules: Exact match, partial match, position

```{r}
x <- sample(c(1:10, NA), size = 20, replace = TRUE)
y <- runif(20, min = 0, max = 1)
cor(x, y, use = "pairwise.complete.obs", method = "kendall")
```

3. 

```{r}
modify(get("x"), 1) <- 10

## equivalent to:
get("x") <- `modify<-`(get("x"), 1, 10)
```

There is no corresponding replacements function for `get()`. 


4. Modify reandom location in vector

```{r}
`random<-` <- function(x, value) {
  idx <- sample(length(x), 1)
  
  x[idx] <- value
  x
}

`random<-`(c(4, 5, 6, 7), 10)

x <- c(4, 5, 6, 7)
random(x) <- 69L
```

5. 

```{r}
`+` <- function(a, b = 0L){
  if (is.character(a) && is.character(b)) {
    paste0(a, b)
  } else {
    base::`+`(a, b)  
  }
}

# Test functionality
+ 1
#> [1] 1
1 + 2
#> [1] 3
"a" + "b"
#> [1] "ab"

c("a", "b", "c") + c("d", "e", "f")

# Return back to the original `+` operator
rm(`+`)
```


6. 

```{r}
repls <- apropos("<-", where = TRUE, mode = "function")
repls

repls_base <- repls[names(repls) == length(search())]
repls_base

repls_base_prim <- mget(repls_base, envir = baseenv()) %>% Filter(is.primitive, .) %>% names()
repls_base_prim
```


7. Valid names for user-created infix functions?

Wrap around with `%` but can't contain `%` inside.

8. infix version of `xor()`

```{r}
`%xor%` <- function(a, b) {
  xor(a, b)
}

TRUE %xor% TRUE
FALSE %xor% TRUE
```


8.


```{r}
`%n%` <- function(a, b) {
  base::intersect(a, b)
}

c(2, 4, 6, 8) %n% c(2, 5, 7, 9)
```



# 7 Environments

Environment: Data structure that power scoping. Lexical scoping, namespaces, R6 classes, etc.


## 7.2 Environment basics

Environment: similar to named list with 4 exceptions

- Every name must be unique.
- Names in an environment are NOT ordered.
- Environment has a parent.
- Environments are not copied when modified.

### 7.2.1: Basics

Use `rlang::env()`, works like `list()` taking a set of name-value pairs.

```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3
)

e1[[1]]
e1[c("a", "b")]
```

In Base R: use `new.env()`, use `$<-` to define values.

Environment: associate or bind a set of names to a set of values. "A bag of names" with no implied order. Environments have reference semantics, when modified - they are modified in place and DONT create a copy. Environments can contain themselves.

```{r}
e1$d <- e1

e1 ## only display memory address...
env_print(e1) ## more info

## find character vector of current bindings
env_names(e1)
```

For Base R: use `names()` (for R 3.2.0 and greater).


### 7.2.2: Important environments

Current environment: `current_env()` is environment in which code is currently executing.

Global environment: `global_env()` is enrivonment for when experimenting interactively. "Workspace" where all interactive computation (outside of function) take place.

For environment comparison use `identical()` as `==` is vectorized operator. Environments are NOT vectors.

```{r}
identical(global_env(), current_env())
```

Base R: `globalenv()` (printed as `Rf_GlobalEnv` and `.GlobalEnv`) and `environment()`.

### 7.2.3: Parents

Every environment has a parent. Parent used to implement lexical scoping. IF name is not found in an environment, R then checks in the parent. Set parent environment by supplying an unnamed argument to `env()`, otherwise default to current environment. 

```{r}
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)

env_print(e2b)

env_parent(e2b)
env_parent(e2a)

env_parents(e2b)
```

Empty environment: Has NO parent. `R_EmptyEnv`. Every environment eventually terminate an empty environment. By default, `env_parents()` stops at global environment. Ancestors of global environment include every attached package.

Base R: Use `parent.env()`. 


### 7.2.4: Super assignment

- Regular assignment `<-` creates variable in current environment. 
- Super assignment `<<-` modifies existing variable found in parent environment.

If not find existing variable, will create in global environment. Global variables introduce non-obvious dependencies between functions. 


### 7.2.5: Getting & Setting

Similar to list, get + set elements of environment with `$` and `[[`:

```{r}
e3 <- env(x = 1, y = 2)
e3$x
e3$z <- 3
e3[["z"]]

env_get(e3, "abc")
env_get(e3, "abc", default = NULL)
```

Returns `NULL` if binding does not exist. Set default with `default` argument. 

Can NOT use `[[` with numeric indices or `[`.


`env_poke()`: take name as string and a value:

```{r}
env_poke(e3, "a", 100)
e3$a
```

`env_bind()`: Bind multiple values:


```{r}
env_bind(e3, a = 10, b = 20)
env_names(e3)
```

`env_has()`: determine if environment has binding: 

```{r}
env_has(e3, "a")
```

Unlike lists, setting element == `NULL` does NOT remove it. Sometimes you want a name that refers to `NULL`. Use `env_unbind()` instead.

```{r}
e3$a <- NULL
env_has(e3, "a")

env_unbind(e3, "a")
env_has(e3, "a")
```

Unbinding does NOT delete object >> garbage collector.

Base R: `get()`, `assign()`, `exists()`, `rm()` for current environment.

### 7.2.6: Advanced bindings

`env_bind_lazy()`: Creates "delayed bindings" - which are evaluated the first time they are accessed. Delayed bindings create promises, behave similarly to function arguments. 

```{r}
env_bind_lazy(current_env(), b = {Sys.sleep(1); 1})

system.time(print(b))
system.time(print(b))
```

Main use for `autoload()`, allows R packages to provide datasets that behave as though loaded in memory even though only loaded from disk when needed.

`env_bind_active()`: Creates "active bindings" - re-computed every time they're accessed. Used to implement R6's active fields. 

```{r}
env_bind_active(current_env(), z1 = function(val) runif(1))

z1
z1
```

Base R: `delayedAssign()` and `makeActiveBinding()`.


### exercise


1. Differences: Environments vs. lists

- Environments have reference semantics (do NOT copy-on-modify)
- Environments have parents
- Environment elements are NOT ordered
- Environment elements must have unique names

2. 

```{r}
e1 <- env()
e1$loop <- e1

env_print(e1)
```


3. 

```{r}
e1 <- env()
e2 <- env()

e1$loop <- e2
e2$dedoop <- e1

env_print(e1)
env_print(e2)
```

4. 

```{r}
env_print(e1)
```


Environments have no ordered elements. Environments return 2 objects at the same time.


5. Single assignment for `env_poke()`


```{r}
env_poke2 <- function(env, name, value) {
  if (env_has(env, name)) {
    abort(paste0("\"", name, "\" is already assigned to a value."))
  }

  env_poke(env, name, value)
  invisible(env)
}

# Test
env_1 <- env(a = 1)
env_poke2(env_1, "b", 2)
env_names(env_1)
#> [1] "a" "b"
env_poke2(env_1, "b", 2)
#> Error: "b" is already assigned to a value.
```


6. 

```{r}
rebind <- function(name, value, env = caller_env()) {
  if (identical(env, empty_env())) {
    stop("Can't find `", name, "`", call. = FALSE)
  } else if (env_has(env, name)) {
    env_poke(env, name, value)
  } else {
    rebind(name, value, env_parent(env))
  }
}
rebind("a", 10)
#> Error: Can't find `a`
a <- 5
rebind("a", 10)
a
#> [1] 10
```


The primary differnce between rebind() and <<- is that rebind() will only carry out an assignment when it finds an existing binding; unlike <<- it will never create a new one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions.



## 7.3 Recursing over environments

Recursive function: operate on every ancestor of an environment. 

- `where()`:

```{r}
where <- function(name, env = caller_env()) {
  if (identical(env, empty_env)) {
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name)) {
    env
  } else {
    where(name, env_parent(env))
  }
}
```

Base: Reached empty environment and haven't found binding >>> throw error.
Success: Name exists in this environment >>> return environment
Recursive: Name not found in environment >>> try parent environment

```{r}
where("yyy")

x <- 5
where("x")

where("mean")
```

Iterative version:

```{r}
f2 <- function(..., env = caller_env()) {
  while (!identical(env, empty_env))) {
    if (success) {
      return()
    }
    env <- env_parent(env)
  }
  ## base case
}
```



### exercise

1. 

```{r}
where2 <- function(name, env = caller_env(), results = list()) {
  if (identical(env, empty_env())) {
    # Base case
    results
  } else {
    # Recursive case
    if (env_has(env, name)) {
      results <- c(results, env)
    }
    where2(name, env_parent(env), results)
  }
}

# Test
e1a <- env(empty_env(), a = 1, b = 2)
e1b <- env(e1a, b = 10, c = 11)
e1c <- env(e1b, a = 12, d = 13)

where2("a", e1c)
```




2. 


```{r}
fget <- function(name, env = caller_env(), inherits = TRUE) {
  # Base case
  if (env_has(env, name)) {
    obj <- env_get(env, name)

    if (is.function(obj)) {
      return(obj)
    }
  }

  if (identical(env, emptyenv()) || !inherits) {
    stop("Could not find function called \"", name, "\"",
         call. = FALSE)
  }

  # Recursive Case
  fget(name, env_parent(env))
}

# Test
mean <- 10
fget("mean", inherits = TRUE)
#> function (x, ...) 
#> UseMethod("mean")
#> <bytecode: 0x1899b78>
#> <environment: namespace:base>
```






## 7.4 Special environments


Most environments are created by R rather than the user. 


### 7.4.1: Package environments and search path

Each package attached by `library()` or `require()` becomes one of the parents of the global environment. Immediate parent of the global environment is the LAST package that was attached, then the second to last, etc.

Search path: order of packages attached, can be found from top-level interactive workspace.

```{r}
search()

search_envs()
```

Last 2 environments on search path are always the same:
-`Autoloads` environment: uses delayed bindings to save memory by only loading package objects when needed
- `base` environment: package:base. Access with `base_env()`


### 7.4.2: Function environment

A function binds the current environment when it is created, used for lexical scoping. Across computer languages, functions that capture/enclose their environments are called `closures`.

```{r}
y <- 1
f <- function(x) x + y 

fn_env(f)
```

Base R: use `environment()`


### 7.4.3: Namespaces 

- Prevent packages from finding different functions if loaded in different order. Every package works the same way regardless of what packages are attached by the user, and their order. 

```{r}
sd
```

Every function in a package is associated with a PAIR of environments

- Package environment: external interface to the package. Parent determined by search path. How user finds a function in an attached package or with `::`. Controls how we find function.
- Namespace environment: internal interface to the package. Controls how function finds its variables. 

Every binding in package environment is also found in namespace environment. Ensures EVERY function can use every other function in the package. Some bindings only occur in the namespace environment >> internal or non-exported objects. Allows for hide internal implementation details from the user.

Every namespace environment has same set of ancestors:

- `imports` environment that contains bindings to all functions used by the package. Imports environment is controlled with the `NAMESPACE` file.
- Parent of the imports environment is the `base namespace`. Contains same bindings as the base environment but has different parent.
- Global environment: Parent of `base namespace`. If binding isn't defined in imports environment, the package willl look in usual way, up the parents. 

Argument value found in sequence of environments determined by package developer, NOT the user. Code always works same way regardless of what packages have been attached by the user. 


### 7.4.4: Execution environments

```{r}
g <- function(x) {
  if (!env_has(current_env(), "a")) {
    message("Defining a")
    a <- 1
  } else {
    a <- a + 1
  }
  a
}
```

Returns SAME, every run due to 'fresh start principle'. Each tie the function is called, a new environment is created to host its execution. 

To have function environment stay longer:
- Explicitly return it: `current_env()`
- Return an object with a binding to that environment, ex. function >>> function factory

### exercise

1. 

```{r}
search_envs() # returns global, ALL environments on search path. 

env_parents(global_env()) # not return global, empty included. List ALL ancestors of global environment
```



## 7.5 Call stacks

Caller environment: accessed with `rlang::caller_env()`. Provides environment from which function was called and varies based on how function is called, NOT how function was created. 

Base R: `parent.frame()`


Executing function creates two types of context:
- Execution environment is child of function environment is de etermined by WHERE function was CREATED.
- Call stack created by WHERE function was CALLED. 


### 7.5.1: Simple call stacks

`f()` calls `g()` calls `h()`

```{r}
f <- function(x) {
  g(x = 2)
}

g <- function(x) {
  h(x = 3)
}

h <- function(x) {
  stop()
}

f(x = 1)
traceback()
```

Use `lobstr::cst()`: opposite order from `traceback(). Sequence of calls from beginning rather than end.

```{r}
h <- function(x) {
  lobstr::cst()
}

f(x = 1)
```

### 7.5.2: Lazy evaluation

```{r}
a <- function(x) b(x)
b <- function(x) c(x)
c <- function(x) x

a(f())
```

x is laziy evaluated so two separate branches. 

- Branch #1: `a()` calls `b()`,  then `b()` calls `c()`
- Branch #2: When `c()` evaluates its argument `x`. Argument evaluated in new branch as environment in which it is evaluated is the global environment, NOT environment of `c()`. 

### 7.5.3: Frames

Frame: each element of a call stack, evaluation context. 

3 key components: 
- Expression `expr` giving function call. What `traceback()` prints out.
- Environment `env` typically execution environment of a function. 
-- 2 exceptions: Global frame == global environment. Calling `eval()` generates frames where environment can be anything
- Parent: the previous call in the call stack.



### 7.5.4: Dynamic scope

Dynamic scoping: Looking up variables in the calling stack > enclosing environment

Dynamic scoping makes it harder to reason about how a function operates. Need to know how it was defined AND know context in which it is called. 


### exercise


```{r}
ls(all.names = TRUE)

ls2 <- function(env = caller_env()) {
  sort(env_names(env))
}

ls2()
```

## 7.6 As data structures


Environments useful as data structures as they have reference semantics. 

- Avoid copies of large data: Environments have reference semantics so never accidentally create a copy. Use `R6` objects as bare environments are difficult to work with.

- Managing state within a package: Explicit environments are useful in packages as can maintain state across function calls. Objects in packages are locked - can't modify directly.

```{r}
my_env <- new.env(parent = emptyenv())
my_env$a <- 1

get_a <- function() {
  my_env$a
}

set_a <- function(value) {
  old <- my_env$a
  my_env$a <- value
  invisible(old)
}

set_a(5)

my_env$a
```

- Hashmap: data structure that takes a constant, `O(1)`, time to find object based on its name. 


# 8 Conditions

Condition system: provides a paired set of tools that allow author of cuntion to indicate something unusual is happening >> tells user of function to deal with it.

- Function author signals conditions with functions like `stop()`, `warning()`, `message()`, then the function user can handle them with functions like `tryCatch()` and `withCallingHandlers()`. 

- Signal conditions from functions created AND handle conditions signalled by the functions called

R base conditions system on Common Lisp. 

## 8.2 Signalling conditions

3 conditions that you can signal in code: errors, warnings, messages

- Errors: most severe, indicate that no way for function to continue, must stop.
- Warnings: Indicate that something has gone wrong but function has partially recovered
- Message: Inform users that some action has been performed on their behalf.

Interrupt: User interrupted execution by pressing `Esc`, `Ctrl+Break`, `Ctrl+C`. 

### 8.2.1: Errors

Base R: `stop()`

By default, error message includes the call, but typicall not useful. Use `traceback()`. Use `call. = FALSE` to not include call.

{rlang} equivalent: `abort()`, use `glue::glue()` for construct complex error messages.

```{r}
h <- function() abort("This is an error!")
h()
```

Error mesages: Describe what is wrong + point towards fixing problem.
- Difficulty from developer and user to imagine other perspective.

### 8.2.2: Warnings 

Warnings: signal something gone wrong but code recover and continue. Can have multiple warnings in a single function call.

```{r}
fw <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warning("W3")
}

fw()
```

`option()`: 

- `warn = 1`: warnings appear immediately
- `warn = 2`: warnings into errors
- `warn = 0`: restore default behavior

- suppress call with `call. = FALSE` argument
- {rlang}: `warn()`

- Deprecate function: allow older code to continue but encourage usage of new function
- Recovery: If certain that can recover from problem, otherwise throw error.


### 8.2.3: Messages

Messages: informational, tell users something done on their behalf. Displayed immediately and do not have `call.` argument.

- Default argument requires some non-trivial amount of computation >>> tell user what value was used. Ex. {ggplot2} reports # of bins if no `binwidth` supplied.

- Functions called primarily for side-effects which would otherwise be silent. Ex. Files to disk, web API, writing to DB >>> provide status messages to tell what's happening to user. 

- Long running process with no intermediate output >>> progress bar may be better.

- Display message when package is loaded `packageStartupMessage()`

Any function producing message should provide some way to suppress it. 

- `cat()`: WHen primary role of function is to print to console.
-- Ex. `print()`, `str()` methods

- `message()`: Print to console when primary purpose of function is something else.

`cat()` is for when user ASKS for something to be printed. `message()` for when developer `elects()` to print something. 


### exercise 

1. 

```{r}
file_remove_strict <- function(path) {
  if (!file.exists(path)) {
    stop("Can't delete the file '", path, "' because it doesn't exist.",
         call. = FALSE)
  }
  file.remove(path)
}
```


2. 

The appendLF argument automatically appends a new line to the message.

```{r}
multiline_msg <- function(appendLF = TRUE) {
  message("first", appendLF = appendLF)
  cat("second")
  cat("third")
}

multiline_msg(appendLF = TRUE)
#> first
#> secondthird
multiline_msg(appendLF = FALSE)
#> first
#> secondthird
```


## 8.3 Ignoring conditions

- `try()`: ignore errors
- `suppressWarnings()`: ignore warnings
- `suppressMessages()`: ignore messages

`try()`: allows for execution to continue even after error occur. Error message will display. Do assignment in call, define a default value to be used IF code NOT succeed. Argument evaluated in calling environment and NOT inside function.

```{r}
default <- NULL
try(default <- read.csv("blah-blah.csv"), silent = TRUE)
default
```

## 8.4 Handling conditions

Every condition has default behavior. Condition handlers allow temporary override/supplement to default behavior.

`tryCatch()` & `withCallingHandlers()`: Register handlers - functiosn that take signalled conditoin as their single argument.

```{r}
tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning signalled
  },
  message = function(cnd) {
    # code to run when message signalled
  },
  code_to_run_while_handlers_are_active
)
```


- `tryCatch()`: defines exiting handlers, after condition is handled, control returns to context where `tryCatch()` was called. Most suitable for workign with errors + interrupts.

- `withCallingHandlers()`: defines calling handlers - after condition is captured, control returns to context where condition was signalled. Most suitable for working with non-error conditions.

Condition objects: created implicitly when signal condition, becomes explicit inside handler.

### 8.4.1: Condition objects

`rlang::catch_cnd()`: view condition object by catching from signalled condition

```{r}
cnd <- catch_cnd(stop("an error"))

str(cnd)
```

- Build-in conditions are lists with two elements:
-- message: length-1 character ector containing text to display to user >> extract with `conditionMesasge(cnd)`
-- call: call which triggered the condition >> extract with `conditionCall(cnd)`

- Conditions have "class" attribute (character vector) >>> S3 objects. Determines which nalders will match the condition.

### 8.4.2: Exiting handlers 

`tryCatch()` registers exiting handlers >>> allows override default error behavior. 

```{r}
f3 <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    log(x)
  )
}

## return NA instead of throw error
f3("x")
```

If NO conditions signalled OR class of signalled condition NOT match handler name, code executes normally. 

Handlers set up by `tryCatch()` called exiting handlers: After condition is signalled, control passes to the handler and never returns to the original code - effectively the code exits at this point.

```{r}
tryCatch(
  message = function(cnd) "There",
  {
    message("Here")
    stop("This code is never run!")
  }
)
```

Protected code is evaluated in environment of `tryCatch()` but handler code is NOT as handlers are functions. 

Handler function has single argument, condition object `cnd`. Useful when create own custom conditions. 

```{r}
tryCatch(
  error = function(cnd) {
    paste0("-haha-", conditionMessage(cnd), "-haha-")
  },
  stop("This is an error")
)
```

`finally` argument: Specifies block of code to run regardless of whether initial expression succeeds or fails. Ex. clean up: delete files, close connections, etc. Equivalent to `on.exit()`.


### 8.4.3: Calling handlers

`withCallingHandlers()`: set up calling handlers, code execution continues normally once the handler returns. Use for non-error conditions. 

- Exiting handler: Handles signal by making problem go away
- Calling handler: Handles signal by keeping it.

Handlers are applied in order. 

```{r}
tryCatch(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)

withCallingHandlers(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)
```

Return value of a calling handler is ignored because the code continuse to execute after handler completes. Handlers only useful for side-effects.

Muffle: Prevent condition from bubbbling up to parent handlers but still run rest of code in block, explicitly muffle it with `rlang::cnd_muffle()`



### 8.4.4: Call stacks

Call statcks of exiting and calling handlers are different!

```{r}
f <- function() g()
g <- function() h()
h <- function() message("!")
```

* Calling handlers: called in context of the call that signalled the condition
* Exiting handlers: called in context of the call to `tryCatch()`

```{r}
withCallingHandlers(f(), message = function(cnd) {
  lobstr::cst()
  cnd_muffle(cnd)
})

tryCatch(f(), message = function(cnd) lobstr::cst())
```


### exercise 

1. Info from `abort()` vs. `stop()`?

```{r}
?abort()
?stop()
```

`abort()`: does not include call info by default. Backtrace always saved into error objects. Supply metadata `...` arg, create classed condition `class` arg. 

2. 

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}
```


```{r}
show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

3. 

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

`message()` shows message but also keeps running rest of the code. b > a then b > c

4. 

`catch_cnd()`: captures any condition signalled while evaluating its argument. Useful when expect specific condition to be signalled for debugging/unit testing.

```{r}
catch_cnd(10)
catch_cnd(abort("errores"))
catch_cnd(signal("condiciones", message = "mamma mia"))
```
5. 

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
      cnd_muffle("cnd")
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

## 8.5 Custom conditions

Most functions generate one of the built-in conditions >> contain only message and call. If want to detect a certain type of error >> can only work with TEXT of the error message. Messages can change and translation issues. However, can create custom conditions containing useful metadata. Use `rlang::abort()` to supply `.subclass` and other metadata. 


### 8.5.1: Motivation

`base::log()`: absolute minimum for errors caused by invalid args.

```{r}
log(letters)
log(1:10, base = letters)
```

Be more explicit about WHICH argument is the problem and say what the problematic input is. 

```{r}
my_log <- function(x, base = exp(1)) {
  if (!is.numeric(x)) {
    abort(paste0(
      "'x' must be a numeric vector; not ", typeof(x), "."
    ))
  }
  if (!is.numeric(base)) {
    abort(paste0(
      "'base' must be a numeric vector; not ", typeof(base), "."
    ))
  }
  base::log(x, base = base)
}

my_log(letters)
my_log(1:10, base = letters)
```

### 8.5.2: Signalling

Still all metadata about error is in single string... need to build more infrastructure. Create custom `abort()` function for bad arguments. Create nice error message for user and store metadata in the condition call for the developer. 

```{r}
abort_bad_argument <- function(arg, must, not = NULL) {
  msg <- glue::glue("'{arg}' must {must}")
  if (!is.null(not)) {
    not <- typeof(not)
    msg <- glue::glue("{msg}; not {not}")
  }
  abort("error_bad_argument",
        message = msg,
        arg = arg,
        must = must, 
        not = not)
}

my_log <- function(x, base = exp(1)) {
  if (!is.numeric(x)) {
    abort_bad_argument("x", must = "be numeric", not = x)
  }
  if (!is.numeric(base)) {
    abort_bad_argument("base", must = "be numeric", not = base)
  }
  base::log(x, base = base)
} 

my_log(letters)
my_log(1:10, base = letters)
```

### 8.5.3: Handling

Same interactive error messages but much easier to program with. 

Capture error, then assert it has structure we expect:

```{r}
library(testthat)

err <- catch_cnd(my_log("a"))

err

expect_s3_class(err, "error_bad_argument")
expect_equal(err$arg, "x")
expect_equal(err$not, "character")
```


Class: `error_bad_argument` in `tryCatch()` to only handle that specific error:

```{r}
tryCatch(
  error_bad_argument = function(cnd) "bad_argument",
  error = function(cnd) "other error",
  my_log("a")
)
```

For `tryCatch()` with multiple handlers and custom classes, the FIRST handler to match any class in signal's class vector is called, not necessarily the best match. So necessary to put most specific handlers first.


### exercise 


1.

```{r}
check_installed <- function(package) {
  if (!requireNamespace(package, quietly = FALSE)) {
    abort(
      "error_pkg_not_found",
      message = paste0("package '", package, "' not installed."),
      package = package
    )
  }
  TRUE
}

check_installed("ggplot2")
check_installed("ggplot69")

```

2. Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

Instead returning an error it might be preferable to throw a customized condition and place a standardized error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.

## 8.6 Applications

### 8.6.1: Failure value

Wrapper to return a default if error occurs:

```{r}
fail_with <- function(expr, value = NULL) {
  tryCatch(
    error = function(cnd) value, 
    expr
  )
}

fail_with(log(10), NA_real_)
fail_with(log("a"), NA_real_)
```

### 8.6.2: Success and failure values

`success_val` and `error_val` 

```{r}
foo <- function(expr) {
  tryCatch(
    error = function(cnd) error_val,
    {
      expr
      success_val
    }
  )
}
```


### 8.6.3: Resignal 

Return default values when condition is signalled, handlers used to make more informative error messages.

Ex. warnings into errors

```{r}
warning2error <- function(expr) {
  withCallingHandlers(
    warning = function(cnd) abort(conditionMessage(cnd)),
    expr
  )
}

warning2error({
  x <- 2 ^ 4
  warn("Hello!")
})
```


### 8.6.4: Record

Record conditiosn for later investigation. Modify object in place and not return values.

```{r}
catch_cnds <- function(expr) {
  conds <- list()
  add_cond <- function(cnd) {
    conds <<- append(conds, list(cnd))
    cnd_muffle(cnd)
  }
  withCallingHandlers(
    message = add_cond,
    warning = add_cond,
    expr
  )
  conds
}

catch_cnds({
  inform("a")
  warn("b")
  inform("c")
})
```

Also capture errors: 


```{r}
catch_cnds <- function(expr) {
  conds <- list()
  add_cond <- function(cnd) {
    conds <<- append(conds, list(cnd))
    cnd_muffle(cnd)
  }
  tryCatch(
    error = function(cnd) {
      conds <<- append(conds, list(cnd))
    },
    withCallingHandlers(
      message = add_cond,
      warning = add_cond,
      expr
    )
  )
  conds
}

catch_cnds({
  inform("a")
  warn("b")
  abort("C")
})
```


### 8.6.5: No default behavior

Signal condition that doesn't inherit from `message`, `warning`, or `error`. Condition has no effect unless user specifically request it. 

```{r}
log <- function(message, level = c("info", "error", "fatal")) {
  level <- match.arg(level)
  signal(message, "log", level = level)
}

## no default handler...
log("This code was run") 
```

Activate logging >>> do something for "log" condition.

```{r}
record_log <- function(expr, path = stdout()) {
  withCallingHandlers(
    log = function(cnd) { ## define what to do for `log` condition
      cat(
        "[", cnd$level, "]", cnd$message, "\n", sep = "", 
        file = path, append = TRUE
      )
    },
    expr
  )
}

record_log(log("Hello there!"))
```

Suppress certain log levels:

```{r}
ignore_log_levels <- function(expr, levels) {
  withCallingHandlers(
    log = function(cnd) {
      if (cnd$level %in% levels) {
        cnd_muffle(cnd)
      }
    },
    expr
  )
}

record_log(ignore_log_levels(log("Hello there!"), "info"))
```



### exercise 

Catch errors but suppress error message. 

```{r}
suppressErrors <- function(expr) {
  tryCatch(
    error = function(cnd) invisible(cnd),
    interrupt = function(cnd) stop("Terminated by the user",
                                   call. = FALSE),
    expr
  )
}

suppressConditions <- function(expr) {
  suppressErrors(suppressWarnings(suppressMessages(expr)))
}

error_obj <- suppressConditions({
    message("message")
    warning("warning")
    abort("error")
  })

error_obj
```

2. 







# II. Functional Programming

First-class functions: functions that behave like any other data structure. Do same things with function as you do with a vector. Assign as variables, store in list, pass as arguments to other functions, create inside functions, return as result of function, etc.

Pure: 
- output ONLY depends on inputs. If called with same inputs always produce the same outputs. Exclude `runif()`, `Sys.time()`, etc.
- Has NO side-effects, no changing value of a global variable, no writing to disk, no display to screen. Exclude `print()`, `<-`, etc.

## Functional style

Decomposing a big problem into smaller pieces. Operate independently. 


# 9 Functionals 

Functional: Function that takes function as input and returns vectors as output. 

```{r}
randomize <- function(f) f(runif(1e3))

randomize(mean)
randomize(mean)
randomize(mean)
randomize(sum)
```

Replace `for` with functionals. 

## 9.2 `map()`

`purrr::map()`: takes vector and function >>> calls function once for each element of the vector and returns results in list. 

`map(1:3, f)` == `list(f(1), f(2), f(3))`

```{r}
triple <- function(x) x * 3
map(1:3, triple)
```

- Allocate a list the same length as input, then fill in the list with a `for` loop. 

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

`map()` written in C, preserves names, supports shortcuts.

Base R: `lapply()`. 

### 9.2.1: Producing atomic vectors 

Simpler variants of `map()` to return atomic vector of different types: `map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`. 

All map functions always return an output vector the same length as the input >>> implies each call to `.f` must return a single value. If not >>> ERROR.

Base R: `sapply()` and `vapply()`. Avoid `sapply()` as simplify result into list, vector, or matrix. `vapply()` use `FUN.VALUE` to describe output shape.

```{r}
x <- c(25, 40, 585, 48, 202, 2)

map_dbl(x, mean, na.rm = TRUE)

vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))
```


### 9.2.2: Anonymous functions & shortcuts 

Use inline anonymous functions instead of existing functions. 

```{r}
map_dbl(mtcars, function(x) length(unique(x)))
```

Shortcut `~`

```{r}
map_dbl(mtcars, ~ length(unique(x)))
```

Shortcuts for extracting elements from a vector >>> `purrr::pluck()`. Use character vector to select elements by name, integer vector to select by position, list to select by both name and position. Useful for nested lists >> JSON.

```{r}
x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

map_dbl(x, "x")
map_dbl(x, 1)
map_dbl(x, list("y", 2), .default = NA)
```

### 9.2.3: Passing arguments with `...`

Pass additional arguments.

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
map_dbl(x, mean, na.rm = TRUE)
```

Any arguments after `.f` the function are inserted after the data in individual calls to `f()`

### 9.2.4: Argument names

Write out full argument names in code for better understanding. Be careful of `f` and `x` arguments as they can clash, `purrr()` uses `.f` and `.x` to avoid such mishaps.

### 9.2.5: Varying another argument

First argument of `map()` >>> first argument of function. BUT what if want first argument to be a constant and vary a different argument?

Use anonymous function to rearrange the argument order:

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

map_dbl(trims, ~ mean(x, trim = .x))
map_dbl(trims, function(trim) mean(x, trim = trim))
```

### exercise 

1. `as_mapper()`

map() offers multiple ways (functions, formulas and extractor functions) to specify the function argument (.f). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of as_mapper() and it is called every time map() is used.

Given character, numeric or list input as_mapper() will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.

The extractor function is implemented as a call to purrr::pluck(), which accepts a list of accessors (accessors “access” some part of your data object).


2. `map(1:3, ~ runif(2))` vs. `map(1:3, runif(2))`

The first pattern creates multiple random numbers, because ~ runif(2) successfully uses the formula interface. Internally map() applies as_mapper() to this formula, which converts ~ runif(2) into an anonymous function. Afterwards runif(2) is applied three times (one time during each iteration), leading to three different pairs of random numbers.

```{r}
map(1:3, ~ runif(2))
```


In the second pattern runif(2) is evaluated once, then the results are passed to map(). Consequently as_mapper() creates an extractor function based on the return values from runif(2) (via pluck()). This leads to three NULLs (pluck()’s .default return), because no values corresponding to the index can be found.

```{r}
map(1:3, runif(2))
```

3. 

```{r}
map_dbl(mtcars, ~ sd(.))

mtcars_num <- map_lgl(mtcars, is.numeric)
map_dbl(mtcars[mtcars_num], sd)

mtcars_factor <- map_lgl(mtcars, is.factor)
map_int(mtcars[mtcars_factor], ~ length(levels(.x)))
```

4. 

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))

library(ggplot2)

trials_df <- tibble(p_value = map_dbl(trials, "p.value"))

trials_df %>% 
  ggplot(aes(x = p_value, fill = p_value < 0.05)) + 
  geom_histogram(binwidth = .01) +
  ggtitle("Distribution of p-values for random poisson data.")
```


5. 


6.

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

models <- map(formulas, lm, data = mtcars)
```

7. 

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

bootstraps %>% 
  map(~ lm(mpg ~ disp, data = .x)) %>% 
  map(summary) %>% 
  map_dbl("r.squared")
```


## 9.3 Purrr style

Example problem: fit model to each subgroup and extract coefficient for model. 

Split by # of cylinders:

```{r}
by_cyl <- split(mtcars, mtcars$cyl)
```

List of 3 dfs >> 4, 6, 8 cylinders

Extract slope from each model:

```{r}
by_cyl %>% 
  map(~ lm(mpg ~ wt, data = .x)) %>% 
  map(coef) %>% 
  map_dbl(2)
```


Base R: 

```{r}
models <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))

vapply(models, function(x) coef(x)[[2]], double(1))

## for loop:
intercepts <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  intercepts[[i]] <- coef(model)[[2]]
}

intercepts
```

## 9.4 Map variants

### 9.4.1: `modify()`: same type of output as input

Ex. double every column in a df.

`map()` returns list >>> use `modify()` to keep output as df.

```{r}
df <- data.frame(x = 1:3, y = 6:4)
modify(df, ~ .x * 2)
```


### 9.4.2: Two inputs 

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

`map()` not pass additional arguments as anything after `.f` are not transformed. Need variant that vectorizes over two arguments >>> `.x` and `.y`

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

arguemtns go before function `.f`, all additional arguments go after `.f`. 





### 9.4.3: No outputs

Most functions called for value returned. Some functions only called for SIDE-EFFECTS so not need returned results. Ex. `cat()`, `write.csv()`, `ggsave()`. 

```{r}
welcome <- function(x) {
  cat("Welcome ", x, "!\n", sep = "")
}

names <- c("Hadley", "Jenny")

map(names, welcome)

walk(names, welcome)
```

`walk2()`: useful for saving to disk. >>> object and path name

```{r}
temp <- tempfile() 
di.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)
dir(temp)
```

Base R: wrap result of `lapply()` in `invisible()` or save in unused variable.


### 9.4.4: Iterating over values and indices

`for` loop:
- loop over elements: `for (x in xs)` >>> `map()`
- loop over the numeric indices: `for (i in seq_along(xs))` >>> `imap()`
- loop over the names: `for (nm in names(xs))` >>> `imap()`

`imap(x, f)` == `map2(x, names(x), f)` if x has names OR `map2(x, seq_along(x), f)`.

```{r}
imap_chr(iris, ~ paste0("The first value of ", .y, " is ", .x[[1]]))
```

IF vector is unnamed, 2nd argument == index.

```{r}
x <- map(1:6, ~ sample(1000, 10))
imap_chr(x, ~ paste0("The highest value of ", .y, " is ", max(.x)))
```

### 9.4.5 Any number of inputs


`pmap()`: supply with single list of any number of arguments. 

- `pmap(list(x, y), f)` == `map2(x, y, f)`

Allow more control over argument matching as can name the components of the list.

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

pmap_dbl(list(trim = trims), mean, x = x)
```

- Easy to call `pmap()` with data frame >>> `tibble::tribble()`

```{r}
params <- tibble::tribble(
  ~ n, ~ min, ~ max,
  1L,      0,     1,
  2L,     10,   100,
  3L,    100,  1000
)

pmap(params, runif)
```

Base R: 

use `Map()` and `mapply()`


### exercise 

1. 


```{r}
mtcars
modify(mtcars, 2)
```

Extracts the 'x' index by position but keeps the output the same as the input. In this case it grabs the data from the 2nd row but keeps it in the same df format which means that the 2nd row data is recycled to all the other rows.


2. 

```{r}
temp <- tempfile()
dir.create(temp)
cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)


imap(cyls, write.csv)
```

Shows output returns



3. 

```{r}
mtcars
trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, labels = c("auto", "manual"))
)

nm <- names(trans)
mtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))
```

apply each of the functions in `trans` to the columns `nm` from mtcars 

4.

map() and write.csv() returns NULL of length input vector while walk2() returns invisibly




## 9.5 reduce

`reduce()`: takes vector lenght == n and produces vector of length == 1 by calling a function with a pair of values at a time.

Generalize function that works with two inputs >>> work with any # of inputs.

Ex. for list of numeric vectors, find values intersect in every element.


```{r}
l <- map(1:4, ~ sample(1:10, 15, replace = TRUE))
str(l)

## no need to repeatedly call `intersect()`
reduce(l, intersect)
reduce(l, union)
```

Can pass additional arguments. 

```{r}
simple_reduce <- function(x, f) {
  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}
```


Base R: `Reduce()` >>> no supplying of additional arguments


### 9.5.2: Accumulate

`accumulate()`: returns all intermediate results 

```{r}
accumulate(l, intersect)
```

Similar to cumulative sum:

```{r}
x <- c(4, 3, 10)
reduce(x, `+`)
accumulate(x, `+`)
```

### 9.5.3: Output types

When length == 1 or 0, without additional arguments, `reduce()` simply returns input when x == 1.

```{r}
reduce(1, `+`)
```

No way to check validity of inputs.

```{r}
reduce("a", `+`)
```

x == 0

```{r}
reduce(integer(), `+`)
```

supply `.init` 

```{r}
reduce(integer(), `+`, .init = 0)
reduce("a", `+`, .init = 0)
```

0: identity of real numbers under the operation of addition. 0 + X == X


### 9.5.4: Multiple inputs

`reduce2()`: length of 2nd argument varies depending on `.init` supplied. If 4 elements of 'x', then 'f' will be called 3 times but if `init` then 4 times. 

### 9.5.5: Map-reduce

Hadoop

Each map on individual data >>> results sent back to coordinating power which reduces each result into single overall result.


## 9.6 Predicate functionals 

Predicate: Returns single TRUE / FALSE >>> `is.character()`, `is.null()`, `all()`, etc. Predicate MATCHES a vector if it returns TRUE.

### 9.6.1: Basics

Predicate functional: applies predicate to EACH element of a vector.

* `some(.x, .p)`: return TRUE if ANY element matches. Terminates at first TRUE.
* `every(.x, .p)`: returns TRUE if ALL element matches. Terminates at first FALSE.

* `detect(.x, .p)`: returns value of the first match. 
* `detect_index(.x, .p)`: returns location of the first match.

* `keep(.x, .p)`: keeps ALL matching elements
* `discard(.x, .p)`: drops ALL matching elements

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))

detect(df, is.factor)
detect_index(df, is.factor)

str(keep(df, is.factor))
str(discard(df, is.factor))
```

### 9.6.2: Map variants 

`*_if()` predicate functions

```{r}
df <- data.frame(
  num1 = c(0, 10, 20),
  num2 = c(5, 6, 7),
  chr1 = c("a", "b", "c"),
  stringsAsFactors = FALSE
)

str(map_if(df, is.numeric, mean))
str(modify_if(df, is.numeric, mean))
str(map(keep(df, is.numeric), mean))
```

### exercise

1. 

`is.na()` returns logical vector of the SAME LENGTH as argument 'x'.

`anyNA(recursive = TRUE)` is predicate version 

2. 

use `seq_along()` instead of `seq()`

3. 


4. 

```{r}
arg_max <- function(x, f){
  y <- map_dbl(x, f)
  x[y == max(y)]
}

arg_min <- function(x, f){
  y <- map_dbl(x, f)
  x[y == min(y)]
}

arg_max(x = -10:5, f = function(x) x ^ 2)
arg_min(x = -10:5, f = function(x) x ^ 2)
```

5. 

```{r}
modify_if(mtcars, is.numeric, scales01)
```



## 9.7 Base functionals

Base functionals with no equivalent in {purrr}.

### 9.7.1: Matrices and arrays

`base::apply()`: used with 2D and higher vectors >> matrices + arrays. Summarize matrix or array by collapsing each row/column to a single value.

Arguments: 
* 'X': matrix or array to summarize
* 'MARGIN': integer vector giving dimensiosn to summarize over. 1 = rows, 2 = cols, etc.  
* 'FUN': summary function
* '...': other arguments to 'FUN'


```{r}
a2d <- matrix(1:20, nrow = 5)
a2d
apply(a2d, 1, mean) # row
apply(a2d, 2, mean) # column
```

Specify multiple dimensions in 'MARGIN' 

```{r}
a3d <- array(1:24, c(2, 3, 4))
apply(a3d, 1, mean)
apply(a3d, c(1, 2), mean)
```

`apply()` caveats:
* no control over output type >>> automatically simplified to list/matrix/vector. 
* Not idempotent >>> if summary function is identity operator >> output NOT always same as input

```{r}
a1 <- apply(a2d, 1, identity)
identical(a2d, a1)

a2 <- apply(a2d, 2, identity)
identical(a2d, a2)
```

NEVER use `apply()` with a data frame >>> coerce to matrix == undesireable results if any NOT numeric vector. 


### 9.7.2: Mathematical concerns

`integrate()`: finds area under curve defined by `f()`
`uniroot()`: finds where `f()` hits zero
`optimise()`: finds location of lowest/highest value of `f()`

### exercise 

1. 

`apply()` applies function over the margins of an array >>> 2D: margins are rows & cols.

```{r}
arr2 <- array(1:12, dim = c(3, 4))
rownames(arr2) <- paste0("row", 1:3)
colnames(arr2) <- paste0("col", 1:4)
arr2
```

Transposed over rows

```{r}
apply(arr2, 1, function(x) x[1:2])
apply(arr2, 2, function(x) x[1:2])
```

The output of apply() is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.


2. 


eapply() is a variant of lapply(), which iterates over the (named) elements of an environment. In purrr there is no equivalent for eapply() as purrr mainly provides functions that operate on vectors and functions, but not on environments.

rapply() applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default classes = ANY). One may also specify how elements of other classes should remain: i.e. as their identity (how = replace) or another value (deflt = NULL). The closest equivalent in purrr is modify_depth(), which allows you to modify elements at a specified depth in a nested list.





# 10 Function factories

Function factory: function that makes functions.

```{r}
power1 <- function(exp) {
  function(x) {
    x ^ exp
  }
}

square <- power1(2)
cube <- power1(3)

## manufactured functions
square(3)
cube(3)
```


## 10.2 Factory fundamentals

THe enclosing environment of the manufactured function is an execution environment of the function factory.


### 10.2.1: Environments


```{r}
square

cube
```

'x' is from argument. 'exp'? 

Each of `square()` and `cube()` have two different environments for 'exp' with the same parent, the enclosing environment of `power1()` - the global environment.

```{r}
env_print(square)
env_print(cube)

fn_env(square)$exp
fn_env(cube)$exp
```

Names in enclosing environment are BOUND to different values (square == 2, cube == 3). 
For `square(10)`: For executing `x & exp` it finds 'x' in execution environment and 'exp' in the enclosing environment (so it finds 2 instead of any other value bound by other functions created by the factory).

### 10.2.3: Forcing evaluation

Bug in `power1()` due to lazy evaluation. 

```{r}
x <- 2 
square <- power1(x)
x <- 3

square(2) # == 8! when it should be 4!
```


'x' is only evaluated lazily when `square()` is run, NOT when `power1()` is run.

Happen when binding changes in between calling factory function and calling the manufactured function. Fix by "forcing" evaluation with `force()`:

```{r}
power2 <- function(exp) {
  force(exp)
  function(x) {
    x ^ exp
  }
}

x <- 2 
square <- power2(x)
x <- 3

square(2)
```

When creating function factory, make sure EVERY argument is evaluated using `force()` if necessary if argument ONLY used by manufactured function.


### 10.2.4: Stateful functions 

Maintain state across function invocations, generally unable due to fresh start principle. 

- Enclosing environment of manufactured function is UNIQUE and CONSTANT.
- R has special assignment operator `<<-` which modifies bindings in the enclosing environment. 

`<-`: always creates binding in the current environment

`<<-`: rebinds an existing name found in the parent environment 


```{r}
new_counter <- function() {
  i <- 0
  
  function() {
    i <<- i + 1
    i
  }
}

counter_one <- new_counter()
counter_two <- new_counter()

counter_one()
counter_one()

counter_two()
```

When manufactured function is run `i <<- i + 1` will modify 'i' in its enclosing environment. As manufactured functions have independent enclosing environments >>> they have independent counts. If function is managing state of multiple variables, use R6 instead...


### 10.2.5: Garbage collection

Manufactured functions hold on to the execution environment >>> so necessary to explicitly unbind any large temporary objects with `rm()`.

```{r}
f1 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  function() m
}

g1 <- f1(1e6)
lobstr::obj_size(g1)

f2 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  rm(x)
  function() m
}

g2 <- f2(1e6)
lobstr::obj_size(g2)
```

### exercise 

1. `force()`

using this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed x.


2. 


3. 

```{r}
pick <- function(i) {
  force(i)
  
  function(x) x[[i]]
}

x <- 1:3
identical(x[[1]], pick(1)(x))

identical(lapply(mtcars, function(x) x[[5]]),
          lapply(mtcars, pick(5)))
```


4. 

```{r}
moment <- function(i){
  force(i)
  
  function(x) sum((x - mean(x)) ^ i) / length(x)
}

m1 <- moment(1)
m2 <- moment(2)

x <- runif(100)
all.equal(m1(x), 0)  # removed stopifnot() for clarity
#> [1] TRUE
all.equal(m2(x), var(x) * 99 / 100)
#> [1] TRUE
```



5. no closure?

```{r}
i <- 0
new_counter2 <- function() {
  i <<- i + 1
  i
}

new_counter2()

i

new_counter2()

i

i <- 0
new_counter2()
```

Counts will be stored in global environments which can then be overwritten or deleted to interfere with other counters being executed. 

6. use <- instead of <<-

Always return same value due to fresh start principle (always start new execution environment within same enclosing environment - containing unchanged value for '_')


## 10.3 Graphical factories

### 10.3.1: Labelling 

{scales}: customize labels in {ggplot2}. Formatter functions all return a function. Primary interface is a function factory. 

```{r}
y <- c(12345, 123466, 123584)
comma_format()(y)

number_format(scale = 1e-3, suffix = "k")(y)
```

```{r}
df <- data.frame(x = 1, y = y)
core <- ggplot(df, aes(x, y)) +
  geom_point() + 
  scale_x_continuous(breaks = 1, labels = NULL) +
  labs(x = NULL, y = NULL)

core 
core + scale_y_continuous(labels = comma_format())
core + scale_y_continuous(labels = number_format(scale = 1e-3, suffix = "k"))
core + scale_y_continuous(labels = scientific_format())
```


### 10.3.2: Histogram bins

'binwidth' argument can be a function. Function is executed once for EACh group, so can have different bindwidths in different facets. 

```{r}
sd <- c(1, 5, 15)
n <- 100

df <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = 2) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```

Each facet has same 'n' but different variance. Create with function factory that take input of desired # of bins, and outputs function that takes numeric vector to return binwidth. 


```{r}
binwidth_bins <- function(n) {
  force(n)
  
  function(x) {
    (max(x) - min(x)) / n
  }
}

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = binwidth_bins(20)) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```


```{r}
base_bins <- function(type) {
  fun <- switch(type,
    Sturges = nclass.Sturges,
    scott = nclass.scott,
    FD = nclass.FD,
    stop("Unknown type", call. = FALSE)
  )
  
  function(x) {
    (max(x) - min(x)) / fun(x)
  }
}

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = base_bins("FD")) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```


### 10.3.3: `ggsave()`

`ggplot2:::plot_dev()` used by `ggsave()` to go from file extension to graphics device function. Base graphics devices have minor inconsistencies.

- `filename` vs. `file`
- `width` and `height` pixels in raster graphics but inches in vector graphics



## 10.4 Statistical factories 



## 10.5 Function factories and functionals


Create specially named power functions by iterating over a list of arguments.

```{r}
names <- list(
  square = 2, 
  cube = 3, 
  root = 1/2, 
  cuberoot = 1/3, 
  reciprocal = -1
)
funs <- purrr::map(names, power1)

funs$root(64)
#> [1] 8
funs$root
```

Annoying to have to prefix every function call with `fun$`

```{r}
with(funs, root(100))
```

`with(mtcars, mpg[cyl == 8  &  disp > 350])`
    # is the same as, but nicer than
`mtcars$mpg[mtcars$cyl == 8  &  mtcars$disp > 350]`

OR `attach()` functions to the search path and `detach()` when done

```{r}
attach(funs)
root(100)
detach(funs)
```

OR copy functions to global environment with `env_bind()`

```{r}
rlang::env_bind(global_env(), !!!funs)
root(100)
rlang::env_unbind(global_env(), names(funs))
```


### exercise

1.

```{r}
f <- mean
z <- 1
x <- list(f = mean, z = 1)

identical(with(x, f(z)), x$f(x$z))
#> [1] TRUE
identical(with(x, f(z)), f(x$z))
#> [1] TRUE
identical(with(x, f(z)), x$f(z))
#> [1] TRUE
identical(with(x, f(z)), f(z))
```


2. `env_bind()` vs. `attach()`

`attach()` adds 'funs' to the search path. Therefore, the provided functions are found before their respective versions from the base package. Further, they can not get accidentally overwritten by similar named functions in the global environment. One annoying downside of using `attach()` is the possibility to attach the same object multiple times, making it necessary to call `detach()` equally often.

In contrast `rlang::env_bind()` just adds the functions in 'fun' to the global environment. No further side effects are introduced and the functions are overwritten when similarly named functions are defined.



# 11 Function operators

Function operator: function that takes functions as input and returns function as output.

```{r}
chatty <- function(f) {
  force(f)
  
  function(x, ...) {
    res <- f(x, ...)
    cat("Processing ", x, "\n", sep = "")
    res
  }
}
f <- function(x) x ^ 2
s <- c(3, 2, 1)

purrr::map_dbl(s, chatty(f))
```

## 11.2 Existing function operators

### 11.2.1: Capturing errors with `purrr::safely()`

`for` loop: If one iteration fails, can still acceess results up to the failure. 

```{r}
x <- list(
  c(0.512, 0.165, 0.717),
  c(0.064, 0.781, 0.427),
  c(0.890, 0.785, 0.495),
  "oops"
)

out <- rep(NA_real_, length(x))
for (i in seq_along(x)) {
  out[[i]] <- sum(x[[i]])
}

out
```

Functionals: no output so difficulty assessing where problem is.

```{r}
map_dbl(x, sum)
```

Use `purrr::safely()` to transforms function to turn errors into data. 

```{r}
safe_sum <- safely(sum)
safe_sum

str(safe_sum(x[[1]]))
str(safe_sum(x[[4]]))
```

Returns: 'result' and 'error'. NULL if none.

```{r}
out <- map(x, safely(sum))
str(out)
```

Now have four list each with 'result' and 'error'. Unwieldy so use `purrr::transpose()` to get a list of 'result' and list of 'error'.

```{r}
out <- transpose(map(x, safely(sum)))
str(out)
```

Find results that worked and which failed.

```{r}
ok <- map_lgl(out$error, is.null)
ok

x[!ok]
out$result[ok]
```

```{r}
fit_model <- function(df) {
  glm(y ~ x1 + x2 * x3, data = df)
}

models <- transpose(map(datasets, safely(fit_model)))
ok <- map_lgl(models$error, is.null)

# which data failed to converge?
datasets[!ok]

# which models were successful?
models[ok]
```


- `possibly()`: return default value when error. 
- `quietly()`: turns output, messages, warning side-effects into 'output', 'message', 'warning' components of output
- `auto_browser()`: automatically executes `browser()` inside function if error.

### 11.2.2: Caching computations with `memoise::memoise()`

Function to memorize previous inputs and return cached results. Memoised function can run faster but uses more memory as store previous inputs + outputs.

```{r}
slow_function <- function(x) {
  Sys.sleep(1)
  x * 10 * runif(1)
}
system.time(print(slow_function(1)))

system.time(print(slow_function(1)))
```

Slow for new arguments but for previously seen arguments == very fast as retrieves previous value from that computation.

```{r}
fast_function <- memoise::memoise(slow_function)
system.time(print(fast_function(1)))

system.time(print(fast_function(1)))
```

Fibonacci series: recursive

```{r}
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
system.time(fib(24))
```

Memoise: each value is only computed once == faster

```{r}
fib2 <- memoise::memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
system.time(fib2(24))
```

Dynamic programming: Complex problem can be broken down into many overlapping sub-problems, remembering results of sub-problem can improve performance.

IF function NOT pure (output not only depend on input) then will get misleading results. 

### exercise 

1. 

In R a lot of functions are “vectorised”. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors, and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.

However, despite what the function’s name implies, Vectorize() is not able to speed up the provided function. It rather changes the input format of the supplied arguments (vectorize.args), so that they can be iterated over.

In essence, Vectorize() is mostly a wrapper for mapply(). Vectorize() provides a convenient and concise notation to iterate over multiple arguments, but has some major drawbacks that mean you generally shouldn’t use it.

2.

possibly() modifies functions to return a specified default value in case of an error (otherwise) and to suppress any error messages (quiet = TRUE).

While reading the source code, we notice that possibly() internally uses purrr::as_mapper(). This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the purrr package. Besides this, the new default value (otherwise) gets evaluated once to make it (almost) immutable.

The main functionality of possibly() is provided by base::tryCatch(). In this part the supplied function (.f) gets wrapped and the error and interrupt handling are specified.




3. 

safely() modifies functions to return a list, containing the elements “result” and “error”. It works in a similar fashion as possibly() and besides using as_mapper(), safely() also provides the otherwise and quiet argument. However, in order to provide the result and the error in a consistent way, the tryCatch() part of the implementation returns a list with the same structure in both cases. In the case of successful evaluation “error” equals to NULL and in case of an error “result” equals to otherwise, which is NULL by default.


## 11.3 Case study: Creating your own function operators

Imagine you have a named vector of URLs and you’d like to download each one to disk.

```{r}
urls <- c(
  "adv-r" = "https://adv-r.hadley.nz", 
  "r4ds" = "http://r4ds.had.co.nz/"
  # and many many more
)
path <- paste(tempdir(), names(urls), ".html")

walk2(urls, path, download.file, quiet = TRUE)
```

* Add a small delay between each request to avoid hammering the server.
* Display a . every few URLs so that we know that the function is still working.

In `for` loop:

```{r}
for(i in seq_along(urls)) {
  Sys.sleep(0.1)
  if (i %% 10 == 0) cat(".")
  download.file(urls[[i]], paths[[i]])
}
```

ALl in one >>> extract out each process to make them reusable.

```{r}
delay_by <- function(f, amount) {
  force(f)
  force(amount)
  
  function(...) {
    Sys.sleep(amount)
    f(...)
  }
}
system.time(runif(100))
system.time(delay_by(runif, 0.1)(100))

walk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)
```


Can not rely on index from loop. Can't pass index as argument as breaks encapsulation (concern of progress function is handled by a higher level wrapper). Progress wrapper manage own internal counter. 

```{r}
dot_every <- function(f, n) {
  force(f)
  force(n)
  
  i <- 0
  function(...) {
    i <<- i + 1
    if (i %% n == 0) cat(".")
    f(...)
  }
}
walk(1:100, runif)
walk(1:100, dot_every(runif, 10))
```

Combine:

```{r}
walk2(
  urls, path, 
  dot_every(delay_by(download.file, 0.1), 10), 
  quiet = TRUE
)

## use pipe for legibility:
walk2(
  urls, path, 
  download.file %>% dot_every(10) %>% delay_by(0.1), 
  quiet = TRUE
)
```

### exercise

1. 

Both commands will print a dot every 10 downloads and will take the same amout of time to run, so the differences may seem quite subtle.

In the first case, first the dot functionality is added to download.file. Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed and the first dot will be printed as soon as the download for the 10th url starts.

In the latter case. The delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, the the short delay occurs before the 10th download actually starts.

2.

No. Size of files might be very large to keep in memory.

This implies that it’s probably not beneficial to memoise file.download() in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.

3. 

```{r}
dir_compare <- function(old, new) {
  if (setequal(old, new)) {
    return()
  }
  
  added <- setdiff(new, old)
  removed <- setdiff(old, new)
  
  changes <- c(
    if (length(added) > 0) paste0(" * '", added, "' was added"),
    if (length(removed) > 0) paste0(" * '", removed ,
                                    "' was removed")
  )
  message(paste(changes, collapse = "\n"))
}

dir_compare(c("x", "y"), c("x", "y"))
#> NULL
dir_compare(c("x", "y"), c("x", "a"))
```

Wrap in function operator: 

```{r}
track_dir <- function(f) {
  force(f)
  function(...) {
    dir_old <- dir()
    on.exit(dir_compare(dir_old, dir()), add = TRUE)
    
    f(...)
  }
}

file_create <- track_dir(file.create)
file_remove <- track_dir(file.remove)

file_create("delete_me")
file_remove("delete_me")
```


To create a more serious version of track_dir() one might provide optionality to set the full.names and recursive arguments of dir() to TRUE. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.

Other global effects that might be worth tracking include changes regarding:

- the search path and possibly introduced conflicts()
- options() and par() which modify global settings
- the path of the working directory
- environment variables


4.

```{r}
append_line <- function(path, ...) { 
  cat(..., "\n", sep = "", file = path, append = TRUE)
}

logger <- function(f, log_path) {
  force(f)
  force(log_path)
  
  append_line(log_path, "created at: ", as.character(Sys.time()))
  function(...) {
    append_line(log_path, "called at: ", as.character(Sys.time()))
    f(...)
  }
}

log_path <- tempfile()
mean2 <- logger(mean, log_path)
Sys.sleep(5)
mean2(1:4) 
#> [1] 2.5
Sys.sleep(1)
mean2(1:4)
#> [1] 2.5

readLines(log_path)
```


5. 

```{r}
delay_atleast <- function(amount, f) {
  force(f)
  force(amount)
  
  # Store the last time the function was run
  last_time <- NULL
  
  # Return modified 'delay-aware' function
  function(...) {
    if (!is.null(last_time)) {
      wait <- (last_time - Sys.time()) + amount
      if (wait > 0) {
        Sys.sleep(wait)
      }
    }
    
    # Update the time after the function has finished
    on.exit(last_time <<- Sys.time()) 
    
    f(...)
  }
}
```





# III. Object-Oriented Programming

## OOP: 
- polymorphism: developer can consider a function's interface as separate from implementation. So use same function form for different types of input. Similar to encapsulation - usser doesn't need to worry about details of object as they are encapsulated behind a standard interface.

```{r}
## `summary()` output for numeric and factor variables 
summary(diamonds$carat)
summary(diamonds$cut)
```

## OOP Systems

Class: type of object "what is", organized in hierarchy so if method not exist for one class, parent method is used, child "inherits" behavior. 
-- Ex. ordered factor inherits from regular factor. GLM inherits from linear model
Method: implementation for a specific class "what do"
- Method dispatch: finding correct method given a class
Fields: defined by class, the data possessed by every instance of that class

### OOP paradigms

- Encapsulated: methods belong to objects/classes, object encapsulates both data (fields) and behavior (methods)
-- Method call ex.: `object.method(arg1, arg2)`

- Functional: methods belong to generic functions, looks similar to regular function call, internal components are also functions
-- Method call ex.: `generic(object, arg2, arg3)`

## OOP in R

- S3
-- informal implementation of functional OOP, rely on common conventions > ironclad guarantees

- S4
-- formal rewrite of S3. More guarantees + greater encapsulation. S4 implemented in base {methods} package.

- RC
-- Encapsulated OOP. Special type of S4 objects that are mutable - can be modified in place. 

- R6
-- Encapsulated OOP. Resolves issues in RC

- R.oo
-- Formalism on S3, mutable S3 objects.

- proto
-- Prototype based OOP. Used in {ggplot2}

```{r}
library(sloop)

otype(1:10)
otype(mtcars)

mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)
otype(mle_obj)
```



# 12 Base types

Object: Not ALL objects are object-oriented. 
-- Base objects vs. OO objects

## 12.2 Base vs. OO objects

Use `is.object()` or `sloop::otype()`

```{r}
is.object(1:10)
sloop::otype(1:10)

is.object(mtcars)
sloop::otype(mtcars )
```

OO objects have a "class" attribute:
```{r}
attr(1:10, "class")
attr(mtcars, "class")
```

Use `class()` for S3 and S4 objects but can be misleading if used on base objects. Use `sloop::s3_class()` instead.

```{r}
x <- matrix(1:4, nrow = 2)
class(x)
sloop::s3_class(x)
```

## 12.3 Base types

ALL objects have a 'base type':
```{r}
typeof(1:10)
typeof(mtcars)
```

Base types do not form OOP system as functions that behave differently for different base types are using C code >>> uses 'switch' statements. Only R-Core can create new types >>> difficulty due to all work needed to add switch statements to code. 

```{r}
typeof(NULL)

typeof(1L)

typeof(1i)

typeof(mean)

typeof(`[`)

typeof(sum) 

typeof(globalenv())

mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)
typeof(mle_obj)

typeof(quote(a))

typeof(quote(a + 1))

typeof(formals(mean))
```

### 12.3.1: Numeric type

"Numeric" can mean:

1. Alias for "double" type. `as.numeric()` == `as.double()` // `numeric()` == `double()`

2. S3 + S4: numeric is shorthand for 'integer' or 'double' type for picking methods.

```{r}
sloop::s3_class(1)
sloop::s3_class(1L)
```

3. `is.numeric()` tests for objects that BEHAVE like numbers. Factors have type 'integer' but do NOT behavior as numbers.

```{r}
typeof(factor("x"))
is.numeric(factor("x"))
```

# 13 S3

Simplest OO system. Only OO system used by {base} and {stats} + most commonly used on CRAN packages.

Very flexible, few constraints >>> necessity to apply constraints yourself.

## 13.2: Basics

S3 object: base type with at least a 'class' attribute. 

Factor: base type == 'integer' vector, 'class' attribute of "factor", 'levels' attribute stores all possible levels.

```{r}
f <- factor(c("a", "b", "c"))
typeof(f)
attributes(f)

## strip 'class' attribute, lose special behavior
unclass(f)
```

S3 object behave differently from underlying base type if passed to a 'generic' function.

`sloop::ftype()`: to find 'generic' functions

```{r}
ftype(print)
ftype(str)
ftype(unclass)
```

'Generic' function: defines an interface - uses different implementation depending on the 'class' or argument. 

```{r}
print(f) # print as factor

print(unclass(f)) # strip 'f' of factor class >> behave as integer
```

`str()` is 'generic': Some S3 classes use it to hide internal details. Ex. 'POSIXlt' class. 


'generic': Defines the interface and find right implementation for it. 
'method': Implementation for a specific class.
'method dispatch': How 'generic' finds method

```{r}
s3_dispatch(print(f))
```

No need to call method directly >> let the 'generic' do it for you. 

Check if method by `sloop::ftype()`.

Can NOT see source codes for most S3 methods as they are not usually exported - only live inside package and not available in global env. 

Check using `sloop::s3_get_method()`:

```{r}
weighted.mean.Date

s3_get_method(weighted.mean.Date)
```

### exercise 

1. `t.test()` vs. `t.data.frame()`

```{r}
ftype(t.test)
ftype(t.data.frame)
```

`t.test()`: generic function
`t.data.frame()`: method that gets called by `t()` to transpose data.frame input.

2. 

```{r}
install.packages()
read.csv()

list.files()
download.file()

data.frame()
as.character()
Sys.Date()

all.equal()

do.call()
on.exit()
```


3. 

`as.data.frame.data.frame()` calls method dispatch for the `as.data.frame()` function for the input data.frame. 

Define names better!!

4. when unclass the mean is taken of the 'some_days' which when losing it's "Date" class now behaves as an double.

5. 

```{r}
x <- ecdf(rpois(100, 10))
ftype(x)
typeof(x)
s3_class(x)
attributes(x)
```

6. 

```{r}
x <- table(rpois(100, 5))
typeof(x)
attributes(x)
```

## 13.3: Classes

S3: Has no formal definition of class. Only need to set the 'class' attribute.

Creation with `structure()` or post-creation with `class<-()`

```{r}
x <- structure(list(), class = "my_class")

x <- list()
class(x) <- "my_class"

class(x)
inherits(x, "my_class")
inherits(x, "your_class")
```

'class' name can be ANY string. Recommend only LETTERS and `_`. Avoid `.` as can be confused with generic/class separator. For packages, use package name in class name to avoid clashes with classes in other packages. 

Can change class of existing objects:

```{r}
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)

class(mod) <- "Date"
print(mod)
```

Provide 3 basic functions:

- Constructor: low level `new_myclass()` that efficiently creates new objects with the correct structure.
- Validator: `validate_myclass()` which performs more rigourous checks to ensure object has the correct values.
- Helper: `myclass()` to provide other users to create objects of your class

### 13.3.1: Constructors

No formal definition of lcass == no built-in way to ensure all objects of a given class have same structure. Enforce consistent structure with a "constructor".

- Name: `new_myclass()`
- 1 argument for base object, one for each attribute
- Check type of base object and check typoes of each attribute

`Date`: doulbe with single attribute >>> 'class' == "Date

```{r}
new_Date <- function(x = doubl()) {
  stopifnot(is.double(x))
  structure(x, class = "Date")
}

new_Date(c(-1, 0, 1))
```

`difftime`: double but has 'units' attribute

```{r}
new_difftime <- function(x = double(), units = "secs") {
  stopifnot(is.double(x))
  units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))

  structure(x,
    class = "difftime",
    units = units
  )
}

new_difftime(c(1, 10, 3600), "secs")
new_difftime(52, "weeks")
```

Avoid checks in constructor.

### 13.3.2: Validators

More complicated classes require more complciated checks for validity. 

Factors: 

```{r}
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

new_factor(1:5, "a")
new_factor(0:1, "a")
```

Separate validation checks from constructor. 

```{r}
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
```



### 13.3.3: Helpers

Allow users to construct objects from your class.

- Have same name as class
- Finish by calling constructur and validator
- Create carefully crafted error messages for user
- UI and default values + useful conversions

Helper to coerce input to desired type.


```{r}
new_difftime(1:10) ## error as NOT double

difftime <- function(x = double(), units = "secs") {
  x <- as.double(x)
  new_difftime(x, units = units)
}

difftime(1:10)
```


Natural representation of complex object >>> string.

Convenient to specify factors with character vector. Have `factor()` guess from input character vector that the 'levels' are the unique values. Not always correct but good enough default to start. 

```{r}
factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

factor(c("a", "a", "b"))
```


Some complex objects more naturally specified by multiple simple components >>> date-time via supplying individual components. 

```{r}
POSIXct <- function(year = integer(), 
                    month = integer(), 
                    day = integer(), 
                    hour = 0L, 
                    minute = 0L, 
                    sec = 0, 
                    tzone = "") {
  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)
}

POSIXct(2020, 1, 1, tzone = "America/New_York")
```

### exercise 

1. 

Data frames are built on named lists of vectors, where every element is the same length. Their only attribute is “row.names” which must be a character vector the same length as the other elements. We need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.

```{r}
new_data.frame <- function(x, n, row.names = NULL) {
  stopifnot(is.list(x))
  
  # Check all inputs are the same length
  stopifnot(all(lengths(x) == n))
  
  if (is.null(row.names)) {
    # Use special row names helper
    row.names <- .set_row_names(n)
  } else {
    # Otherwise check that they're a character vector with the 
    # correct length
    stopifnot(is.character(row.names), length(row.names) == n)
  }
  
  structure(
    x,
    class = "data.frame",
    row.names = row.names
  )
}

# Test
x <- list(a = 1, b = 2)
new_data.frame(x, n = 1)
#>   a b
#> 1 1 2
new_data.frame(x, n = 1, row.names = "l1")
#>    a b
#> l1 1 2

# Create a data frame with 0 columns and 2 rows    
new_data.frame(list(), n = 2)
```



2.

```{r}
factor2 <- function(x, levels = unique(x)) {
  new_levels <- match(x, levels)
  
  # Error if levels don't include all values
  missing <- unique(setdiff(x, levels))
  if (length(missing) > 0) {
    stop(
      "The following values do not occur in the levels of x: ",
      paste0("'", missing, "'", collapse = ", "), ".", 
      call. = FALSE
    )
  }
  
  validate_factor(new_factor(new_levels, levels))
}

factor2(c("a", "b", "c"), levels = c("a", "b"))
```


3. 

The original implementation allows a more flexible specification of input for x. The input is coerced to character or replaced by character(0) (in case of NULL). It also ensures that the factor levels are unique. This is achieved by setting the levels via base::levels<-, which fails when duplicate values are supplied.

```{r}
factor()
```

4. 


```{r}
new_factor <- function(
  x = integer(),
  levels = character(),
  contrast = NULL
) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  if (!is.null(constrast)) {
    # if supplied should be a numeric matrix
    stopifnot(is.matrix(contrast) && is.numeric(contrast))
  }
  
  structure(
    x,
    levels = levels,
    class = "factor",
    contrast = contrast
  )
}
```

5. 

```{r}
as.roman(567)
```




## 13.4 Generics & Methods


# 14 R6



# 15 S4


# 16 Trade-offs





