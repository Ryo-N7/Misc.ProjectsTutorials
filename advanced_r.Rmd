---
title: "Untitled"
author: "RN7"
date: "9/7/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r}
pacman::p_load(lobstr, rlang, dplyr, magrittr, 
               purrr, ggplot2, scales, sloop,
               R6, methods)
```


# 2. Names & Values

```{r}
set.seed(1014)
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)

str(df)

df$`3` <- df$`1`+ df$`2`

str(df)
```

```{r}
x <- runif(1e6)
y <- list(x, x, x)

# object.size(y) WRONG
lobstr::obj_size(y)
```




```{r}
a <- c(1, 5, 3, 2)
a

b <- a
b
a

b[[1]] <- 10

b

## a is copied when b is modified at line 3
```







```{r}
lobstr::obj_addr(mean)
lobstr::obj_addr(base::mean)
lobstr::obj_addr(get("mean"))
lobstr::obj_addr(evalq(mean))
lobstr::obj_addr(match.fun("mean"))
```


```{r}
read.csv(check.names = FALSE)
```




```{r}
x <- c(1L, 2L, 3L)
x
tracemem(x)

x[[3]] <- 4
untracemem(x)
```





# 3. Vectors

## 3.2: Atomic Vectors

4 common types of vectors: double, character, logical, integer
2 rare types of vectors: complex, raw

Attributes: associate arbitrary additional metadata to object

```{r}
attr()
attributes()
```

List vs. atomic vector: elements of LIST can be ANY type, elements of atomic vector must be the same

Matrix vs. data frame:  element of matrix must be same, element of data frame can be ANY type

List as matrix? Assign dimension to list
Data frame have column == matrix? Assign matrix to column of df with `<- matrix()` or `I()`

Difference between tibbles vs. data frame: tibbles have enhanced print method, NEVER coerces string to factors, provide stricter subsetting methods

### 3.2.1: Scalars

Scalar: individual value for the primary types of vectors
- Logical: TRUE / FALSE, T / F
- Doubles: decimal, scientific, hexadecimal forms. Special values (Inf, -Inf, NaN)
- Integers: no fractional values, use of `L` at end
- Strings: `"blah"`, special characters escaped with `\`



### 3.2.2: Longer vectors with `c()`

`c()`: combine

```{r}
lgl_var <- c(TRUE, FALSE)
lgl_var

int_var <- c(1L, 6L, 104L)
int_var

dbl_var <- c(1, 2.5, 6.45)
dbl_var

chr_var <- c("these are", "some strings")
chr_var
```
If inputs == atomic vectors >> `c()` creates another atomic vector >> flattens

```{r}
c(c(1, 2), c(3, 4))
```
`type_of()`: determine type of vector 



### 3.2.3: Missing Values

Missing/unknown: `NA`, most computations with missing value return missing value!

```{r}
NA > 5
10 * NA
!NA
```

Exceptions: when identity holds for all possible inputs

```{r}
NA ^ 0
NA | TRUE
NA & FALSE
```
Common mistake: 

```{r}
x <- c(NA, 5, NA, 10)
x == NA

## use is.na() instead for testing presence of missingness!
is.na(x)
```
NA types: `NA`, `NA_integer_`, `NA_real_`, `NA_character_`
- `NA` usually coerced to correct type

### 3.2.4: Testing and coercion

`is.*()`: test for type of vector. 
- AVOID: `is.vector()` + `is.atomic()` + `is.numeric()`
- When attempt to combine different vector types >>> coercion
- Coercion order: character >>> double >>> integer >>> logical
Ex. combine character + integet == character

```{r}
str(c("A", 1))
```
- Most mathematical functions coerc to numeric (`+`, `log()`, `abs()`, etc.)
- `TRUE` == `1` & `FALSE` == `0` 

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

## total number of TRUE
sum(x)

## proportion that are TRUE
mean(x)
```

`as.*()`: directly coerce vector type: `as.logical()`, `as.integer()`, `as.double()`, `as.character()`.

Ex. failed coercion:

```{r}
as.integer(c("1", "1.5", "a"))
```

### exercise

1. 
scalars == represented as vectors of length == 1
scalars of type raw:

```{r}
raw(1)
as.raw(42)
```

scalars of type complex:

```{r}
complex(1)
complex(length.out = 1, real = 1, imaginary = 1)
```

2. Vector coercion rules:

```{r}
c(1, FALSE)  ## double
c("a", 1)    ## character
c(TRUE, 1L)  ## integer
```

3. 

```{r}
1 == "1"    ## coerces to character
## TRUE because `1` is coerced to "1"

-1 < FALSE  ## coerces to double
## TRUE because `FALSE` coerces to double >> `0`

"one" < 2   ## coerces to character
## FALSE because `2` coerces to character "2"
## numerals precede letters but depends on locale
```
4. 

DEFAULT missing NA == logical vector: due to hierarchy of type coercion, when combining `NA` with other atomic vector types then will be coerced in order integer, numeric, character. IF `NA` was character than all other values in set would be coerced to characters as well which would be problematic.

5. 

`is.atomic()`: test if atomic vector or NULL
`is.numeric()`: test if object has type "integer"/"double" and NOT "factor", "Date", "POSIXt", "difftime"
`is.vector()`: test if object is vector and NO attributes besides names

## 3.3 Attributes

Atomic vectors != `matrices`, `arrays`, `factors`, `date-times`
- Built on top of atomic vectors by adding ATTRIBUTES

### 3.3.1: Getting & Setting

Attributes: name-value pairs >>> attach metadata on object
- `attr()`: retrieve/modify individual attributes
- `attributes()`: retrieve en masse
- `structure()`: set en masse

```{r}
a <- 1:3
attr(a, "asd49824-blahblah") <- "abcdef23blargh-attribute"
attr(a, "asd49824-blahblah")
```

```{r}
attr(a, "y") <- 4:6
str(attributes(a))
```

```{r}
a <- structure(
  1:3,
  x = "abcdef",
  y = 4:6
)

str(attributes(a))
```

Most attributes lost by operations:

```{r}
attributes(a[1])
attributes(sum(a))
```

Two attributes usually preserved:
- `names`: character vector giving each element a name
- `dim`: dimensions, integer vector used to turn vectors into matrices/arrays

To preserve others, need to create S3 class.

### 3.3.2: Names

```{r}
## Upon creation
x <- c(a = 1, b = 2, c = 3)
x

## Assigning character vector to `names()`
x <- 1:3
names(x) <- c("a", "b", "c")
x

## Inline via `setNames()`
x <- setNames(1:3, c("a", "b", "c"))
x
```

```{r}
unname(x)
names(x) <- NULL
```

Missing names either "" or `NA_character_`. If all names missing == `NULL`

### 3.3.3: Dimensions

`dim`: Add to vector for it to behave like 2D matrix or multi-D array. 

```{r}
## 2 scalar arguments specifying row + column size
a <- matrix(1:6, nrow = 2, ncol = 3)
a

## 1 vector argument to describe all dimensions
b <- array(1:6, c(2, 3, 1))
b

## modify object in palce with `dim()`
c <- 1:6
dim(c) <- c(2, 3)
c
```

- Vector with no `dim` attributes == NULL dimensions


### exercise

1. How are `setNames()` and `unname()` implemented?

- `setNames()`: uses `names()` and assigns input to the object
- `unname()`: removes existing names and sets to `NULL`

2. `dim()` to 1d vector? When use `NROW()` and `NCOL()`?

- `dim()`: returns NULL when applied to 1d vector

```{r}
x <- 1:10
nrow(x)
ncol(x)

## use for when handle atomic vectors, lists, NULLs similar to 1 column matrices/data frames
NROW(x)
NCOL(x)
```

3. 

```{r}
x1 <- array(1:5, c(1, 1, 5)) ## 1 row 1 col 5 z
x2 <- array(1:5, c(1, 5, 1)) ## 1 row 5 col 1 z
x3 <- array(1:5, c(5, 1, 1)) ## 5 rows 1 col 1 z
```

4. `structure()`

```{r}
foo <- structure(1:5, comment = "my attribute")

attributes(foo)

attr(foo, which = "comment")
```


## 3.4: S3 Atomic vectors

Class: vector attribute >>> S3 object system
S3 object: Object with a class attribute, behaves differently from regular ector when passed to a generic function. Every S3 object is built on top of a base type, stores additional info about other attributes.

### 3.4.1: Factors

Factor: Vector containing only pre-defined values for storing categorical data. Built on top of integer vector with 2 attributes
- Class "factor": behave differently from regular integer vectors
- levels: Defines the set of allowed values

```{r}
x <- factor(c("a", "b", "b", "a"))
x

typeof(x)
attributes(x)
```

Tabulating factors: Get counts of all categories, even if unobserved

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_factor)
```
Ordered: Order of levels is meaningful (ex. low, medium, high)

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
```

Careful when using string methods on factors, as they are built on integer vectors NOT character.

### 3.4.2: Dates

Date: Built on top of double vectors. 
- Class "Date", no other attributes

```{r}
today <- Sys.Date()

today

typeof(today)

attributes(today)

## value of double represents # of days since 1970-01-01
date <- as.Date("1970-02-01")
unclass(date)
```

### 3.4.3: Date-times


POSIXct: calendar time >> atomic vector, appropriate for data frames
POSIXlt: local time

```{r}
now_ct_DLT <- as.POSIXct("2018-07-22 09:00", tz = "America/New_York")
now_ct <- as.POSIXct("2018-11-22 09:00", tz = "America/New_York")

now_ct

typeof(now_ct)

attributes(now_ct)

structure(now_ct_DLT, tzone = "Asia/Tokyo")
structure(now_ct, tzone = "Asia/Tokyo")
```

### 3.4.4: Durations

Durations: Amount of time between pairs of dates or date-times. >>> `difftimes`
- Built on top of doubles, `units` attribute for how integer is interpreted

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

### exercise 

1. `table()` object? Type? Attributes? Dimension changes as add more variables?

Class: `table`
array of integers with attributes `dim` and `dimnames`
Dimensions correspond to # of unique values in each variable

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

tabobj <- table(sex_char)

typeof(tabobj)
attributes(tabobj)


```

2. What happens to factor when modify its levels?

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

levels(f1)
as.integer(f1)
```
Underlying integer values remain same but levels change!





### exercise 

`table()` returns type integer, class "table", with "dim" and "dimnames" attributes, represented internally as array of integers

```{r}
typeof(table(cars))
```


2. What happens to factor when you modify levels?

```{r}
f1 <- factor(letters)
levels(f1)
as.integer(f1)

levels(f1) <- rev(levels(f1))
levels(f1)
as.integer(f1)
```

underlying integer values stay the same but levels == changed!

3. How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))

f3 <- factor(letters, levels = rev(letters))

f1
f2
f3
```
f1: BOTH order of factor elements AND order of levels reversed!
f2: order of factor elements reversed
f3: order of levels reversed


## 3.5: Lists

- Each element can be ANY type, not just ectors. 

### 3.5.1: Creating

```{r}
l1 <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9)
)

typeof(l1)
str(l1)
```

Elements of list are references >>> Creating a list does NOT involve copying components INTO the list!

```{r}
lobstr::obj_size(mtcars)
l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
```


Lists: recursive vectors as list can contain other lists

```{r}
l3 <- list(list(list(1)))
str(l3)
```

`c()` combines several lists into 1. If combo of atomic vectors and lists, coerce vectors to lists before combining.

```{r}
l4 <- list(list(1, 2), c(3, 4))
l5 <- c(list(1, 2), c(3, 4))

str(l4)
str(l5)
```


### 3.5.2: Testing & coercion

`is.list()`, `as.list()`, `unlist()` for list >> atomic vector

```{r}
list(1:3)
as.list(1:3)
```

### 3.5.3: Matrices & arrays

- For atomic vectors, dimension attribute used for creating matrices
-- Lists: dimension attribute to create list-matrices and list-arrays

```{r}
l <- list(1:3, "a", TRUE, 1.0)
l

dim(l) <- c(2, 2)
l

l[1]
l[[1, 1]]
```

### exercise

1. List all ways list different from atomic vector

List: Can be heterogenous (elements of different types allowed), contain separate references for each element, subsetting out-of-bound values or NAs == `NULL`

Atomic vector: Always homogenous (all elements == same type), point to one address in memory, subsetting out-of-bound values or NAs == `NA`

```{r}
lobstr::ref(1:2)

lobstr::ref(list(1:2, 2))
```



2. Why use `unlist()` to convert list to atomic vector? Why `as.vector()` NOT work?

- List is already a vector (but not an atomic vector)
- `as.vector()` != `is.vector()`


3. Compare/contrast `c()` and `unlist()` when combining date and date-time into a single vector.

Date + date-time built on doubles. Dates == days, date-time (POSIXct) == seconds.

Generic function dispatches based on class of its first argument.

`c()` coerces types >> errors occur due to inappropriate method dispatch (avoid by explicit conversion of classes)
`unlist()` strips attributes

## 3.6 Data Frames and Tibbles

Data frame: Named list of vectors with attributes for column names, `row.names`, class: "data.frame"

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])

typeof(df1)

attributes(df1)
```

Dataframe additional constraint vs. regular list: Length of each vector must be the same >>> rectangular structure, reason why share properties of matrices + lists
- df: `rownames()` + `colnames()`. `names()` of df == column names
- df: `nrow()` + `ncol()`. `length()` of df == # of columns

Tibbles: modern re-imagining of data frames.

```{r}
library(tibble)

df2 <- tibble(x = 1:3, y = letters[1:3])
typeof(df2)
attributes(df2)
```

### 3.6.1: Creating

Supply name-vector pairs to `data.frame(0`)
- default conversion of strings to factors >> `stringsAsFactors = FALSE`

```{r}
df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c")
)

str(df)
```

Tibble: never coerces input

Data farames: automatically transform non-syntactic names (unless `check.names = FALSE`)

Tibble: NOT auto-transform non-syntactic names

```{r}
names(data.frame(`1` = 1))

names(tibble(`1` = 1))
```
- Every element must have same length, can recycle shorter inputs.
- df: recycle cols that are integer multiple of longest column
- tibble: only recycle vectors of length one

```{r}
data.frame(x = 1:4, y = 1:2)

data.frame(x = 1:4, y = 1:3)

tibble(x = 1:4, y = 1)

tibble(x = 1:4, y = 1:2)
```

tibbles: allow referencing variables created during construction (inputs evaluated left-to-right)

```{r}
tibble(x = 1:3,
       y = x * 2)
```



### 3.6.2: Row names

Label each row with character vector of unique values >>> `rownames()`

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)

df3
df3["Bob", ]
```

Can NOT transpose data frame as you would a matrix.

- Metadata == still data. 
- Row names are bad abstraction for labelling rows as only ID by single string (what about time or multiple vectors?).
- Unique: duplication of rows will create new row names. Matching rows == complicated regex

```{r}
df3[c(1, 1, 1), ]
```

Tibbles: NO row names >> convert row names to regular columns
- `rownames_to_column()` or specify in `rownames` argument in `as_tibble()`

### 3.6.3: Printing

Tibbles: First 10 rows and al columns that can fit on screen.
- Each column labelled with type
- Wide cols truncated

### 3.6.4: Subsetting

Data frames: Subset with `[` will return vector if only 1 variable selected, otherwise data frame
- Extract single column >>> if none then select any that starts with letter, then NULL

Tibble: `[` always returns tibble, `$` not do any partial matching + warning if none

### 3.6.5: Testing and coercing

`is.data.frame()` + `as.data.frame()` <> `is_tibble()` + `as_tibble()`

### 3.6.6: List columns

Data frames: Only created added after creation or wrap list with `I()`
Tibble: Directly included inside tibble creation

### 3.6.7: Matrix and data frame columns 

- Most functions assume data frame columns are vectors 



### exercise

1. Data frame with 0 rows? 0 columns?

```{r}
iris[0, ]
iris[, 0]
iris[0, 0]

data.frame()
```


2. Set rownames that are NOT unique?

- error if `row.names()`
- if subsetting with `[`, automatically de-duplicates


3. Transpose data frame?

returns matrix! output columns coerced to same type!

```{r}
class( t(t(data.frame(mtcars)))  )
```

4. `as.matrix()` to a data frame with different type columns? `data.matrix()`?

`as.matrix()` will coerce column types based on type hierarchy

`data.matrix()` converts to numeric >>> replace characters/factors with internal codes


## 3.7: NULL

NULL: Unique type, always length == 0, no attributes
- `is.null()`



# 4. Subsetting

- 6 ways to subset atomic vectors
- 3 subsetting operators: `[[`, `[`, `$`, interact differently with vector types
- Subsetting can be combined with assignment


## 4.2 Selecting multiple elements

`[`: Select any number of elements from a vector.

### 4.2.1: Atomic vectors

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

Postiive integers: return elements at specified positions:

```{r}
x[c(3, 1)]

x[order(x)]

x[c(1, 1)] ## duplicate indcies == duplicate values

x[c(2.1, 2.9)] ## real numbers truncated to integers
```

Negative integers: exclude elements at specified positions

```{r}
x[-c(3, 1)]
```


Can NOT mix pos and neg in single subset

Logical vectors: Select elements where corresponding logical value == TRUE

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]

x[x > 3]
```

IF `x[y]`, x & y are different lengths >>> recycling rules: shorter of two is recycled to the length of longer

```{r}
x[c(TRUE, FALSE)]
x[c(TRUE, FALSE, TRUE, FALSE)]
```

Missing value >>> NA in output


Nothing: returns original vector

Zero: returns zero-length vector

If named vector >>> character vectors: return elements with matching names


```{r}
(y <- setNames(x, letters[1:4]))

y[c("d", "c", "a")]

y[c("a", "a", "a")]

## names must be matched exactly:
z <- c(abc = 1, def = 2)
z[c("a", "d")]
```

Avoid subsetting with factors as use underlying integer vector and NOT the character levels.


### 4.2.2: Lists

`[`: always returns list
`[[` & `$`: pull elements from list

### 4.2.3: Matrices and arrays

Subset matrices & arrays:

- Multiple vectors
- Single vector
- Matrix

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ]

a[c(TRUE, FALSE, TRUE), c("B", "A")]
```
`[` simplifies results to lowest possible dimension. 

```{r}
a[1, ]
a[1, 1]
```

Single vector subsetting: Matrices + arrays are just vectors with special attributes

Arrays in R: column-major order ![](https://en.wikipedia.org/wiki/Row-_and_column-major_order#/media/File:Row_and_column_major_order.svg)

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals

vals[c(4, 15)]
```

Subset with integer matrix or character matrix (if named)" Each row in matrix  = location of one value, each column = dimension in array

```{r}
select <- matrix(ncol = 2, byrow = TRUE,
                 c(1, 1,
                   3, 1,
                   2, 4))

vals[select]
```

### 4.2.4: Data frames and tibbles

Single index: behave as lists >> index columns `df[1:2]` selects first two cols
Two indices: behave as matrices >> `df[1:3, ]` selects first three rows + all cols

Matrix subsetting simplifies by default, list does NOT.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2,]
df[c(1, 3), ]

df[c("x", "z")] ## list
df[, c("x", "z")] ## matrix

str(df["x"]) ## list
str(df[, "x"]) ## matrix

```

Subsetting tibble with `[` always returns tibble:

```{r}
df <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])

str(df["x"])
str(df[, "x"])
```

### 4.2.5: Preserving dimensionality

Preserve original dimensions >>> set `drop = FALSE`

Matrices + arrays: any dimensions with length 1 will be dropped

```{r}
a <- matrix(1:4, nrow = 2)
str(a[1, ])

str(a[1, , drop = FALSE])
```

Data frames with single column: return single column

```{r}
df <- data.frame(a = 1:2, b = 1:2)
str(df[, "a"])

str(df[, "a", drop = FALSE])
```

Tibble: defaults to using `drop = FALSE`

Factors: `drop` argument controls for levels (NOT dimensions) preserved, defaulting to `FALSE`. 

```{r}
z <- factor(c("a", "b"))

z[1]
z[1, drop = TRUE]
```

### exercise

1. Fix errors

```{r}
mtcars[mtcars$cyl = 4, ]
## need double ==
mtcars[mtcars$cyl == 4, ]

mtcars[-1:4, ]
## need to concatenate multiple selection
mtcars[-c(1:4), ]

mtcars[mtcars$cyl <= 5]
## need comma for all cols
mtcars[mtcars$cyl <= 5, ]

mtcars[mtcars$cyl == 4 | 6, ]
## separate filters need to be concatenated
mtcars[mtcars$cyl %in% c(4, 6), ]
```

2. 

```{r}
x <- 1:5
x[NA]

x[NA_real_] # returns single NA
```

`NA` is type: logical, logical vectors are recycled to the same length as vector being subsetted, so 5 `NA` returned.

3. 

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x

x[upper.tri(x)]
```

`upper.tr()` returns logical matrix with `TRUE` for all upper diagonal elements & `FALSE` else.

Subsetting behavior identical to subsetting with logical matrices.

4. `mtcars[1:20]` returns error? How differ from `mtcars[1:20, ]`

```{r}
mtcars[1:20]

mtcars[1:20,]
```

Subsetting a data frame with a single vector: behaves similarly to subsetting a list of cols. When `mtcars[1:20]` >>> return df with first 20 cols. BUT `mtcars` only have 11 cols so error due to index out of bounds. `mtcars[1:20, ]` is subsetted with 2 vectors == 2d subsetting so first index will refer to the rows.


5.



6. `df[is.na(df)] <- 0`?

```{r}
df[is.na(df)] <- 0
```





## 4.3: Selecting a single element

extract single items: `[[` 
shorthand for `x[["y"]]`: `$`   >>> `x$y`



### 4.3.1: `[[`

Ex.

If list `x` is a train carrying objects 
->> `x[[5]]` is the object inside car 5.
->> `x[4:6]` is a train of cars 4-6.

When extracting a single element: 
- Create a smaller train: `x[1]`
- Extract contents of a particular carriage in train: `x[[1]]`

For extracting multiple or zero elements >>> always need to make a smaller train, `[`.

`[[` only returns a single item. Must use single positive integer or single string.
- Vector: subset recursively: `x[[c(1, 2)]]` == `x[[1]][[2]]` >>> use `purrr::pluck()` instead
- Use also for atomic vectors for extrating single values


### 4.3.2: `$`


- Often used to access variables in a df.
- `$` does partial matching
Ex. 

```{r}
x <- list(abc = 1)
x$a
x[["a"]]
```

To avoid >>> set global option: `warnPartialMatchDollar == TRUE`

- tibbles never do partial matching!


### 4.3.3: Missing and out-of-bounds indices

Some inconsistencies when subsetting with `[[` with an invalid index.

`purrr::pluck()` + `purrr::chuck()`

When element is missing: `pluck()` ALWAYS returns `NULL`, `chuck()` throws `Error`

`pluck()` behavior is good for indexing into deeply nested data structures where component that you want may not exist (ex. JSON data from web APIs).

`pluck()` allows for mixed integer + character indices, and alt default value if item does not exist

```{r}
x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

purrr::pluck(x, "c", 1)
purrr::pluck(x, "c", 1, .default = NA)
```

### 4.3.4: `@` and `slot()`

Subsetting for S4 objects.

`@` equivalent to `$` (more restrictive and will return error if slot not exist) and `slot()` equivalent to `[[`


### exercise

1.

```{r}
mtcars

mtcars$cyl[[3]]

mtcars[3, 2]
mtcars[[c(2, 3)]]

mtcars[["cyl"]][[3]]

with(mtcars, cyl[[3]])

mtcars[3, ]$cyl

mtcars[3, "cyl"]

mtcars[3, ][ , "cyl"]
mtcars[3, ][["cyl"]]
```

2.

```{r}
mod <- lm(mpg ~ wt, data = mtcars)

mod$df.residual
mod$df.res

mod["df.residual"]
mod[["df.residual"]]

summary(mod)$r.squared
```

## 4.4: Subsetting and assignment

Subassignment: All subsetting operators can be combined with assignment values of an input vector

`x[i] <- value`

```{r}
x <- 1:5

x

x[c(1, 2)] <- c(101, 102)

x
```

Make sure that `length(value)` == `length(x[i])`. If not, recycle and may cause problems.

Lists: `x[[i]] <- NULL` to remove components, to add NULL: `x[i] <- list(NULL)`

```{r}
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

y <- list(a = 1, b = 2)
y["b"] <- list(NULL)
str(y)
```

Subsetting with nothing can be useful in assignment as it preserves the structure of the original object.

```{r}
mtcars[] <- lapply(mtcars, as.integer)
mtcars

mtcars <- lapply(mtcars, as.integer)
mtcars
```

## 4.5: Applications

### 4.5.1: Lookup tables (character subsetting)

Ex. convert abbreviations

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x])
```

### 4.5.2: Matching and merging by hand (integer subsetting)


```{r}
grades <- c(1, 2, 2, 3, 1)
info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

grades

info
```

Duplicate `info` so that one row for each value in `grades`

```{r}
id <- match(grades, info$grade)
id

info[id, ]
```

For multiple cols, collapse with `interaction()` or join functions like `merge()` or `dplyr::left_join()`.

### 4.5.3: Random samples and bootstraps (integer subsetting)

Use integer indices to randomly sample/bootstrap a vector/dataframe.

`sample(n)` to generate random permutation of `1:n` then use results to subset values.

```{r}
df <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])

## Randomly reorder
df[sample(nrow(df)), ]

## Select 3 random rows
df[sample(nrow(df), 3), ]

## Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]


```

### 4.5.4: Ordering (integer subsetting)

`order()`: vector input >>> integer vector describing how to order subsetted vector

```{r}
x <- c("b", "c", "a")
order(x)

x[order(x)]
```

Tie-breakers: supply additional variables to `order()`. `decreasing = TRUE/FALSE` option. 

Default: any missing values will be put last. Remove with `na.last = NA` or at front with `na.last = FALSE`.


For 2D or more dimensions >>> order either rows or cols of objects:

```{r}
df
df2 <- df[sample(nrow(df)), 3:1]
df2

df2[order(df2$x), ]

df2[, order(names(df2))]
```


Sort vectors with `sort()` or `dplyr::arrange()` for data frames


### 4.5.5: Expanding aggregated counts (integer subsetting)

Uncollapse identical rows with count columns.
- `rep()` >>> vectorization: `rep(x, y)` repeats `x[i] y[i]` times


```{r}
df <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

rep(1:nrow(df), df$n)

df[rep(1:nrow(df), df$n), ]
```


### 4.5.6: Removing cols from data frames (character subsetting)

Remove cols from df:
1. Set cols to `NULL`

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df$z <- NULL
df
```

2. Subset to return only columns needed

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[, c("x", "y")]
```


If only know columns you DONT want, use set operations to work out which cols to keep:

```{r}
df[setdiff(names(df), "z")]

df %>% select(-z)
```


### 4.5.7: Select rows based on condition (logical subsetting)

```{r}
mtcars[mtcars$gear == 5, ]
```


```{r}
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```


De Morgan's Laws:

- `!(X & Y) == !X | !Y`
- `!(X | Y) == !X & !Y`

### 4.5.8: Boolean algebra vs. sets

Set operations more effective:
- Searching for the first or last `TRUE`
- Have very few `TRUE` and many `FALSE`, set operation = faster + less storage
- `which()` allows convert boolean to integer representation

```{r}
x <- sample(10) < 4

which(x)

unwhich <- function(x, n) {
  out <- rep_len(FALSE, n)
  out[x] <- TRUE
  out
}

unwhich(which(x), 10)
```

- `X & Y` == `intersect(x, y)`
- `X | Y` == `union(x, y)`
- `X & !Y` == `setdiff(x, y)`
- `xor(X, Y)` == `setdiff(union(x, y), intersect(x, y))`

When logical vector contains `NA`, logical subsetting replaces with `NA` while `which()` drops values.

`x[-which(y)]` NOT equivalent to `x[!y]`: IF y == all FALSE, `which(y)` == `integer(0)`. `-integer(0)` is still `integer(0)` so no values returned.


### exercise

1. Randomly permute df cols? Permute rows and cols at same time?

```{r}
df[sample(ncol(df))]

df[sample(nrow(df)), sample(ncol(df))]
```

2. Select random sample of `m` rows from df.

```{r}
m <- 10
mtcars[sample(nrow(mtcars), m), , drop = FALSE]
mtcars[sample(nrow(mtcars), m), ]
```

Blocked sample:

```{r}
start <- sample(nrow(mtcars) - m + 1, 1)
end <- start + m - 1

start; end

mtcars[start:end, , drop = FALSE]
mtcars[start:end, ]
```

3. Cols in alphabetical order


```{r}
mtcars[order(names(mtcars))]

mtcars %>% select(order(colnames(.)))
mtcars %>% select(order(names(.)))
mtcars %>% select(sort(tidyselect::peek_vars()))
```


# 5. Control flow

- Choices: `if` statements, `switch()` calls >> run different code depending on input
- Loops: `for`, `while` >> repeatedly run code with changing options

1. Difference between `if` and `ifelse()`?

`if` works with scalars
`ifelse()` works with vectors

2.

```{r}
x <- TRUE
y <- if (x) 3
y

x <- FALSE
y <- if (x) 3
y

x <- NA
y <- if (x) 3
y
```

3. 

```{r}
switch("x", x = , y = 2, z = 3)
```

## 5.2 Choices

With single `if` statement, returns `NULL` if condition is `FALSE`. 
- `c()` and `paste()` drop `NULL` inputs: much more compact expressions

### 5.2.1: Invalid inputs

`condition` should evaluate to a SINGLE `TRUE` or `FALSE`

```{r}
if ("x") 1

if (logical()) 1

if (NA) 1
```

Logical vector of length > 1: generates warning

```{r}
if (c(TRUE, FALSE)) 1 
```

Can be turned into error via environment variable.

```{r}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
if (c(TRUE, FALSE)) 1 
```

### 5.2.2: Vectorized if

`ifelse()`: vector of logical values >>> `test`, `yes`, `no`

```{r}
x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))

ifelse(x %% 2 == 0, "EVEN", "ODD")
```

Use for SAME type >>> hard to predict output type if different vectors 

`dplyr::case_when()` 


### 5.2.3: `switch()` statement

```{r}
x_option <- function(x) {
  switch(x,
         a = "option 1",
         b = "option 2",
         c = "option 3",
         stop("Invalid 'x' value"))
}
```

Last component of `switch()` should always throw an error or otherwise unmatched inputs will invisibily return `NULL`

```{r}
(switch("c", a = 1, b = 2))
```

If multiple inputs have same output, leave right-hand side empty and input will fall through to next value.

Use `switch()` only for character inputs.

### exercise

1. 

```{r}
ifelse(TRUE, 1, "no") %>% class()
ifelse(FALSE, 1, "no") %>% class()

ifelse(NA, 1, "no") %>% class()
```

```{r}
x <- 1:10
if (length(x)) "not empty" else "empty"

x <- numeric()

if (length(x)) "not empty" else "empty"
```

`length(x)` evaluates to 0 >>> FALSE


## 5.3 Loops

- Iterate over items in a vector.

`for` (item `in` vector) perform_action

For each item in vector >>> perform_action is called once, updating value of `item` every time.

```{r}
for (i in 1:3) {
  print(i)
}
```

`for` assigns `item` to the CURRENT ENVIRONMENT, overwrites any existing variables with the same name.

Terminate loop early:
- `next` exits current iteration
- `break` exits entire loop


```{r}
for (i in 1:10) {
  if (i < 3)
    next
  print(i)
  
  if (i >= 5) 
    break
}
```

### 5.3.1: Common pitfalls

- Pre-allocate output container for generating data.
- Iterating over `1:length(x)` not work if `x` of length == 0. Use `seq_along()` instead.

```{r}
means <- c(1, 50, 20)

out <- vector("list", length(means))

for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}

out
```

Iteration over S3 vectors >>> loops strip attributes so wrap around with `[[`

```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))

for (i in seq_along(xs)) {
  print(xs[[i]])
}
```

### 5.3.2: Related tools

- `while` (condition) action: performs action while condition == `TRUE`
- `repeat` (action): repeats action forever until `break`

- use `map()` and `apply()`


### exercise

```{r}
x <- numeric() 

out <- vector("list", length(x))

for (i in 1:length(x)) {
  out[i] <- x[i] ^ 2
}

out

for (i in seq_along(x)) {
  out[i] <- x[i] ^ 2
}

out
```


2. 

```{r}
x
xs <- c(1, 2, 3)

for (x in xs) {
  xs <- c(xs, x * 2)
}

xs
```


3. 

```{r}
for (i in 1:3) {
  i <- i * 2
  print(i)
}
```

In a for-loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn’t affect the following iterations.






# 6. Functions


## 6.2 Function fundamentals

- Functions: arguments, body, environment
- Primitive "base" functions >>> C
- Functions are objects


### 6.2.1: Function components

- `formals()`: list of arguments that control how you call the function
- `body()`: code inside the function
- `environment()`: data structure that determines how function finds the values associated with the names

Formals + body specified explicitly, environment implictily (based on where function was defined). Function environment always exists, ONLY printed when function is NOT defined in the global environment.

```{r}
f02 <- function(x, y) {
  # blah
  x + y 
}

formals(f02)
body(f02)
environment(f02)
```

Functions can possess `attributes()`. 
- `srcref`: source reference, source code used to create the function. Contains code comments and other formatting

```{r}
attr(f02, "srcref")
```

### 6.2.2: Primitive functions

type `builtin` or `special`

```{r}
typeof(sum)
typeof(`[`)
```

Exist in C so formals, body, environment all `NULL`.

Only found in `base` package. Performance advantages but harder to write

### 6.2.3: First-class functions

R functions are objects >>> "first-class functions".

Create a function object with `function()` and assign with `<-`

```{r}
f01 <- function(x) {
  sin(1 / x ^ 2)
}
```

Anonymous function: function without name

```{r}
lapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
```

Functions can be placed inside lists.

```{r}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
```

### 6.2.4: Invoking a function

Arguments in data structure >>> use `do.call()` 

```{r}
args <- list(1:10, na.rm = TRUE)

do.call(mean, args)
```

### exercise

1.

NO one-to-one mapping between functions and names. Name points to a single object but object can have many names.


2. 

```{r}
(function(x) 3)()
```

Extra `()` separate function call from anonymous function body

3. Descriptive names for non-anonymous functions. Anonymous functions for conciseness.

4. 

Use `is.function()` to test if object is function. Use `is.primitive()` for specifically primitive functions.


5. 

List all functions in `base`

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```


```{r}
n_args <- funs %>% 
  map(formals) %>% map_int(length) 
  
n_args %>%   
  sort(decreasing = TRUE) %>% head()
```

`scan()` has most arguments.
```{r}
n_args2 <- funs %>% discard(is.primitive) %>% map(formals) %>% map_int(length)

sum(n_args2 == 0)
```

Most no arg functions are primitive functions.

6. body, formals, environment.

7. Primitive and functions created in global environment do NOT print their environment.

## 6.3 Function Composition

```{r}
square <- function(x) x^2
deviation <- function(x) x - mean(x)

## 1. nest function calls:
x <- runif(100)

sqrt(mean(square(deviation(x))))

## 2. save intermediate results as variables
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out

## 3. magrittr pipe 
x %>% 
  deviation() %>% 
  square() %>% 
  mean() %>% 
  sqrt()
```

- Nesting: concise, suited for short sequences. Longer == harder to read >>> inside out + right to left. 
- Intermediate objects: Need to name intermediary objects every time.
- Piping: Left-to-right. Only for linear sequences of transformation of a single object. 


## 6.4 Lexical scoping

Scoping: finding value associated with name.

```{r}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```

Lexical scoping: it looks up the values of names based on how a function is DEFINED, not CALLED. Scoping rules use a parse-time > run-time structure.

4 primary rules:
- Name masking
- Functions vs. variables
- Fresh start
- Dynamic lookup

### 6.4.1: Name masking

Names defined inside a function mask names defined outside a function.

```{r}
x <- 10
y <- 20

g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}

g02()
```

IF name not defined inside function, R looks one level up.

```{r}
x <- 2 

g03 <- function() {
  y <- 1
  c(x, y)
}

g03()

y
```

Functions defined another function. R first looks in the current function, then where function was defined, ..., global environment, other loaded packages.

```{r}
x <- 1
y <- 2084

g04 <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}

g04()
```

### 6.4.2: Functions vs. variables

Scoping rules also apply to functions themselves as functions are objects.

```{r}
g07 <- function(x) x + 1
g08 <- function() {
  g07 <- function(x) x + 100
  g07(10)
}

g08()
```

IF function and non-function share same name (in different environments):
- R ignores non-function objects when looking for value of function call.

```{r}
g09 <- function(x) x + 100
g10 <- function(x) {
  g09 <- 10
  g09(g09)
}
g10()
```

### 6.4.3: Fresh start

Values in between invocations of a function:

Run once, then again:

```{r}
g11 <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

g11()
g11()
```

Returns SAME value. Every time function is called, a NEW environment is created to host its execution! Each invocation is completely independent.

### 6.4.4: Dynamic lookup

R looks for values when function is run NOT when created. Output of function can differ depending on objects outside function environment.

```{r}
g12 <- function() x + 1 
x <- 15
g12()

x <- 20
g12()
```

Detect global environment variables, `codetools::findGlobals()`: Lists all external dependencies (unbound symbols) within function.

```{r}
codetools::findGlobals(g12)
```

Manually change function environment to `emptyenv()`. Empty environment.

```{r}
environment(g12) <- emptyenv()
g12()
```

R relies on lexical scoping to find ALL.

### exercise

1. 

```{r}
c <- 10
c(c = c)
```

c: function call `c()`
c: list name `c`
c: variable R object value `c`


2. 

Lexical scoping:
- Name masking, functions vs. variables, fresh start, dynamic lookup


3. 

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}

f(10)
```

Order of calculation from inside-to-outside!


## 6.5 Lazy evaluation

Functions arguments are lazily evaluated: only evaluated if accessed.

```{r}
h01 <- function(x) {
  10
}

## no erroras 'x' is never used.
h01(stop("This is an error"))
```

### 6.5.1: Promises

Lazy eval powered by `promise`/`thunk` data structure. 

3 components:
- Expression: ex. `x + y`, delayed computation
- Environment: Where expression is evaluated.
-- Variable is bound outside of function

```{r}
y <- 10

h02 <- function(x) {
  y <- 100
  x + 1 
}

h02(y)

h02(y <- 1000)
y
```

- Value: Computed & cached the first time a promise is accessed when expression evaluated in specified environment. Promise is evaluated at most once.

```{r}
double <- function(x) {
  message("Calculating...")
  x * 2
}

h03 <- function(x) {
  c(x, x)
}

h03(double(x))
```

Can not manipulate promises with R code.


### 6.5.2: Default arguments

Default values can be defined in terms of other arguments or variables defined later in function >>> NOT RECOMMENDED. Code harder to understand. 


```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  c(x, y, z)
}

h04()
```

Evaluation environment different between default vs. user-supplied arguments. Defaults are evaluated inside function.


### 6.5.3: Missing arguments

`missing()` to find if user or default:

```{r}
h06 <- function(x = 10) {
  list(missing(x), x)
}

str(h06())
str(h06(10))
```


### exercise

1. `&&` 

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)

x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```
We expect x_ok() to validate its input via certain criteria: it must not be NULL, but have length 1 and a value greater than 0. Meaningful outcomes for this assertion will be TRUE, FALSE or NA. The desired behaviour is reached by combining the assertions through && instead of &.

&& does not perform elementwise comparisons, instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from ?Logic). This means that the RHS of && won’t be evaluated if the LHS already determines the outcome of the comparision (e.g. evaluate to FALSE). This behaviour is also known as ‘shortcircuiting’. For some situations (x = 1) both operators will lead to the same result. But this is not always the case. For x = NULL, the &&-operator will stop after the !is.null-statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of &), the outcome would change. NULL > 0 returns logical(0), which is not helpful in this case.)

We can also see the difference in behaviour, when we set x = 1:3. The &&-operator returns the result from length(x) == 1, which is FALSE. Using & as the logical operator leads to the (vectorised) x > 0 condition being be evaluated and also returned.


2. What does `f2()` return? Why? 

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}

f2()
```

Return `100`. Default argument value can be lazy evaluated within function environment when `x` gets accessed where `x` == `z`.



```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()
y
```

The function returns c(2, 1) which is due to name masking. When x is accessed within c(), the promise x = {y <- 1; 2} is evaluated inside f1()’s environment. y gets bound to the value 1 and the return value of {() (2) gets assigned to x. When y gets accessed next within c(), it has already the value 1 and R doesn’t need to look it up any further. Therefore, the promise y = 0 won’t be evaluated. Also, as y is assigned within f1()’s environment, the value of the global variable y is left untouched.


4. 

```{r}
hist(mtcars$mpg, xlim = c(10, 55))
```

The xlim argument of hist() defines the range of the histogram’s x-axis. In order to provide a valid axis xlim must contain a numeric vector of exactly two unique values. Consequently for the default xlim = range(breaks)), breaks must evaluate to a vector with at least two unique values.

During execution hist() overwrites the breaks argument. The breaks argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore the specific behaviour depends highly on the input. But hist ensures that breaks evaluates to a numeric vector containing at least two unique elements before xlim is computed.




5. 

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
show_time(x = stop("Error!"))
```

Before show_time() accesses x (default stop("Error")), the stop() function is masked by function(...) Sys.time(). Because default arguments are evaluated in the function environment, print(x) will be evaluated as print(Sys.time()).

This function is confusing, because its behaviour changes when x’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of stop won’t affect the outcome any more.



6.

```{r}
library()
```



## 6.6 ...


Functions can have special argument `...`. Can take ANY number of additional arguments. "varargs", "variadic". Use `...` to pass additional arguments to another function. 


```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
```

Can use `..N` to refer to elements of `...` by position. 

`list(...)`: evaluates arguments and stores in list

```{r}
i04 <- function(...) {
  list(...)
}

str(i04(a = 1, b = 2))
```


Primary uses of `...`:

- If function takes a functio nas argument, use as means of passing additional arguments to that function.

Ex. `...` in `lapply()` to pass `na.rm` arg to `mean()`:

```{r}
x <- list(c(1, 3, NA), c(4, NA, 6))
str(lapply(x, mean, na.rm = TRUE))
```

- If function == S3 generic, use to allow methods to take arbitrary extra arguments. 
-- `print()`: different options for printing depending on type of object, no ay to pre-specify EVERY possible argument, so `...` allows individual methods to have different arguments.

```{r}
print(factor(letters), max.levels = 4)
print(y ~ x, showEnv = TRUE)
```

Downsides:

- Necessity to carefully explain where arguments go.
- Misspelled arguments will not raise error!

### exercise

1. 

```{r}
sum(1, 2, 3)
mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE) ## TRUE is evaluated as numeric `1` as 'na.omit' is not a real argument that can be passed on
mean(1, 2, 3, na.omit = TRUE)
```

However, in contrast to sum() the elements of ... are not “part” of the mean. The other supplied arguments are matched by their order, i.e. x = 1, trim = 2 and na.rm = 3. As x is of length 1 and not NA, the settings of trim and na.rm do not affect the calculation of the mean. Both calls (mean(1, 2, 3) and mean(1, 2, 3, na.omit = TRUE)) return 1.


2. 

```{r}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```


## 6.7 Exiting a function

Exit: return value (success) or error (failure). 

### 6.7.1: Implicit vs. explicit returns

Functions return values in 2 ways:

1. Implicitly: where last evaluated expression is return value

2. Explicitly: calling `return()`


### 6.7.2: Invisible values

Most functiosn return visibly: calling function in interactive context prints the result. Prevent automatic printing by applying `invisible()` to last value.

```{r}
j03 <- function() 1
j03()

j04 <- function() invisible(1)
j04()
```

To verify invisibly value actually exists, explicitly `print()`, wrap in `()`, or `withVisible()`

```{r}
print(j04())
(j04())
str(withVisible(j04()))
```

Most common function that returns invisibly `<-` 

```{r}
a <- 2
(a <- 2)

## chain assignments
a <- b <- c <- d <- 2
```

In general: any function called primarily for a SIDE EFFECT (`<-`, `print()`, `plot()`, etc.) should return an invisible value (typically value of first argument).


### 6.7.3: Errors

If function can not complete assigned task >>> error with `stop()`.

### 6.7.4: Exit handlers

Temporary changes to global state >> clean up can be painful esp. if error.

Use `on.exit()` to restore global state no matter how function exits.


```{r}
j06 <- function(x) {
  cat("Hello\n")
  on.exit(cat("Goodbye!\n"), add = TRUE)
  
  if (x) {
    return(10)
  } else {
    stop("Error")
  }
}

j06(TRUE)
j06(FALSE)
```

ALWAYS set `add = TRUE`: else each call to `on.exit()` will overwrite previous exit handler. 

R 3.4: `on.exit()` expressions run in order of creation.
R 3.5: control by setting `after = TRUE/FALSE`.


### exercise

1. `load()` return?

load() loads objects saved to disk in .Rdata files by save(). When run successfully, load() invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to TRUE or surround the call in parentheses to trigger R’s auto-printing mechanism.

2. 

```{r}
print(readr::write_csv(mtcars, here::here("mtcars.csv")))
```


3.

4. 

```{r}
plot_pdf <- function(code) {
  pdf("test.pdf")
  plot(code)
  on.exit(dev.off(), add = TRUE)
  code
}

plot_pdf(mtcars)
```


5. 


```{r}
body(capture.output)
```



## 6.8. Function forms


> Everything that exists is an object.
> Everything that happens is a function call.
- John Chambers

Function call varieties:

- prefix: function name comes before arguments.
-- ex. `footy(a, b, c)`

- infix: function name comes between arguments. Mainly mathematical operators, user-defined functions begin/end in `%`
-- ex. `x + y`

- replacement: functions that replace values by assignment.
-- ex. `names(df) <- c("a", "b", "c")`

- special: `if`, `for`, `[[`, etc.


### 6.8.1: Rewriting to prefix form

Every infix, replacement, special form can be rewritten in prefix form.



```{r}
x + y
`+`(x, y)

names(df) <- c("a", "b", "c")
`names<-`(df, c("a", "b", "c"))

for(i in 1:10) print(i)
`for`(i, 1:10, print(i))
```

Functional programming

```{r}
add <- function(x, y) x + y

lapply(list(1:3, 4:5), add , 3)
## or instead use `+`
lapply(list(1:3, 4:5), `+`, 3)
```


### 6.8.2: Prefix form

Prefix arguments:

- by position `help(mean)`
- by partial matching `help(top = mean)`
- by name `help(topic = mean)`



```{r}
k01 <- function(abcdef, bcde1, bcde2) {
  list (a = abcdef, b1 = bcde1, b2 = bcde2)
}

str(k01(1, 2, 3))
str(k01(2, 3, abcdef = 1))
str(k01(2, 3, a = 1))
```

In general: use positional matching only for first one~two arguments. NEVER use partial matching!

```{r}
options(warnPartialMatchArgs = TRUE)
```

### 6.8.3: Infix functions

Function comes inbetween arguments.

Ex.

`:`, `::`, `:::`, `$`, `^`, `*`, `!=`, `&&`, etc.

Can define own via `%____%`

```{r}
`%+%` <- function(a, b) paste0(a, b)

"new" %+% "string"
```

Need to excape special characters in string for defining function but not when actual call.

```{r}
`% %` <- function(a, b) paste(a, b)
`%/\\%` <- function(a, b) paste(a, b)

"a" % % "b"
"c" %/\% "z"
```
Infix operators are composed left-to-right.

`+` and `-` can be called with a single argument.


### 6.8.4 Replacement functions

Replacement functiosn act like they modify arguments in place >>> `xxx <-` 
- Must have arguments `x` and `value`, must return modified object.

```{r}
`second<-` <- function(y, value) {
  y[2] <- value
  y
}

y <- 1:10
second(y) <- 5L
y

y <- 1:10
tracemem(y)
second(y) <- 6L
```

Create modified copy rather than actually modify arguments in place. If replacement function needs additional arguments, place between `x` and `value`. The additional arguments should e supplied on the left. 

```{r}
`modify<-` <- function(y, position, value) {
  y[position] <- value
  y
}

modify(y, 1) <- 10
y
```


Replacement with other functions translated using `*tmp*` local variable which is removed post-execution.


### 6.8.5 Special forms

All special forms are implemented as primitive functions (in C)

Special forms also have prefix forms:

`(x)` == `(`x))
`{x}` == `{`x))

`x[i]` == (`[`x, i))
`x[[i]]` == (`[[`x, i))

if (cond) true == (`if`(cond, true))
for(var in seq) action == (`for`(var, seq, action))

etc.

Knowing name of function underlying special form is useful for getting docs. 

?`(` rather than ?(

### exercise 

1.

```{r}
1 + 2 + 3

`+`(`+`(1, 2), 3)

1 + (2 + 3)
`+`(1, `+`(2, 3))

x <- c(1, 2, 3, 4, 5, 6, 7)
n <- 3

if (length(x) <= 5) x[[5]] else x[[n]]

`if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, n))
```

2. 

```{r}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

Argument rules: Exact match, partial match, position

```{r}
x <- sample(c(1:10, NA), size = 20, replace = TRUE)
y <- runif(20, min = 0, max = 1)
cor(x, y, use = "pairwise.complete.obs", method = "kendall")
```

3. 

```{r}
modify(get("x"), 1) <- 10

## equivalent to:
get("x") <- `modify<-`(get("x"), 1, 10)
```

There is no corresponding replacements function for `get()`. 


4. Modify reandom location in vector

```{r}
`random<-` <- function(x, value) {
  idx <- sample(length(x), 1)
  
  x[idx] <- value
  x
}

`random<-`(c(4, 5, 6, 7), 10)

x <- c(4, 5, 6, 7)
random(x) <- 69L
```

5. 

```{r}
`+` <- function(a, b = 0L){
  if (is.character(a) && is.character(b)) {
    paste0(a, b)
  } else {
    base::`+`(a, b)  
  }
}

# Test functionality
+ 1
#> [1] 1
1 + 2
#> [1] 3
"a" + "b"
#> [1] "ab"

c("a", "b", "c") + c("d", "e", "f")

# Return back to the original `+` operator
rm(`+`)
```


6. 

```{r}
repls <- apropos("<-", where = TRUE, mode = "function")
repls

repls_base <- repls[names(repls) == length(search())]
repls_base

repls_base_prim <- mget(repls_base, envir = baseenv()) %>% Filter(is.primitive, .) %>% names()
repls_base_prim
```


7. Valid names for user-created infix functions?

Wrap around with `%` but can't contain `%` inside.

8. infix version of `xor()`

```{r}
`%xor%` <- function(a, b) {
  xor(a, b)
}

TRUE %xor% TRUE
FALSE %xor% TRUE
```


8.


```{r}
`%n%` <- function(a, b) {
  base::intersect(a, b)
}

c(2, 4, 6, 8) %n% c(2, 5, 7, 9)
```



# 7 Environments

Environment: Data structure that power scoping. Lexical scoping, namespaces, R6 classes, etc.


## 7.2 Environment basics

Environment: similar to named list with 4 exceptions

- Every name must be unique.
- Names in an environment are NOT ordered.
- Environment has a parent.
- Environments are not copied when modified.

### 7.2.1: Basics

Use `rlang::env()`, works like `list()` taking a set of name-value pairs.

```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3
)

e1[[1]]
e1[c("a", "b")]
```

In Base R: use `new.env()`, use `$<-` to define values.

Environment: associate or bind a set of names to a set of values. "A bag of names" with no implied order. Environments have reference semantics, when modified - they are modified in place and DONT create a copy. Environments can contain themselves.

```{r}
e1$d <- e1

e1 ## only display memory address...
env_print(e1) ## more info

## find character vector of current bindings
env_names(e1)
```

For Base R: use `names()` (for R 3.2.0 and greater).


### 7.2.2: Important environments

Current environment: `current_env()` is environment in which code is currently executing.

Global environment: `global_env()` is enrivonment for when experimenting interactively. "Workspace" where all interactive computation (outside of function) take place.

For environment comparison use `identical()` as `==` is vectorized operator. Environments are NOT vectors.

```{r}
identical(global_env(), current_env())
```

Base R: `globalenv()` (printed as `Rf_GlobalEnv` and `.GlobalEnv`) and `environment()`.

### 7.2.3: Parents

Every environment has a parent. Parent used to implement lexical scoping. IF name is not found in an environment, R then checks in the parent. Set parent environment by supplying an unnamed argument to `env()`, otherwise default to current environment. 

```{r}
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)

env_print(e2b)

env_parent(e2b)
env_parent(e2a)

env_parents(e2b)
```

Empty environment: Has NO parent. `R_EmptyEnv`. Every environment eventually terminate an empty environment. By default, `env_parents()` stops at global environment. Ancestors of global environment include every attached package.

Base R: Use `parent.env()`. 


### 7.2.4: Super assignment

- Regular assignment `<-` creates variable in current environment. 
- Super assignment `<<-` modifies existing variable found in parent environment.

If not find existing variable, will create in global environment. Global variables introduce non-obvious dependencies between functions. 


### 7.2.5: Getting & Setting

Similar to list, get + set elements of environment with `$` and `[[`:

```{r}
e3 <- env(x = 1, y = 2)
e3$x
e3$z <- 3
e3[["z"]]

env_get(e3, "abc")
env_get(e3, "abc", default = NULL)
```

Returns `NULL` if binding does not exist. Set default with `default` argument. 

Can NOT use `[[` with numeric indices or `[`.


`env_poke()`: take name as string and a value:

```{r}
env_poke(e3, "a", 100)
e3$a
```

`env_bind()`: Bind multiple values:


```{r}
env_bind(e3, a = 10, b = 20)
env_names(e3)
```

`env_has()`: determine if environment has binding: 

```{r}
env_has(e3, "a")
```

Unlike lists, setting element == `NULL` does NOT remove it. Sometimes you want a name that refers to `NULL`. Use `env_unbind()` instead.

```{r}
e3$a <- NULL
env_has(e3, "a")

env_unbind(e3, "a")
env_has(e3, "a")
```

Unbinding does NOT delete object >> garbage collector.

Base R: `get()`, `assign()`, `exists()`, `rm()` for current environment.

### 7.2.6: Advanced bindings

`env_bind_lazy()`: Creates "delayed bindings" - which are evaluated the first time they are accessed. Delayed bindings create promises, behave similarly to function arguments. 

```{r}
env_bind_lazy(current_env(), b = {Sys.sleep(1); 1})

system.time(print(b))
system.time(print(b))
```

Main use for `autoload()`, allows R packages to provide datasets that behave as though loaded in memory even though only loaded from disk when needed.

`env_bind_active()`: Creates "active bindings" - re-computed every time they're accessed. Used to implement R6's active fields. 

```{r}
env_bind_active(current_env(), z1 = function(val) runif(1))

z1
z1
```

Base R: `delayedAssign()` and `makeActiveBinding()`.


### exercise


1. Differences: Environments vs. lists

- Environments have reference semantics (do NOT copy-on-modify)
- Environments have parents
- Environment elements are NOT ordered
- Environment elements must have unique names

2. 

```{r}
e1 <- env()
e1$loop <- e1

env_print(e1)
```


3. 

```{r}
e1 <- env()
e2 <- env()

e1$loop <- e2
e2$dedoop <- e1

env_print(e1)
env_print(e2)
```

4. 

```{r}
env_print(e1)
```


Environments have no ordered elements. Environments return 2 objects at the same time.


5. Single assignment for `env_poke()`


```{r}
env_poke2 <- function(env, name, value) {
  if (env_has(env, name)) {
    abort(paste0("\"", name, "\" is already assigned to a value."))
  }

  env_poke(env, name, value)
  invisible(env)
}

# Test
env_1 <- env(a = 1)
env_poke2(env_1, "b", 2)
env_names(env_1)
#> [1] "a" "b"
env_poke2(env_1, "b", 2)
#> Error: "b" is already assigned to a value.
```


6. 

```{r}
rebind <- function(name, value, env = caller_env()) {
  if (identical(env, empty_env())) {
    stop("Can't find `", name, "`", call. = FALSE)
  } else if (env_has(env, name)) {
    env_poke(env, name, value)
  } else {
    rebind(name, value, env_parent(env))
  }
}
rebind("a", 10)
#> Error: Can't find `a`
a <- 5
rebind("a", 10)
a
#> [1] 10
```


The primary differnce between rebind() and <<- is that rebind() will only carry out an assignment when it finds an existing binding; unlike <<- it will never create a new one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions.



## 7.3 Recursing over environments

Recursive function: operate on every ancestor of an environment. 

- `where()`:

```{r}
where <- function(name, env = caller_env()) {
  if (identical(env, empty_env)) {
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name)) {
    env
  } else {
    where(name, env_parent(env))
  }
}
```

Base: Reached empty environment and haven't found binding >>> throw error.
Success: Name exists in this environment >>> return environment
Recursive: Name not found in environment >>> try parent environment

```{r}
where("yyy")

x <- 5
where("x")

where("mean")
```

Iterative version:

```{r}
f2 <- function(..., env = caller_env()) {
  while (!identical(env, empty_env))) {
    if (success) {
      return()
    }
    env <- env_parent(env)
  }
  ## base case
}
```



### exercise

1. 

```{r}
where2 <- function(name, env = caller_env(), results = list()) {
  if (identical(env, empty_env())) {
    # Base case
    results
  } else {
    # Recursive case
    if (env_has(env, name)) {
      results <- c(results, env)
    }
    where2(name, env_parent(env), results)
  }
}

# Test
e1a <- env(empty_env(), a = 1, b = 2)
e1b <- env(e1a, b = 10, c = 11)
e1c <- env(e1b, a = 12, d = 13)

where2("a", e1c)
```




2. 


```{r}
fget <- function(name, env = caller_env(), inherits = TRUE) {
  # Base case
  if (env_has(env, name)) {
    obj <- env_get(env, name)

    if (is.function(obj)) {
      return(obj)
    }
  }

  if (identical(env, emptyenv()) || !inherits) {
    stop("Could not find function called \"", name, "\"",
         call. = FALSE)
  }

  # Recursive Case
  fget(name, env_parent(env))
}

# Test
mean <- 10
fget("mean", inherits = TRUE)
#> function (x, ...) 
#> UseMethod("mean")
#> <bytecode: 0x1899b78>
#> <environment: namespace:base>
```






## 7.4 Special environments


Most environments are created by R rather than the user. 


### 7.4.1: Package environments and search path

Each package attached by `library()` or `require()` becomes one of the parents of the global environment. Immediate parent of the global environment is the LAST package that was attached, then the second to last, etc.

Search path: order of packages attached, can be found from top-level interactive workspace.

```{r}
search()

search_envs()
```

Last 2 environments on search path are always the same:
-`Autoloads` environment: uses delayed bindings to save memory by only loading package objects when needed
- `base` environment: package:base. Access with `base_env()`


### 7.4.2: Function environment

A function binds the current environment when it is created, used for lexical scoping. Across computer languages, functions that capture/enclose their environments are called `closures`.

```{r}
y <- 1
f <- function(x) x + y 

fn_env(f)
```

Base R: use `environment()`


### 7.4.3: Namespaces 

- Prevent packages from finding different functions if loaded in different order. Every package works the same way regardless of what packages are attached by the user, and their order. 

```{r}
sd
```

Every function in a package is associated with a PAIR of environments

- Package environment: external interface to the package. Parent determined by search path. How user finds a function in an attached package or with `::`. Controls how we find function.
- Namespace environment: internal interface to the package. Controls how function finds its variables. 

Every binding in package environment is also found in namespace environment. Ensures EVERY function can use every other function in the package. Some bindings only occur in the namespace environment >> internal or non-exported objects. Allows for hide internal implementation details from the user.

Every namespace environment has same set of ancestors:

- `imports` environment that contains bindings to all functions used by the package. Imports environment is controlled with the `NAMESPACE` file.
- Parent of the imports environment is the `base namespace`. Contains same bindings as the base environment but has different parent.
- Global environment: Parent of `base namespace`. If binding isn't defined in imports environment, the package willl look in usual way, up the parents. 

Argument value found in sequence of environments determined by package developer, NOT the user. Code always works same way regardless of what packages have been attached by the user. 


### 7.4.4: Execution environments

```{r}
g <- function(x) {
  if (!env_has(current_env(), "a")) {
    message("Defining a")
    a <- 1
  } else {
    a <- a + 1
  }
  a
}
```

Returns SAME, every run due to 'fresh start principle'. Each tie the function is called, a new environment is created to host its execution. 

To have function environment stay longer:
- Explicitly return it: `current_env()`
- Return an object with a binding to that environment, ex. function >>> function factory

### exercise

1. 

```{r}
search_envs() # returns global, ALL environments on search path. 

env_parents(global_env()) # not return global, empty included. List ALL ancestors of global environment
```



## 7.5 Call stacks

Caller environment: accessed with `rlang::caller_env()`. Provides environment from which function was called and varies based on how function is called, NOT how function was created. 

Base R: `parent.frame()`


Executing function creates two types of context:
- Execution environment is child of function environment is de etermined by WHERE function was CREATED.
- Call stack created by WHERE function was CALLED. 


### 7.5.1: Simple call stacks

`f()` calls `g()` calls `h()`

```{r}
f <- function(x) {
  g(x = 2)
}

g <- function(x) {
  h(x = 3)
}

h <- function(x) {
  stop()
}

f(x = 1)
traceback()
```

Use `lobstr::cst()`: opposite order from `traceback(). Sequence of calls from beginning rather than end.

```{r}
h <- function(x) {
  lobstr::cst()
}

f(x = 1)
```

### 7.5.2: Lazy evaluation

```{r}
a <- function(x) b(x)
b <- function(x) c(x)
c <- function(x) x

a(f())
```

x is laziy evaluated so two separate branches. 

- Branch #1: `a()` calls `b()`,  then `b()` calls `c()`
- Branch #2: When `c()` evaluates its argument `x`. Argument evaluated in new branch as environment in which it is evaluated is the global environment, NOT environment of `c()`. 

### 7.5.3: Frames

Frame: each element of a call stack, evaluation context. 

3 key components: 
- Expression `expr` giving function call. What `traceback()` prints out.
- Environment `env` typically execution environment of a function. 
-- 2 exceptions: Global frame == global environment. Calling `eval()` generates frames where environment can be anything
- Parent: the previous call in the call stack.



### 7.5.4: Dynamic scope

Dynamic scoping: Looking up variables in the calling stack > enclosing environment

Dynamic scoping makes it harder to reason about how a function operates. Need to know how it was defined AND know context in which it is called. 


### exercise


```{r}
ls(all.names = TRUE)

ls2 <- function(env = caller_env()) {
  sort(env_names(env))
}

ls2()
```

## 7.6 As data structures


Environments useful as data structures as they have reference semantics. 

- Avoid copies of large data: Environments have reference semantics so never accidentally create a copy. Use `R6` objects as bare environments are difficult to work with.

- Managing state within a package: Explicit environments are useful in packages as can maintain state across function calls. Objects in packages are locked - can't modify directly.

```{r}
my_env <- new.env(parent = emptyenv())
my_env$a <- 1

get_a <- function() {
  my_env$a
}

set_a <- function(value) {
  old <- my_env$a
  my_env$a <- value
  invisible(old)
}

set_a(5)

my_env$a
```

- Hashmap: data structure that takes a constant, `O(1)`, time to find object based on its name. 


# 8 Conditions

Condition system: provides a paired set of tools that allow author of cuntion to indicate something unusual is happening >> tells user of function to deal with it.

- Function author signals conditions with functions like `stop()`, `warning()`, `message()`, then the function user can handle them with functions like `tryCatch()` and `withCallingHandlers()`. 

- Signal conditions from functions created AND handle conditions signalled by the functions called

R base conditions system on Common Lisp. 

## 8.2 Signalling conditions

3 conditions that you can signal in code: errors, warnings, messages

- Errors: most severe, indicate that no way for function to continue, must stop.
- Warnings: Indicate that something has gone wrong but function has partially recovered
- Message: Inform users that some action has been performed on their behalf.

Interrupt: User interrupted execution by pressing `Esc`, `Ctrl+Break`, `Ctrl+C`. 

### 8.2.1: Errors

Base R: `stop()`

By default, error message includes the call, but typicall not useful. Use `traceback()`. Use `call. = FALSE` to not include call.

{rlang} equivalent: `abort()`, use `glue::glue()` for construct complex error messages.

```{r}
h <- function() abort("This is an error!")
h()
```

Error mesages: Describe what is wrong + point towards fixing problem.
- Difficulty from developer and user to imagine other perspective.

### 8.2.2: Warnings 

Warnings: signal something gone wrong but code recover and continue. Can have multiple warnings in a single function call.

```{r}
fw <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warning("W3")
}

fw()
```

`option()`: 

- `warn = 1`: warnings appear immediately
- `warn = 2`: warnings into errors
- `warn = 0`: restore default behavior

- suppress call with `call. = FALSE` argument
- {rlang}: `warn()`

- Deprecate function: allow older code to continue but encourage usage of new function
- Recovery: If certain that can recover from problem, otherwise throw error.


### 8.2.3: Messages

Messages: informational, tell users something done on their behalf. Displayed immediately and do not have `call.` argument.

- Default argument requires some non-trivial amount of computation >>> tell user what value was used. Ex. {ggplot2} reports # of bins if no `binwidth` supplied.

- Functions called primarily for side-effects which would otherwise be silent. Ex. Files to disk, web API, writing to DB >>> provide status messages to tell what's happening to user. 

- Long running process with no intermediate output >>> progress bar may be better.

- Display message when package is loaded `packageStartupMessage()`

Any function producing message should provide some way to suppress it. 

- `cat()`: WHen primary role of function is to print to console.
-- Ex. `print()`, `str()` methods

- `message()`: Print to console when primary purpose of function is something else.

`cat()` is for when user ASKS for something to be printed. `message()` for when developer `elects()` to print something. 


### exercise 

1. 

```{r}
file_remove_strict <- function(path) {
  if (!file.exists(path)) {
    stop("Can't delete the file '", path, "' because it doesn't exist.",
         call. = FALSE)
  }
  file.remove(path)
}
```


2. 

The appendLF argument automatically appends a new line to the message.

```{r}
multiline_msg <- function(appendLF = TRUE) {
  message("first", appendLF = appendLF)
  cat("second")
  cat("third")
}

multiline_msg(appendLF = TRUE)
#> first
#> secondthird
multiline_msg(appendLF = FALSE)
#> first
#> secondthird
```


## 8.3 Ignoring conditions

- `try()`: ignore errors
- `suppressWarnings()`: ignore warnings
- `suppressMessages()`: ignore messages

`try()`: allows for execution to continue even after error occur. Error message will display. Do assignment in call, define a default value to be used IF code NOT succeed. Argument evaluated in calling environment and NOT inside function.

```{r}
default <- NULL
try(default <- read.csv("blah-blah.csv"), silent = TRUE)
default
```

## 8.4 Handling conditions

Every condition has default behavior. Condition handlers allow temporary override/supplement to default behavior.

`tryCatch()` & `withCallingHandlers()`: Register handlers - functiosn that take signalled conditoin as their single argument.

```{r}
tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning signalled
  },
  message = function(cnd) {
    # code to run when message signalled
  },
  code_to_run_while_handlers_are_active
)
```


- `tryCatch()`: defines exiting handlers, after condition is handled, control returns to context where `tryCatch()` was called. Most suitable for workign with errors + interrupts.

- `withCallingHandlers()`: defines calling handlers - after condition is captured, control returns to context where condition was signalled. Most suitable for working with non-error conditions.

Condition objects: created implicitly when signal condition, becomes explicit inside handler.

### 8.4.1: Condition objects

`rlang::catch_cnd()`: view condition object by catching from signalled condition

```{r}
cnd <- catch_cnd(stop("an error"))

str(cnd)
```

- Build-in conditions are lists with two elements:
-- message: length-1 character ector containing text to display to user >> extract with `conditionMesasge(cnd)`
-- call: call which triggered the condition >> extract with `conditionCall(cnd)`

- Conditions have "class" attribute (character vector) >>> S3 objects. Determines which nalders will match the condition.

### 8.4.2: Exiting handlers 

`tryCatch()` registers exiting handlers >>> allows override default error behavior. 

```{r}
f3 <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    log(x)
  )
}

## return NA instead of throw error
f3("x")
```

If NO conditions signalled OR class of signalled condition NOT match handler name, code executes normally. 

Handlers set up by `tryCatch()` called exiting handlers: After condition is signalled, control passes to the handler and never returns to the original code - effectively the code exits at this point.

```{r}
tryCatch(
  message = function(cnd) "There",
  {
    message("Here")
    stop("This code is never run!")
  }
)
```

Protected code is evaluated in environment of `tryCatch()` but handler code is NOT as handlers are functions. 

Handler function has single argument, condition object `cnd`. Useful when create own custom conditions. 

```{r}
tryCatch(
  error = function(cnd) {
    paste0("-haha-", conditionMessage(cnd), "-haha-")
  },
  stop("This is an error")
)
```

`finally` argument: Specifies block of code to run regardless of whether initial expression succeeds or fails. Ex. clean up: delete files, close connections, etc. Equivalent to `on.exit()`.


### 8.4.3: Calling handlers

`withCallingHandlers()`: set up calling handlers, code execution continues normally once the handler returns. Use for non-error conditions. 

- Exiting handler: Handles signal by making problem go away
- Calling handler: Handles signal by keeping it.

Handlers are applied in order. 

```{r}
tryCatch(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)

withCallingHandlers(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)
```

Return value of a calling handler is ignored because the code continuse to execute after handler completes. Handlers only useful for side-effects.

Muffle: Prevent condition from bubbbling up to parent handlers but still run rest of code in block, explicitly muffle it with `rlang::cnd_muffle()`



### 8.4.4: Call stacks

Call statcks of exiting and calling handlers are different!

```{r}
f <- function() g()
g <- function() h()
h <- function() message("!")
```

* Calling handlers: called in context of the call that signalled the condition
* Exiting handlers: called in context of the call to `tryCatch()`

```{r}
withCallingHandlers(f(), message = function(cnd) {
  lobstr::cst()
  cnd_muffle(cnd)
})

tryCatch(f(), message = function(cnd) lobstr::cst())
```


### exercise 

1. Info from `abort()` vs. `stop()`?

```{r}
?abort()
?stop()
```

`abort()`: does not include call info by default. Backtrace always saved into error objects. Supply metadata `...` arg, create classed condition `class` arg. 

2. 

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}
```


```{r}
show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

3. 

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

`message()` shows message but also keeps running rest of the code. b > a then b > c

4. 

`catch_cnd()`: captures any condition signalled while evaluating its argument. Useful when expect specific condition to be signalled for debugging/unit testing.

```{r}
catch_cnd(10)
catch_cnd(abort("errores"))
catch_cnd(signal("condiciones", message = "mamma mia"))
```
5. 

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
      cnd_muffle("cnd")
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

## 8.5 Custom conditions

Most functions generate one of the built-in conditions >> contain only message and call. If want to detect a certain type of error >> can only work with TEXT of the error message. Messages can change and translation issues. However, can create custom conditions containing useful metadata. Use `rlang::abort()` to supply `.subclass` and other metadata. 


### 8.5.1: Motivation

`base::log()`: absolute minimum for errors caused by invalid args.

```{r}
log(letters)
log(1:10, base = letters)
```

Be more explicit about WHICH argument is the problem and say what the problematic input is. 

```{r}
my_log <- function(x, base = exp(1)) {
  if (!is.numeric(x)) {
    abort(paste0(
      "'x' must be a numeric vector; not ", typeof(x), "."
    ))
  }
  if (!is.numeric(base)) {
    abort(paste0(
      "'base' must be a numeric vector; not ", typeof(base), "."
    ))
  }
  base::log(x, base = base)
}

my_log(letters)
my_log(1:10, base = letters)
```

### 8.5.2: Signalling

Still all metadata about error is in single string... need to build more infrastructure. Create custom `abort()` function for bad arguments. Create nice error message for user and store metadata in the condition call for the developer. 

```{r}
abort_bad_argument <- function(arg, must, not = NULL) {
  msg <- glue::glue("'{arg}' must {must}")
  if (!is.null(not)) {
    not <- typeof(not)
    msg <- glue::glue("{msg}; not {not}")
  }
  abort("error_bad_argument",
        message = msg,
        arg = arg,
        must = must, 
        not = not)
}

my_log <- function(x, base = exp(1)) {
  if (!is.numeric(x)) {
    abort_bad_argument("x", must = "be numeric", not = x)
  }
  if (!is.numeric(base)) {
    abort_bad_argument("base", must = "be numeric", not = base)
  }
  base::log(x, base = base)
} 

my_log(letters)
my_log(1:10, base = letters)
```

### 8.5.3: Handling

Same interactive error messages but much easier to program with. 

Capture error, then assert it has structure we expect:

```{r}
library(testthat)

err <- catch_cnd(my_log("a"))

err

expect_s3_class(err, "error_bad_argument")
expect_equal(err$arg, "x")
expect_equal(err$not, "character")
```


Class: `error_bad_argument` in `tryCatch()` to only handle that specific error:

```{r}
tryCatch(
  error_bad_argument = function(cnd) "bad_argument",
  error = function(cnd) "other error",
  my_log("a")
)
```

For `tryCatch()` with multiple handlers and custom classes, the FIRST handler to match any class in signal's class vector is called, not necessarily the best match. So necessary to put most specific handlers first.


### exercise 


1.

```{r}
check_installed <- function(package) {
  if (!requireNamespace(package, quietly = FALSE)) {
    abort(
      "error_pkg_not_found",
      message = paste0("package '", package, "' not installed."),
      package = package
    )
  }
  TRUE
}

check_installed("ggplot2")
check_installed("ggplot69")

```

2. Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

Instead returning an error it might be preferable to throw a customized condition and place a standardized error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.

## 8.6 Applications

### 8.6.1: Failure value

Wrapper to return a default if error occurs:

```{r}
fail_with <- function(expr, value = NULL) {
  tryCatch(
    error = function(cnd) value, 
    expr
  )
}

fail_with(log(10), NA_real_)
fail_with(log("a"), NA_real_)
```

### 8.6.2: Success and failure values

`success_val` and `error_val` 

```{r}
foo <- function(expr) {
  tryCatch(
    error = function(cnd) error_val,
    {
      expr
      success_val
    }
  )
}
```


### 8.6.3: Resignal 

Return default values when condition is signalled, handlers used to make more informative error messages.

Ex. warnings into errors

```{r}
warning2error <- function(expr) {
  withCallingHandlers(
    warning = function(cnd) abort(conditionMessage(cnd)),
    expr
  )
}

warning2error({
  x <- 2 ^ 4
  warn("Hello!")
})
```


### 8.6.4: Record

Record conditiosn for later investigation. Modify object in place and not return values.

```{r}
catch_cnds <- function(expr) {
  conds <- list()
  add_cond <- function(cnd) {
    conds <<- append(conds, list(cnd))
    cnd_muffle(cnd)
  }
  withCallingHandlers(
    message = add_cond,
    warning = add_cond,
    expr
  )
  conds
}

catch_cnds({
  inform("a")
  warn("b")
  inform("c")
})
```

Also capture errors: 


```{r}
catch_cnds <- function(expr) {
  conds <- list()
  add_cond <- function(cnd) {
    conds <<- append(conds, list(cnd))
    cnd_muffle(cnd)
  }
  tryCatch(
    error = function(cnd) {
      conds <<- append(conds, list(cnd))
    },
    withCallingHandlers(
      message = add_cond,
      warning = add_cond,
      expr
    )
  )
  conds
}

catch_cnds({
  inform("a")
  warn("b")
  abort("C")
})
```


### 8.6.5: No default behavior

Signal condition that doesn't inherit from `message`, `warning`, or `error`. Condition has no effect unless user specifically request it. 

```{r}
log <- function(message, level = c("info", "error", "fatal")) {
  level <- match.arg(level)
  signal(message, "log", level = level)
}

## no default handler...
log("This code was run") 
```

Activate logging >>> do something for "log" condition.

```{r}
record_log <- function(expr, path = stdout()) {
  withCallingHandlers(
    log = function(cnd) { ## define what to do for `log` condition
      cat(
        "[", cnd$level, "]", cnd$message, "\n", sep = "", 
        file = path, append = TRUE
      )
    },
    expr
  )
}

record_log(log("Hello there!"))
```

Suppress certain log levels:

```{r}
ignore_log_levels <- function(expr, levels) {
  withCallingHandlers(
    log = function(cnd) {
      if (cnd$level %in% levels) {
        cnd_muffle(cnd)
      }
    },
    expr
  )
}

record_log(ignore_log_levels(log("Hello there!"), "info"))
```



### exercise 

Catch errors but suppress error message. 

```{r}
suppressErrors <- function(expr) {
  tryCatch(
    error = function(cnd) invisible(cnd),
    interrupt = function(cnd) stop("Terminated by the user",
                                   call. = FALSE),
    expr
  )
}

suppressConditions <- function(expr) {
  suppressErrors(suppressWarnings(suppressMessages(expr)))
}

error_obj <- suppressConditions({
    message("message")
    warning("warning")
    abort("error")
  })

error_obj
```

2. 







# II. Functional Programming

First-class functions: functions that behave like any other data structure. Do same things with function as you do with a vector. Assign as variables, store in list, pass as arguments to other functions, create inside functions, return as result of function, etc.

Pure: 
- output ONLY depends on inputs. If called with same inputs always produce the same outputs. Exclude `runif()`, `Sys.time()`, etc.
- Has NO side-effects, no changing value of a global variable, no writing to disk, no display to screen. Exclude `print()`, `<-`, etc.

## Functional style

Decomposing a big problem into smaller pieces. Operate independently. 


# 9 Functionals 

Functional: Function that takes function as input and returns vectors as output. 

```{r}
randomize <- function(f) f(runif(1e3))

randomize(mean)
randomize(mean)
randomize(mean)
randomize(sum)
```

Replace `for` with functionals. 

## 9.2 `map()`

`purrr::map()`: takes vector and function >>> calls function once for each element of the vector and returns results in list. 

`map(1:3, f)` == `list(f(1), f(2), f(3))`

```{r}
triple <- function(x) x * 3
map(1:3, triple)
```

- Allocate a list the same length as input, then fill in the list with a `for` loop. 

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

`map()` written in C, preserves names, supports shortcuts.

Base R: `lapply()`. 

### 9.2.1: Producing atomic vectors 

Simpler variants of `map()` to return atomic vector of different types: `map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`. 

All map functions always return an output vector the same length as the input >>> implies each call to `.f` must return a single value. If not >>> ERROR.

Base R: `sapply()` and `vapply()`. Avoid `sapply()` as simplify result into list, vector, or matrix. `vapply()` use `FUN.VALUE` to describe output shape.

```{r}
x <- c(25, 40, 585, 48, 202, 2)

map_dbl(x, mean, na.rm = TRUE)

vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))
```


### 9.2.2: Anonymous functions & shortcuts 

Use inline anonymous functions instead of existing functions. 

```{r}
map_dbl(mtcars, function(x) length(unique(x)))
```

Shortcut `~`

```{r}
map_dbl(mtcars, ~ length(unique(x)))
```

Shortcuts for extracting elements from a vector >>> `purrr::pluck()`. Use character vector to select elements by name, integer vector to select by position, list to select by both name and position. Useful for nested lists >> JSON.

```{r}
x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

map_dbl(x, "x")
map_dbl(x, 1)
map_dbl(x, list("y", 2), .default = NA)
```

### 9.2.3: Passing arguments with `...`

Pass additional arguments.

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
map_dbl(x, mean, na.rm = TRUE)
```

Any arguments after `.f` the function are inserted after the data in individual calls to `f()`

### 9.2.4: Argument names

Write out full argument names in code for better understanding. Be careful of `f` and `x` arguments as they can clash, `purrr()` uses `.f` and `.x` to avoid such mishaps.

### 9.2.5: Varying another argument

First argument of `map()` >>> first argument of function. BUT what if want first argument to be a constant and vary a different argument?

Use anonymous function to rearrange the argument order:

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

map_dbl(trims, ~ mean(x, trim = .x))
map_dbl(trims, function(trim) mean(x, trim = trim))
```

### exercise 

1. `as_mapper()`

map() offers multiple ways (functions, formulas and extractor functions) to specify the function argument (.f). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of as_mapper() and it is called every time map() is used.

Given character, numeric or list input as_mapper() will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.

The extractor function is implemented as a call to purrr::pluck(), which accepts a list of accessors (accessors “access” some part of your data object).


2. `map(1:3, ~ runif(2))` vs. `map(1:3, runif(2))`

The first pattern creates multiple random numbers, because ~ runif(2) successfully uses the formula interface. Internally map() applies as_mapper() to this formula, which converts ~ runif(2) into an anonymous function. Afterwards runif(2) is applied three times (one time during each iteration), leading to three different pairs of random numbers.

```{r}
map(1:3, ~ runif(2))
```


In the second pattern runif(2) is evaluated once, then the results are passed to map(). Consequently as_mapper() creates an extractor function based on the return values from runif(2) (via pluck()). This leads to three NULLs (pluck()’s .default return), because no values corresponding to the index can be found.

```{r}
map(1:3, runif(2))
```

3. 

```{r}
map_dbl(mtcars, ~ sd(.))

mtcars_num <- map_lgl(mtcars, is.numeric)
map_dbl(mtcars[mtcars_num], sd)

mtcars_factor <- map_lgl(mtcars, is.factor)
map_int(mtcars[mtcars_factor], ~ length(levels(.x)))
```

4. 

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))

library(ggplot2)

trials_df <- tibble(p_value = map_dbl(trials, "p.value"))

trials_df %>% 
  ggplot(aes(x = p_value, fill = p_value < 0.05)) + 
  geom_histogram(binwidth = .01) +
  ggtitle("Distribution of p-values for random poisson data.")
```


5. 


6.

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

models <- map(formulas, lm, data = mtcars)
```

7. 

```{r}
bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- map(1:10, ~ bootstrap(mtcars))

bootstraps %>% 
  map(~ lm(mpg ~ disp, data = .x)) %>% 
  map(summary) %>% 
  map_dbl("r.squared")
```


## 9.3 Purrr style

Example problem: fit model to each subgroup and extract coefficient for model. 

Split by # of cylinders:

```{r}
by_cyl <- split(mtcars, mtcars$cyl)
```

List of 3 dfs >> 4, 6, 8 cylinders

Extract slope from each model:

```{r}
by_cyl %>% 
  map(~ lm(mpg ~ wt, data = .x)) %>% 
  map(coef) %>% 
  map_dbl(2)
```


Base R: 

```{r}
models <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))

vapply(models, function(x) coef(x)[[2]], double(1))

## for loop:
intercepts <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  intercepts[[i]] <- coef(model)[[2]]
}

intercepts
```

## 9.4 Map variants

### 9.4.1: `modify()`: same type of output as input

Ex. double every column in a df.

`map()` returns list >>> use `modify()` to keep output as df.

```{r}
df <- data.frame(x = 1:3, y = 6:4)
modify(df, ~ .x * 2)
```


### 9.4.2: Two inputs 

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

`map()` not pass additional arguments as anything after `.f` are not transformed. Need variant that vectorizes over two arguments >>> `.x` and `.y`

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

arguemtns go before function `.f`, all additional arguments go after `.f`. 





### 9.4.3: No outputs

Most functions called for value returned. Some functions only called for SIDE-EFFECTS so not need returned results. Ex. `cat()`, `write.csv()`, `ggsave()`. 

```{r}
welcome <- function(x) {
  cat("Welcome ", x, "!\n", sep = "")
}

names <- c("Hadley", "Jenny")

map(names, welcome)

walk(names, welcome)
```

`walk2()`: useful for saving to disk. >>> object and path name

```{r}
temp <- tempfile() 
di.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)
dir(temp)
```

Base R: wrap result of `lapply()` in `invisible()` or save in unused variable.


### 9.4.4: Iterating over values and indices

`for` loop:
- loop over elements: `for (x in xs)` >>> `map()`
- loop over the numeric indices: `for (i in seq_along(xs))` >>> `imap()`
- loop over the names: `for (nm in names(xs))` >>> `imap()`

`imap(x, f)` == `map2(x, names(x), f)` if x has names OR `map2(x, seq_along(x), f)`.

```{r}
imap_chr(iris, ~ paste0("The first value of ", .y, " is ", .x[[1]]))
```

IF vector is unnamed, 2nd argument == index.

```{r}
x <- map(1:6, ~ sample(1000, 10))
imap_chr(x, ~ paste0("The highest value of ", .y, " is ", max(.x)))
```

### 9.4.5 Any number of inputs


`pmap()`: supply with single list of any number of arguments. 

- `pmap(list(x, y), f)` == `map2(x, y, f)`

Allow more control over argument matching as can name the components of the list.

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

pmap_dbl(list(trim = trims), mean, x = x)
```

- Easy to call `pmap()` with data frame >>> `tibble::tribble()`

```{r}
params <- tibble::tribble(
  ~ n, ~ min, ~ max,
  1L,      0,     1,
  2L,     10,   100,
  3L,    100,  1000
)

pmap(params, runif)
```

Base R: 

use `Map()` and `mapply()`


### exercise 

1. 


```{r}
mtcars
modify(mtcars, 2)
```

Extracts the 'x' index by position but keeps the output the same as the input. In this case it grabs the data from the 2nd row but keeps it in the same df format which means that the 2nd row data is recycled to all the other rows.


2. 

```{r}
temp <- tempfile()
dir.create(temp)
cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)


imap(cyls, write.csv)
```

Shows output returns



3. 

```{r}
mtcars
trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) factor(x, labels = c("auto", "manual"))
)

nm <- names(trans)
mtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))
```

apply each of the functions in `trans` to the columns `nm` from mtcars 

4.

map() and write.csv() returns NULL of length input vector while walk2() returns invisibly




## 9.5 reduce

`reduce()`: takes vector lenght == n and produces vector of length == 1 by calling a function with a pair of values at a time.

Generalize function that works with two inputs >>> work with any # of inputs.

Ex. for list of numeric vectors, find values intersect in every element.


```{r}
l <- map(1:4, ~ sample(1:10, 15, replace = TRUE))
str(l)

## no need to repeatedly call `intersect()`
reduce(l, intersect)
reduce(l, union)
```

Can pass additional arguments. 

```{r}
simple_reduce <- function(x, f) {
  out <- x[[1]]
  for (i in seq(2, length(x))) {
    out <- f(out, x[[i]])
  }
  out
}
```


Base R: `Reduce()` >>> no supplying of additional arguments


### 9.5.2: Accumulate

`accumulate()`: returns all intermediate results 

```{r}
accumulate(l, intersect)
```

Similar to cumulative sum:

```{r}
x <- c(4, 3, 10)
reduce(x, `+`)
accumulate(x, `+`)
```

### 9.5.3: Output types

When length == 1 or 0, without additional arguments, `reduce()` simply returns input when x == 1.

```{r}
reduce(1, `+`)
```

No way to check validity of inputs.

```{r}
reduce("a", `+`)
```

x == 0

```{r}
reduce(integer(), `+`)
```

supply `.init` 

```{r}
reduce(integer(), `+`, .init = 0)
reduce("a", `+`, .init = 0)
```

0: identity of real numbers under the operation of addition. 0 + X == X


### 9.5.4: Multiple inputs

`reduce2()`: length of 2nd argument varies depending on `.init` supplied. If 4 elements of 'x', then 'f' will be called 3 times but if `init` then 4 times. 

### 9.5.5: Map-reduce

Hadoop

Each map on individual data >>> results sent back to coordinating power which reduces each result into single overall result.


## 9.6 Predicate functionals 

Predicate: Returns single TRUE / FALSE >>> `is.character()`, `is.null()`, `all()`, etc. Predicate MATCHES a vector if it returns TRUE.

### 9.6.1: Basics

Predicate functional: applies predicate to EACH element of a vector.

* `some(.x, .p)`: return TRUE if ANY element matches. Terminates at first TRUE.
* `every(.x, .p)`: returns TRUE if ALL element matches. Terminates at first FALSE.

* `detect(.x, .p)`: returns value of the first match. 
* `detect_index(.x, .p)`: returns location of the first match.

* `keep(.x, .p)`: keeps ALL matching elements
* `discard(.x, .p)`: drops ALL matching elements

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))

detect(df, is.factor)
detect_index(df, is.factor)

str(keep(df, is.factor))
str(discard(df, is.factor))
```

### 9.6.2: Map variants 

`*_if()` predicate functions

```{r}
df <- data.frame(
  num1 = c(0, 10, 20),
  num2 = c(5, 6, 7),
  chr1 = c("a", "b", "c"),
  stringsAsFactors = FALSE
)

str(map_if(df, is.numeric, mean))
str(modify_if(df, is.numeric, mean))
str(map(keep(df, is.numeric), mean))
```

### exercise

1. 

`is.na()` returns logical vector of the SAME LENGTH as argument 'x'.

`anyNA(recursive = TRUE)` is predicate version 

2. 

use `seq_along()` instead of `seq()`

3. 


4. 

```{r}
arg_max <- function(x, f){
  y <- map_dbl(x, f)
  x[y == max(y)]
}

arg_min <- function(x, f){
  y <- map_dbl(x, f)
  x[y == min(y)]
}

arg_max(x = -10:5, f = function(x) x ^ 2)
arg_min(x = -10:5, f = function(x) x ^ 2)
```

5. 

```{r}
modify_if(mtcars, is.numeric, scales01)
```



## 9.7 Base functionals

Base functionals with no equivalent in {purrr}.

### 9.7.1: Matrices and arrays

`base::apply()`: used with 2D and higher vectors >> matrices + arrays. Summarize matrix or array by collapsing each row/column to a single value.

Arguments: 
* 'X': matrix or array to summarize
* 'MARGIN': integer vector giving dimensiosn to summarize over. 1 = rows, 2 = cols, etc.  
* 'FUN': summary function
* '...': other arguments to 'FUN'


```{r}
a2d <- matrix(1:20, nrow = 5)
a2d
apply(a2d, 1, mean) # row
apply(a2d, 2, mean) # column
```

Specify multiple dimensions in 'MARGIN' 

```{r}
a3d <- array(1:24, c(2, 3, 4))
apply(a3d, 1, mean)
apply(a3d, c(1, 2), mean)
```

`apply()` caveats:
* no control over output type >>> automatically simplified to list/matrix/vector. 
* Not idempotent >>> if summary function is identity operator >> output NOT always same as input

```{r}
a1 <- apply(a2d, 1, identity)
identical(a2d, a1)

a2 <- apply(a2d, 2, identity)
identical(a2d, a2)
```

NEVER use `apply()` with a data frame >>> coerce to matrix == undesireable results if any NOT numeric vector. 


### 9.7.2: Mathematical concerns

`integrate()`: finds area under curve defined by `f()`
`uniroot()`: finds where `f()` hits zero
`optimise()`: finds location of lowest/highest value of `f()`

### exercise 

1. 

`apply()` applies function over the margins of an array >>> 2D: margins are rows & cols.

```{r}
arr2 <- array(1:12, dim = c(3, 4))
rownames(arr2) <- paste0("row", 1:3)
colnames(arr2) <- paste0("col", 1:4)
arr2
```

Transposed over rows

```{r}
apply(arr2, 1, function(x) x[1:2])
apply(arr2, 2, function(x) x[1:2])
```

The output of apply() is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.


2. 


eapply() is a variant of lapply(), which iterates over the (named) elements of an environment. In purrr there is no equivalent for eapply() as purrr mainly provides functions that operate on vectors and functions, but not on environments.

rapply() applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default classes = ANY). One may also specify how elements of other classes should remain: i.e. as their identity (how = replace) or another value (deflt = NULL). The closest equivalent in purrr is modify_depth(), which allows you to modify elements at a specified depth in a nested list.





# 10 Function factories

Function factory: function that makes functions.

```{r}
power1 <- function(exp) {
  function(x) {
    x ^ exp
  }
}

square <- power1(2)
cube <- power1(3)

## manufactured functions
square(3)
cube(3)
```


## 10.2 Factory fundamentals

THe enclosing environment of the manufactured function is an execution environment of the function factory.


### 10.2.1: Environments


```{r}
square

cube
```

'x' is from argument. 'exp'? 

Each of `square()` and `cube()` have two different environments for 'exp' with the same parent, the enclosing environment of `power1()` - the global environment.

```{r}
env_print(square)
env_print(cube)

fn_env(square)$exp
fn_env(cube)$exp
```

Names in enclosing environment are BOUND to different values (square == 2, cube == 3). 
For `square(10)`: For executing `x & exp` it finds 'x' in execution environment and 'exp' in the enclosing environment (so it finds 2 instead of any other value bound by other functions created by the factory).

### 10.2.3: Forcing evaluation

Bug in `power1()` due to lazy evaluation. 

```{r}
x <- 2 
square <- power1(x)
x <- 3

square(2) # == 8! when it should be 4!
```


'x' is only evaluated lazily when `square()` is run, NOT when `power1()` is run.

Happen when binding changes in between calling factory function and calling the manufactured function. Fix by "forcing" evaluation with `force()`:

```{r}
power2 <- function(exp) {
  force(exp)
  function(x) {
    x ^ exp
  }
}

x <- 2 
square <- power2(x)
x <- 3

square(2)
```

When creating function factory, make sure EVERY argument is evaluated using `force()` if necessary if argument ONLY used by manufactured function.


### 10.2.4: Stateful functions 

Maintain state across function invocations, generally unable due to fresh start principle. 

- Enclosing environment of manufactured function is UNIQUE and CONSTANT.
- R has special assignment operator `<<-` which modifies bindings in the enclosing environment. 

`<-`: always creates binding in the current environment

`<<-`: rebinds an existing name found in the parent environment 


```{r}
new_counter <- function() {
  i <- 0
  
  function() {
    i <<- i + 1
    i
  }
}

counter_one <- new_counter()
counter_two <- new_counter()

counter_one()
counter_one()

counter_two()
```

When manufactured function is run `i <<- i + 1` will modify 'i' in its enclosing environment. As manufactured functions have independent enclosing environments >>> they have independent counts. If function is managing state of multiple variables, use R6 instead...


### 10.2.5: Garbage collection

Manufactured functions hold on to the execution environment >>> so necessary to explicitly unbind any large temporary objects with `rm()`.

```{r}
f1 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  function() m
}

g1 <- f1(1e6)
lobstr::obj_size(g1)

f2 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  rm(x)
  function() m
}

g2 <- f2(1e6)
lobstr::obj_size(g2)
```

### exercise 

1. `force()`

using this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed x.


2. 


3. 

```{r}
pick <- function(i) {
  force(i)
  
  function(x) x[[i]]
}

x <- 1:3
identical(x[[1]], pick(1)(x))

identical(lapply(mtcars, function(x) x[[5]]),
          lapply(mtcars, pick(5)))
```


4. 

```{r}
moment <- function(i){
  force(i)
  
  function(x) sum((x - mean(x)) ^ i) / length(x)
}

m1 <- moment(1)
m2 <- moment(2)

x <- runif(100)
all.equal(m1(x), 0)  # removed stopifnot() for clarity
#> [1] TRUE
all.equal(m2(x), var(x) * 99 / 100)
#> [1] TRUE
```



5. no closure?

```{r}
i <- 0
new_counter2 <- function() {
  i <<- i + 1
  i
}

new_counter2()

i

new_counter2()

i

i <- 0
new_counter2()
```

Counts will be stored in global environments which can then be overwritten or deleted to interfere with other counters being executed. 

6. use <- instead of <<-

Always return same value due to fresh start principle (always start new execution environment within same enclosing environment - containing unchanged value for '_')


## 10.3 Graphical factories

### 10.3.1: Labelling 

{scales}: customize labels in {ggplot2}. Formatter functions all return a function. Primary interface is a function factory. 

```{r}
y <- c(12345, 123466, 123584)
comma_format()(y)

number_format(scale = 1e-3, suffix = "k")(y)
```

```{r}
df <- data.frame(x = 1, y = y)
core <- ggplot(df, aes(x, y)) +
  geom_point() + 
  scale_x_continuous(breaks = 1, labels = NULL) +
  labs(x = NULL, y = NULL)

core 
core + scale_y_continuous(labels = comma_format())
core + scale_y_continuous(labels = number_format(scale = 1e-3, suffix = "k"))
core + scale_y_continuous(labels = scientific_format())
```


### 10.3.2: Histogram bins

'binwidth' argument can be a function. Function is executed once for EACh group, so can have different bindwidths in different facets. 

```{r}
sd <- c(1, 5, 15)
n <- 100

df <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = 2) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```

Each facet has same 'n' but different variance. Create with function factory that take input of desired # of bins, and outputs function that takes numeric vector to return binwidth. 


```{r}
binwidth_bins <- function(n) {
  force(n)
  
  function(x) {
    (max(x) - min(x)) / n
  }
}

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = binwidth_bins(20)) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```


```{r}
base_bins <- function(type) {
  fun <- switch(type,
    Sturges = nclass.Sturges,
    scott = nclass.scott,
    FD = nclass.FD,
    stop("Unknown type", call. = FALSE)
  )
  
  function(x) {
    (max(x) - min(x)) / fun(x)
  }
}

ggplot(df, aes(x)) + 
  geom_histogram(binwidth = base_bins("FD")) + 
  facet_wrap(~ sd, scales = "free_x") + 
  labs(x = NULL)
```


### 10.3.3: `ggsave()`

`ggplot2:::plot_dev()` used by `ggsave()` to go from file extension to graphics device function. Base graphics devices have minor inconsistencies.

- `filename` vs. `file`
- `width` and `height` pixels in raster graphics but inches in vector graphics



## 10.4 Statistical factories 



## 10.5 Function factories and functionals


Create specially named power functions by iterating over a list of arguments.

```{r}
names <- list(
  square = 2, 
  cube = 3, 
  root = 1/2, 
  cuberoot = 1/3, 
  reciprocal = -1
)
funs <- purrr::map(names, power1)

funs$root(64)
#> [1] 8
funs$root
```

Annoying to have to prefix every function call with `fun$`

```{r}
with(funs, root(100))
```

`with(mtcars, mpg[cyl == 8  &  disp > 350])`
    # is the same as, but nicer than
`mtcars$mpg[mtcars$cyl == 8  &  mtcars$disp > 350]`

OR `attach()` functions to the search path and `detach()` when done

```{r}
attach(funs)
root(100)
detach(funs)
```

OR copy functions to global environment with `env_bind()`

```{r}
rlang::env_bind(global_env(), !!!funs)
root(100)
rlang::env_unbind(global_env(), names(funs))
```


### exercise

1.

```{r}
f <- mean
z <- 1
x <- list(f = mean, z = 1)

identical(with(x, f(z)), x$f(x$z))
#> [1] TRUE
identical(with(x, f(z)), f(x$z))
#> [1] TRUE
identical(with(x, f(z)), x$f(z))
#> [1] TRUE
identical(with(x, f(z)), f(z))
```


2. `env_bind()` vs. `attach()`

`attach()` adds 'funs' to the search path. Therefore, the provided functions are found before their respective versions from the base package. Further, they can not get accidentally overwritten by similar named functions in the global environment. One annoying downside of using `attach()` is the possibility to attach the same object multiple times, making it necessary to call `detach()` equally often.

In contrast `rlang::env_bind()` just adds the functions in 'fun' to the global environment. No further side effects are introduced and the functions are overwritten when similarly named functions are defined.



# 11 Function operators

Function operator: function that takes functions as input and returns function as output.

```{r}
chatty <- function(f) {
  force(f)
  
  function(x, ...) {
    res <- f(x, ...)
    cat("Processing ", x, "\n", sep = "")
    res
  }
}
f <- function(x) x ^ 2
s <- c(3, 2, 1)

purrr::map_dbl(s, chatty(f))
```

## 11.2 Existing function operators

### 11.2.1: Capturing errors with `purrr::safely()`

`for` loop: If one iteration fails, can still acceess results up to the failure. 

```{r}
x <- list(
  c(0.512, 0.165, 0.717),
  c(0.064, 0.781, 0.427),
  c(0.890, 0.785, 0.495),
  "oops"
)

out <- rep(NA_real_, length(x))
for (i in seq_along(x)) {
  out[[i]] <- sum(x[[i]])
}

out
```

Functionals: no output so difficulty assessing where problem is.

```{r}
map_dbl(x, sum)
```

Use `purrr::safely()` to transforms function to turn errors into data. 

```{r}
safe_sum <- safely(sum)
safe_sum

str(safe_sum(x[[1]]))
str(safe_sum(x[[4]]))
```

Returns: 'result' and 'error'. NULL if none.

```{r}
out <- map(x, safely(sum))
str(out)
```

Now have four list each with 'result' and 'error'. Unwieldy so use `purrr::transpose()` to get a list of 'result' and list of 'error'.

```{r}
out <- transpose(map(x, safely(sum)))
str(out)
```

Find results that worked and which failed.

```{r}
ok <- map_lgl(out$error, is.null)
ok

x[!ok]
out$result[ok]
```

```{r}
fit_model <- function(df) {
  glm(y ~ x1 + x2 * x3, data = df)
}

models <- transpose(map(datasets, safely(fit_model)))
ok <- map_lgl(models$error, is.null)

# which data failed to converge?
datasets[!ok]

# which models were successful?
models[ok]
```


- `possibly()`: return default value when error. 
- `quietly()`: turns output, messages, warning side-effects into 'output', 'message', 'warning' components of output
- `auto_browser()`: automatically executes `browser()` inside function if error.

### 11.2.2: Caching computations with `memoise::memoise()`

Function to memorize previous inputs and return cached results. Memoised function can run faster but uses more memory as store previous inputs + outputs.

```{r}
slow_function <- function(x) {
  Sys.sleep(1)
  x * 10 * runif(1)
}
system.time(print(slow_function(1)))

system.time(print(slow_function(1)))
```

Slow for new arguments but for previously seen arguments == very fast as retrieves previous value from that computation.

```{r}
fast_function <- memoise::memoise(slow_function)
system.time(print(fast_function(1)))

system.time(print(fast_function(1)))
```

Fibonacci series: recursive

```{r}
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
system.time(fib(24))
```

Memoise: each value is only computed once == faster

```{r}
fib2 <- memoise::memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
system.time(fib2(24))
```

Dynamic programming: Complex problem can be broken down into many overlapping sub-problems, remembering results of sub-problem can improve performance.

IF function NOT pure (output not only depend on input) then will get misleading results. 

### exercise 

1. 

In R a lot of functions are “vectorised”. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors, and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.

However, despite what the function’s name implies, Vectorize() is not able to speed up the provided function. It rather changes the input format of the supplied arguments (vectorize.args), so that they can be iterated over.

In essence, Vectorize() is mostly a wrapper for mapply(). Vectorize() provides a convenient and concise notation to iterate over multiple arguments, but has some major drawbacks that mean you generally shouldn’t use it.

2.

possibly() modifies functions to return a specified default value in case of an error (otherwise) and to suppress any error messages (quiet = TRUE).

While reading the source code, we notice that possibly() internally uses purrr::as_mapper(). This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the purrr package. Besides this, the new default value (otherwise) gets evaluated once to make it (almost) immutable.

The main functionality of possibly() is provided by base::tryCatch(). In this part the supplied function (.f) gets wrapped and the error and interrupt handling are specified.




3. 

safely() modifies functions to return a list, containing the elements “result” and “error”. It works in a similar fashion as possibly() and besides using as_mapper(), safely() also provides the otherwise and quiet argument. However, in order to provide the result and the error in a consistent way, the tryCatch() part of the implementation returns a list with the same structure in both cases. In the case of successful evaluation “error” equals to NULL and in case of an error “result” equals to otherwise, which is NULL by default.


## 11.3 Case study: Creating your own function operators

Imagine you have a named vector of URLs and you’d like to download each one to disk.

```{r}
urls <- c(
  "adv-r" = "https://adv-r.hadley.nz", 
  "r4ds" = "http://r4ds.had.co.nz/"
  # and many many more
)
path <- paste(tempdir(), names(urls), ".html")

walk2(urls, path, download.file, quiet = TRUE)
```

* Add a small delay between each request to avoid hammering the server.
* Display a . every few URLs so that we know that the function is still working.

In `for` loop:

```{r}
for(i in seq_along(urls)) {
  Sys.sleep(0.1)
  if (i %% 10 == 0) cat(".")
  download.file(urls[[i]], paths[[i]])
}
```

ALl in one >>> extract out each process to make them reusable.

```{r}
delay_by <- function(f, amount) {
  force(f)
  force(amount)
  
  function(...) {
    Sys.sleep(amount)
    f(...)
  }
}
system.time(runif(100))
system.time(delay_by(runif, 0.1)(100))

walk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)
```


Can not rely on index from loop. Can't pass index as argument as breaks encapsulation (concern of progress function is handled by a higher level wrapper). Progress wrapper manage own internal counter. 

```{r}
dot_every <- function(f, n) {
  force(f)
  force(n)
  
  i <- 0
  function(...) {
    i <<- i + 1
    if (i %% n == 0) cat(".")
    f(...)
  }
}
walk(1:100, runif)
walk(1:100, dot_every(runif, 10))
```

Combine:

```{r}
walk2(
  urls, path, 
  dot_every(delay_by(download.file, 0.1), 10), 
  quiet = TRUE
)

## use pipe for legibility:
walk2(
  urls, path, 
  download.file %>% dot_every(10) %>% delay_by(0.1), 
  quiet = TRUE
)
```

### exercise

1. 

Both commands will print a dot every 10 downloads and will take the same amout of time to run, so the differences may seem quite subtle.

In the first case, first the dot functionality is added to download.file. Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed and the first dot will be printed as soon as the download for the 10th url starts.

In the latter case. The delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, the the short delay occurs before the 10th download actually starts.

2.

No. Size of files might be very large to keep in memory.

This implies that it’s probably not beneficial to memoise file.download() in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.

3. 

```{r}
dir_compare <- function(old, new) {
  if (setequal(old, new)) {
    return()
  }
  
  added <- setdiff(new, old)
  removed <- setdiff(old, new)
  
  changes <- c(
    if (length(added) > 0) paste0(" * '", added, "' was added"),
    if (length(removed) > 0) paste0(" * '", removed ,
                                    "' was removed")
  )
  message(paste(changes, collapse = "\n"))
}

dir_compare(c("x", "y"), c("x", "y"))
#> NULL
dir_compare(c("x", "y"), c("x", "a"))
```

Wrap in function operator: 

```{r}
track_dir <- function(f) {
  force(f)
  function(...) {
    dir_old <- dir()
    on.exit(dir_compare(dir_old, dir()), add = TRUE)
    
    f(...)
  }
}

file_create <- track_dir(file.create)
file_remove <- track_dir(file.remove)

file_create("delete_me")
file_remove("delete_me")
```


To create a more serious version of track_dir() one might provide optionality to set the full.names and recursive arguments of dir() to TRUE. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.

Other global effects that might be worth tracking include changes regarding:

- the search path and possibly introduced conflicts()
- options() and par() which modify global settings
- the path of the working directory
- environment variables


4.

```{r}
append_line <- function(path, ...) { 
  cat(..., "\n", sep = "", file = path, append = TRUE)
}

logger <- function(f, log_path) {
  force(f)
  force(log_path)
  
  append_line(log_path, "created at: ", as.character(Sys.time()))
  function(...) {
    append_line(log_path, "called at: ", as.character(Sys.time()))
    f(...)
  }
}

log_path <- tempfile()
mean2 <- logger(mean, log_path)
Sys.sleep(5)
mean2(1:4) 
#> [1] 2.5
Sys.sleep(1)
mean2(1:4)
#> [1] 2.5

readLines(log_path)
```


5. 

```{r}
delay_atleast <- function(amount, f) {
  force(f)
  force(amount)
  
  # Store the last time the function was run
  last_time <- NULL
  
  # Return modified 'delay-aware' function
  function(...) {
    if (!is.null(last_time)) {
      wait <- (last_time - Sys.time()) + amount
      if (wait > 0) {
        Sys.sleep(wait)
      }
    }
    
    # Update the time after the function has finished
    on.exit(last_time <<- Sys.time()) 
    
    f(...)
  }
}
```





# III. Object-Oriented Programming

## OOP: 
- polymorphism: developer can consider a function's interface as separate from implementation. So use same function form for different types of input. Similar to encapsulation - usser doesn't need to worry about details of object as they are encapsulated behind a standard interface.

```{r}
## `summary()` output for numeric and factor variables 
summary(diamonds$carat)
summary(diamonds$cut)
```

## OOP Systems

Class: type of object "what is", organized in hierarchy so if method not exist for one class, parent method is used, child "inherits" behavior. 
-- Ex. ordered factor inherits from regular factor. GLM inherits from linear model
Method: implementation for a specific class "what do"
- Method dispatch: finding correct method given a class
Fields: defined by class, the data possessed by every instance of that class

### OOP paradigms

- Encapsulated: methods belong to objects/classes, object encapsulates both data (fields) and behavior (methods)
-- Method call ex.: `object.method(arg1, arg2)`

- Functional: methods belong to generic functions, looks similar to regular function call, internal components are also functions
-- Method call ex.: `generic(object, arg2, arg3)`

## OOP in R

- S3
-- informal implementation of functional OOP, rely on common conventions > ironclad guarantees

- S4
-- formal rewrite of S3. More guarantees + greater encapsulation. S4 implemented in base {methods} package.

- RC
-- Encapsulated OOP. Special type of S4 objects that are mutable - can be modified in place. 

- R6
-- Encapsulated OOP. Resolves issues in RC

- R.oo
-- Formalism on S3, mutable S3 objects.

- proto
-- Prototype based OOP. Used in {ggplot2}

```{r}
library(sloop)

otype(1:10)
otype(mtcars)

mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)
otype(mle_obj)
```



# 12 Base types

Object: Not ALL objects are object-oriented. 
-- Base objects vs. OO objects

## 12.2 Base vs. OO objects

Use `is.object()` or `sloop::otype()`

```{r}
is.object(1:10)
sloop::otype(1:10)

is.object(mtcars)
sloop::otype(mtcars )
```

OO objects have a "class" attribute:
```{r}
attr(1:10, "class")
attr(mtcars, "class")
```

Use `class()` for S3 and S4 objects but can be misleading if used on base objects. Use `sloop::s3_class()` instead.

```{r}
x <- matrix(1:4, nrow = 2)
class(x)
sloop::s3_class(x)
```

## 12.3 Base types

ALL objects have a 'base type':
```{r}
typeof(1:10)
typeof(mtcars)
```

Base types do not form OOP system as functions that behave differently for different base types are using C code >>> uses 'switch' statements. Only R-Core can create new types >>> difficulty due to all work needed to add switch statements to code. 

```{r}
typeof(NULL)

typeof(1L)

typeof(1i)

typeof(mean)

typeof(`[`)

typeof(sum) 

typeof(globalenv())

mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)
typeof(mle_obj)

typeof(quote(a))

typeof(quote(a + 1))

typeof(formals(mean))
```

### 12.3.1: Numeric type

"Numeric" can mean:

1. Alias for "double" type. `as.numeric()` == `as.double()` // `numeric()` == `double()`

2. S3 + S4: numeric is shorthand for 'integer' or 'double' type for picking methods.

```{r}
sloop::s3_class(1)
sloop::s3_class(1L)
```

3. `is.numeric()` tests for objects that BEHAVE like numbers. Factors have type 'integer' but do NOT behavior as numbers.

```{r}
typeof(factor("x"))
is.numeric(factor("x"))
```

# 13 S3

Simplest OO system. Only OO system used by {base} and {stats} + most commonly used on CRAN packages.

Very flexible, few constraints >>> necessity to apply constraints yourself.

## 13.2: Basics

S3 object: base type with at least a 'class' attribute. 

Factor: base type == 'integer' vector, 'class' attribute of "factor", 'levels' attribute stores all possible levels.

```{r}
f <- factor(c("a", "b", "c"))
typeof(f)
attributes(f)

## strip 'class' attribute, lose special behavior
unclass(f)
```

S3 object behave differently from underlying base type if passed to a 'generic' function.

`sloop::ftype()`: to find 'generic' functions

```{r}
ftype(print)
ftype(str)
ftype(unclass)
```

'Generic' function: defines an interface - uses different implementation depending on the 'class' or argument. 

```{r}
print(f) # print as factor

print(unclass(f)) # strip 'f' of factor class >> behave as integer
```

`str()` is 'generic': Some S3 classes use it to hide internal details. Ex. 'POSIXlt' class. 


'generic': Defines the interface and find right implementation for it. 
'method': Implementation for a specific class.
'method dispatch': How 'generic' finds method

```{r}
s3_dispatch(print(f))
```

No need to call method directly >> let the 'generic' do it for you. 

Check if method by `sloop::ftype()`.

Can NOT see source codes for most S3 methods as they are not usually exported - only live inside package and not available in global env. 

Check using `sloop::s3_get_method()`:

```{r}
weighted.mean.Date

s3_get_method(weighted.mean.Date)
```

### exercise 

1. `t.test()` vs. `t.data.frame()`

```{r}
ftype(t.test)
ftype(t.data.frame)
```

`t.test()`: generic function
`t.data.frame()`: method that gets called by `t()` to transpose data.frame input.

2. 

```{r}
install.packages()
read.csv()

list.files()
download.file()

data.frame()
as.character()
Sys.Date()

all.equal()

do.call()
on.exit()
```


3. 

`as.data.frame.data.frame()` calls method dispatch for the `as.data.frame()` function for the input data.frame. 

Define names better!!

4. when unclass the mean is taken of the 'some_days' which when losing it's "Date" class now behaves as an double.

5. 

```{r}
x <- ecdf(rpois(100, 10))
ftype(x)
typeof(x)
s3_class(x)
attributes(x)
```

6. 

```{r}
x <- table(rpois(100, 5))
typeof(x)
attributes(x)
```

## 13.3: Classes

S3: Has no formal definition of class. Only need to set the 'class' attribute.

Creation with `structure()` or post-creation with `class<-()`

```{r}
x <- structure(list(), class = "my_class")

x <- list()
class(x) <- "my_class"

class(x)
inherits(x, "my_class")
inherits(x, "your_class")
```

'class' name can be ANY string. Recommend only LETTERS and `_`. Avoid `.` as can be confused with generic/class separator. For packages, use package name in class name to avoid clashes with classes in other packages. 

Can change class of existing objects:

```{r}
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)

class(mod) <- "Date"
print(mod)
```

Provide 3 basic functions:

- Constructor: low level `new_myclass()` that efficiently creates new objects with the correct structure.
- Validator: `validate_myclass()` which performs more rigourous checks to ensure object has the correct values.
- Helper: `myclass()` to provide other users to create objects of your class

### 13.3.1: Constructors

No formal definition of lcass == no built-in way to ensure all objects of a given class have same structure. Enforce consistent structure with a "constructor".

- Name: `new_myclass()`
- 1 argument for base object, one for each attribute
- Check type of base object and check typoes of each attribute

`Date`: doulbe with single attribute >>> 'class' == "Date

```{r}
new_Date <- function(x = doubl()) {
  stopifnot(is.double(x))
  structure(x, class = "Date")
}

new_Date(c(-1, 0, 1))
```

`difftime`: double but has 'units' attribute

```{r}
new_difftime <- function(x = double(), units = "secs") {
  stopifnot(is.double(x))
  units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))

  structure(x,
    class = "difftime",
    units = units
  )
}

new_difftime(c(1, 10, 3600), "secs")
new_difftime(52, "weeks")
```

Avoid checks in constructor.

### 13.3.2: Validators

More complicated classes require more complciated checks for validity. 

Factors: 

```{r}
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

new_factor(1:5, "a")
new_factor(0:1, "a")
```

Separate validation checks from constructor. 

```{r}
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
```



### 13.3.3: Helpers

Allow users to construct objects from your class.

- Have same name as class
- Finish by calling constructur and validator
- Create carefully crafted error messages for user
- UI and default values + useful conversions

Helper to coerce input to desired type.


```{r}
new_difftime(1:10) ## error as NOT double

difftime <- function(x = double(), units = "secs") {
  x <- as.double(x)
  new_difftime(x, units = units)
}

difftime(1:10)
```


Natural representation of complex object >>> string.

Convenient to specify factors with character vector. Have `factor()` guess from input character vector that the 'levels' are the unique values. Not always correct but good enough default to start. 

```{r}
factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

factor(c("a", "a", "b"))
```


Some complex objects more naturally specified by multiple simple components >>> date-time via supplying individual components. 

```{r}
POSIXct <- function(year = integer(), 
                    month = integer(), 
                    day = integer(), 
                    hour = 0L, 
                    minute = 0L, 
                    sec = 0, 
                    tzone = "") {
  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)
}

POSIXct(2020, 1, 1, tzone = "America/New_York")
```

### exercise 

1. 

Data frames are built on named lists of vectors, where every element is the same length. Their only attribute is “row.names” which must be a character vector the same length as the other elements. We need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.

```{r}
new_data.frame <- function(x, n, row.names = NULL) {
  stopifnot(is.list(x))
  
  # Check all inputs are the same length
  stopifnot(all(lengths(x) == n))
  
  if (is.null(row.names)) {
    # Use special row names helper
    row.names <- .set_row_names(n)
  } else {
    # Otherwise check that they're a character vector with the 
    # correct length
    stopifnot(is.character(row.names), length(row.names) == n)
  }
  
  structure(
    x,
    class = "data.frame",
    row.names = row.names
  )
}

# Test
x <- list(a = 1, b = 2)
new_data.frame(x, n = 1)
#>   a b
#> 1 1 2
new_data.frame(x, n = 1, row.names = "l1")
#>    a b
#> l1 1 2

# Create a data frame with 0 columns and 2 rows    
new_data.frame(list(), n = 2)
```



2.

```{r}
factor2 <- function(x, levels = unique(x)) {
  new_levels <- match(x, levels)
  
  # Error if levels don't include all values
  missing <- unique(setdiff(x, levels))
  if (length(missing) > 0) {
    stop(
      "The following values do not occur in the levels of x: ",
      paste0("'", missing, "'", collapse = ", "), ".", 
      call. = FALSE
    )
  }
  
  validate_factor(new_factor(new_levels, levels))
}

factor2(c("a", "b", "c"), levels = c("a", "b"))
```


3. 

The original implementation allows a more flexible specification of input for x. The input is coerced to character or replaced by character(0) (in case of NULL). It also ensures that the factor levels are unique. This is achieved by setting the levels via base::levels<-, which fails when duplicate values are supplied.

```{r}
factor()
```

4. 


```{r}
new_factor <- function(
  x = integer(),
  levels = character(),
  contrast = NULL
) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  if (!is.null(constrast)) {
    # if supplied should be a numeric matrix
    stopifnot(is.matrix(contrast) && is.numeric(contrast))
  }
  
  structure(
    x,
    levels = levels,
    class = "factor",
    contrast = contrast
  )
}
```

5. 

```{r}
as.roman(567)
```




## 13.4 Generics & Methods

`UseMethod()`: Performs method dispatch which is called by every generic call (except internal >>> C code). 

- 'Name': Name of generic function
- 'Argument': Used for method dispatch

```{r}
mean
```

```{r}
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```


### 13.4.1: Method dispatch

`UseMethod()`: creates a vector of method names and then looks for each potential method in turn. 

```{r}
x <- Sys.Date()
sloop::s3_dispatch(print(x))
```

--> Method being called.
* method being defined but NOT called.

"default" class: special pseudo-class included to make it possible to define a standard fallback IF class-specific method is NOT available.



### 13.4.2: Finding methods

`sloop::s3_methods_generic()` & `sloop::s3_methods_class()`: Find ALL methods for a generic or that associated with a certain class.

```{r}
s3_methods_generic("mean")
s3_methods_class("ordered")
```

### 13.4.3: Creating methods

* Only write method if you own the generic or class. 
* Method must have the same arguments as its generic. Enforced in R CMD check.

IF generic has `...`, method can contain a superset of arguments. Any misspelled arguments will be silently allowed...

### exercise 

1.

```{r}
tools::nonS3methods("stats")
```



2.


3.

4.

5.



## 13.5 Object styles

Record style: use list of equal-length vectors to represent individual components of the object. 
- Ex. `POSIXlt`: list of 11 date-time components (year, month, day, etc.) 
- Recrd style classes override `length()` and subsetting methods to conceal the implementation detail

```{r}
x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))
x
#> [1] "2020-01-01 00:00:01 UTC" "2020-01-01 00:00:02 UTC"
#> [3] "2020-01-01 00:00:03 UTC"

length(x)
#> [1] 3
length(unclass(x))
#> [1] 9

x[[1]] # the first date time
#> [1] "2020-01-01 00:00:01 UTC"
unclass(x)[[1]]
```

Data frames: use lists of equal-length vectors. 2D objects and components are exposed to user. # of observations == number of rows, NOT length. 

```{r}
x <- data.frame(x = 1:100, y = 1:100)
length(x)
#> [1] 2
nrow(x)
```

Scalar: use list to represent a single thing. 
* Ex. `lm` object is list of length 12 but represents a single model!

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
length(mod)
mod
```

* Scalar objects can be built on top of functions, calls, environments. 
* Ex. `stats::ecdf()`, R6, `rlang::quo()`

### exercise

1.

```{r}
## scalar
lm()

## vector
x <- factor(x = c("bo", "ma", "ta"))

## vector
x <- table(mtcars$cyl)
length(x)
length(unclass(x))

# vector 
x <- as.Date("2020-01-01")
length(x); length(unclass(x))

## record
as.POSIXct()

## scalar
ecdf()

## vector
ordered()

## depends on input
I()
```


2. 

```{r}
# Define constructor
new_lm <- function(
  coefficients, residuals, effects, rank, fitted.values, assign,
  qr, df.residual, xlevels, call, terms, model
) {
  
  stopifnot(
    is.double(coefficients), is.double(residuals), 
    is.double(effects), is.integer(rank), is.double(fitted.values),
    is.integer(assign), is.list(qr), is.integer(df.residual),
    is.list(xlevels), is.language(call), is.language(terms),
    is.list(model)
  )
  
  structure(
    list(
      coefficients = coefficients,
      residuals = residuals,
      effects = effects,
      rank = rank, 
      fitted.values = fitted.values,
      assign = assign,
      qr = qr,
      df.residual = df.residual,
      xlevels = xlevels,
      call = call,
      terms = terms, 
      model = model
    ),
    class = "lm"
  )
}
```


## 13.6: Inheritance

Inheritance: Share behavior between S3 classes.

- Classes can be a character vector:
* Ex. `ordered` and `POSIXct` have two components to class

```{r}
class(ordered("x"))
class(Sys.time())
```

- If method not found for class in first element of vector, R looks for method in 2nd, then 3rd, etc.

```{r}
s3_dispatch(print(ordered("x")))
s3_dispatch(print(Sys.time()))
```

- Method can delegate work via `NextMethod()`. `->` sign.

```{r}
s3_dispatch(ordered("x")[1])
s3_dispatch(Sys.time()[1])
```

Subclass: When a class appears before another class. `ordered()`: 'ordered'
Superclass: When class appears after another class. `ordered()`: 'factor'


S3 has no restrictions on relationship between sub/superclass but recommended to enforce principles.

- Base type of subclass should be same as superclass
- Attributes of subclass should be a superset of attributes of superclass.


### 13.6.1: `NextMethod()`

`[`: example with concrete use case, create "secret" class that hides output when printed.

```{r}
new_secret <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "secret")
}

print.secret <- function(x, ...) {
  print(strrep("x", nchar(x)))
  invisible(x)
}

x <- new_secret(c(15, 1, 456))

x
```

Works! But default `[` method does NOT preserve "secret" class.

```{r}
s3_dispatch(x[1])

x[1]
```

Need to create `[.secret` method. Need to do without infinite loop (calling `new_secret()` inside the method implementation...). Need to call underlying `[`

* `unclass()` object: Inefficient as would create a copy of 'x'

```{r}
`[.secret` <- function(x, i) {
  x <- unclass(x)
  new_secret(x[i])
}

x[i]
```

* `NextMethod()`: Delegating to method that would've been called if `[.secret` didn't exist. Tracks list of potential next methods with a special variable, modifying object that's being dispatched upon will have NO impact on which method gets called next. 

```{r}
`[.secret` <- function(x, i) {
  new_secret(NextMethod())
}

x[1]

s3_dispatch(x[1])
```

`=>`: `[.secret` called by `NextMethod()` delegates work to underlying `[` internal method show by `->`




### 13.6.2: Allowing subclassing

When create class need to make decision to allow subclasses. Require changes to constructor and methods.

Add `...` and `class` argument to constructor.

```{r}
new_secret <- function(x, ..., class = character()) {
  stopifnot(is.double(x))
  
  structure(
    x, 
    ...,
    class = c(class, "secret")
  )
}
```

Subclass constructor can call parent class constructor with additional arguments as needed. 

* Create `supersecret` class which also hides # of characters: 

```{r}
new_supersecret <- function(x) {
  new_secret(x, class = "supersecret")
}

print.supersecret <- function(x, ...) {
  print(rep("xxxxx", length(x)))
  invisible(x)
}

x2 <- new_supersecret(c(15, 1, 456))
x2
```

For inheritance: think carefully about methods as you can no longer use the constructor. Method will always return same class regardless of input. 

* Revise `[.secret` method... currently always return `secret()` even when given `supersecret`

```{r}
`[.secret` <- function(x, ...) {
  new_secret(NextMethod())
}

x2[1:3]
```

Need to make sure `[.secret` returns same class as 'x' even using subclass. 
* Use `vctrs::vec_restore()` generic. 
** 2 inputs: object with lost subclass info, template object to use for restoration

```{r}
vec_restore.secret <- function(x, to, ...) new_secret(x)
vec_restore.supersecret <- function(x, to, ...) new_supersecret(x)
```

`to` argument for attributes.


```{r}
`[.secret` <- function(x, ...) {
  vctrs::vec_restore(NextMethod(), x)
}

x2[1:3]
```

### exercises

1.

```{r}
`[.Date`
.Date

oldClass(Sys.Date())
```

It seems similar to class(), but it returns NULL for base types. Together this means that [.Date effectively calls mean() on the underlying numeric data, then resets the class of the result to the input. This ignores the fact that a subclass might have additional attributes.

2.




3.





## 13.7: Dispatch details

### 13.7.1: S3 and base types

S3 generic on a base object (no class attribute).

```{r}
class(matrix(1:5))
```

Dispatch occurs on `implicit class`
- string "array"/"matrix" if object has dimensions
- result of `typeof()` with minor tweaks
- string "numeric" if object is "integer"/"double"

```{r}
s3_class(matrix(1:5))
s3_dispatch(print(matrix(1:5)))
```

`class()` of object does NOT uniquely determine dispatch:

```{r}
x1 <- 1:5
class(x1)
s3_dispatch(mean(x1))

x2 <- structure(x1, class = "integer")
class(x2)
s3_dispatch(mean(x2))
```

### 13.7.2: Internal generics

Base functions (`[`, `sum()`, `cbind()`) are 'internal generics' as don't use `UseMethod()` but use C functions `DispatchGroup()`/`DispatchOrEval()`

```{r}
s3_dispatch(Sys.time()[1])
```

### 13.7.3: Group generics

Use both internal generics AND `NextMethod()`. 

- Math: abs(), sign(), sqrt(), floor(), cos(), sin(), log(), etc.

- Ops: +, -, *, /, ^, %%, %/%, &, |, !, ==, !=, <, <=, >=, and >.

- Summary: all(), any(), sum(), prod(), min(), max(), and range().

- Complex: Arg(), Conj(), Im(), Mod(), Re().

Defining a single group generic for class overrides default behavior of all members of the group. Methods for group generics are looked for only if the methods for the specific generic do not exist:

```{r}
s3_dispatch(sum(Sys.time()))
```

`.Generic`: special variable inside group generic function that provides actual generic function called. 

### 13.7.4: Double dispatch

"Ops" group generics: special type of dispatch due to 2-argument arithmetic & boolean operators (`-`, `&`, etc.). Dispatch on BOTH arguments >>> necessary to preserve commutative property of many of the operators. 

```{r}
date <- as.Date("2017-01-01")
integer <- 1L

date + integer
integer + date
```

Dispatch twice for each input.

- Methods are same, so either one can be used
- Methods are different, R falls back to internal method + warning
- One method == internal, so R calls the other method

Use `vctrs::vec_arith()`


### exercise 


1. 

class() returns "integer" in both cases. But the class of x1 is created implicitly and inherits from the "numeric" class, while the class of x2 is set explicitly and no parent class is assumed.

The output of s3_dispatch() shows us, that various methods are not implemented. Rather an internal dispatch (written in C) is used, which shows [ as an internal generic. We also see, that setting the class explicitly for x2 avoids considering the implicit parent class "numeric" for method dispatch.

2.






3.






# 14 R6

- Encapsulated OOP paradigm: methods belong to objects > generics. `object$method()`

- R6 objects: mutable - modified in place, have references semantics

More similar to OOP in other programming languages. 

## 14.2: Classes and methods

`R6::R6Class()`

- 'classname': improve error messages, use R6 objects with S3 generics. Use UpperCamelCase names.
- 'public': supply list of methods/functions and fields that make up public interface of the object. Use snake_case. Methods can access the methods and fields of current object via `self$`

```{r}
Accumulator <- R6::R6Class("Accumulator", list(
  sum = 0,
  add = function(x = 1) {
    self$sum <- self$sum + x
    invisible(self)
  }
))

Accumulator
```

Construct new object from class with `new()` method. Use `$` to access `new()` as methods belong to objects.

```{r}
x <- Accumulator$new()
x$add(4)
x$sum
```

### 14.2.1: Method chaining 

`$add()`: called primarily for side-effect of updating `$sum`

```{r}
Accumulator <- R6::R6Class("Accumulator", list(
  sum = 0,
  add = function(x = 1) {
    self$sum <- self$sum + x
    invisible(self)
  }
))
```

Side-effect R6 methods should ALWAYS return `self` invisibly. Returns "current" object. Chain together multiple method calls:

```{r}
x$add(10)$add(10)$sum

## or method-chaining on new line
x$
  add(10)$
  add(10)$
  sum
```

### 14.2.2: Important methods

`$initialize()`: overrides default behavior of `$new()`. 

Ex. "Person" class with fields `$name` and `$age`. Ensure `$name` is ALWAYS single string, `$age` ALWAYS single number >>> place checks inside `$initialize()`. 

```{r}
Person <- R6::R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  }
))

hadley <- Person$new("Hadley", age = "thirty-eight")
hadley <- Person$new("Hadley", age = 38)
```

Use separate `$validate()` if have more requirements. Call only when needed.

`$print()`: overrides default printing behavior. Return `invisible(self)`.

```{r}
Person <- R6::R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    self$name <- name
    self$age <- age
  },
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age: ", self$age, "\n", sep = "")
    invisible(self)
  }
))

had2 <- Person$new("Hadley")
had2
```

Methods are bound to individual objects >>> previously created object does NOT get new method.

```{r}
hadley
hadley$print
```

### 14.2.3: Adding methods after creation

Modify fields + methods of an existing class. 

`$set()`: Add new elements to existing class. Supply visibility, name, component.

```{r}
Accumulator <- R6::R6Class("Accumulator")
Accumulator$set("public", "sum", 0)
Accumulator$set("public", "add", function(x = 1) {
  self$sum <- self$sum + x
  invisible(self)
})
```

Reminder: new methods + fields only available to NEW objects, not added retrospecitively to existing objects before definition.


### 14.2.4: Inheritance

`inherit` argument: inherit behavior from an existing class, provide class object

```{r}
AccumulatorChatty <- R6::R6Class("AccumulatorChatty", 
                                 inherit = Accumulator, 
                                 public = list(
                                   add = function(x = 1) {
                                     cat("Adding ", x, "\n", sep = "")
                                     super$add(x = x)
                                   }
                                 ))

x2 <- AccumulatorChatty$new()
x2$add(10)$add(1)$sum
```

`$add()` overrides superclass implementation. Use `super$` to delegate superclass implementation (similar to `NextMethod()`). Methods not overwritten will use parent class implementation.

### 14.2.5: Introspection

Every R6 object has S3 class that reflects its hierarchy of R6 classes. Easiest way to determine class and its inheritants with `class()`:

```{r}
class(had2)
```

S3 hierarchy includes base "R6" classes. Provide common behavior >> `print.R6()` method which class `$print()`.

`names()`: List all methods and fields

```{r}
names(had2)
```

### exercise

1.

```{r}
BankAccount <- R6Class(
  classname = "BankAccount", 
  public = list(
    balance = 0,
    deposit = function(dep = 0) {
      self$balance = self$balance + dep
      invisible(self)
    },
    withdraw = function(draw) {
      self$balance = self$balance - draw
      invisible(self)
    }
  ))

my_account <- BankAccount$new()
my_account$balance

my_account$
  deposit(5)$
  withdraw(15)$
  balance
```

```{r}
BankAccountStrict <- R6Class(
  classname = "BankAccount",
  inherit = BankAccount,
  public = list(
    withdraw = function(draw = 0) {
      if (self$balance - draw < 0) {
        stop("Your `withdraw` must be smaller ",
             "than your `balance`.", call. = FALSE)
      }
      super$withdraw(draw = draw)
    }
  ))
```


```{r}
my_strict_account <- BankAccountStrict$new()
my_strict_account$balance

my_strict_account$
  deposit(5)$
  withdraw(15)
```




```{r}
BankAccountCharging <- R6Class(
  classname = "BankAccount",
  inherit = BankAccount,
  public = list(
    withdraw = function(draw = 0) {
      if (self$balance - draw < 0) {
        draw <- draw + 1
      }
      super$withdraw(draw = draw)
    }
  ))
```


```{r}
my_charging_account <- BankAccountCharging$new()
my_charging_account$balance

my_charging_account$
  deposit(5)$
  withdraw(15)$
  withdraw(2)
```


2.

```{r}
suit <- c("♠", "♥", "♦", "♣")
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste0(rep(value, 4), suit)
```

```{r}
ShuffledDeck <- R6Class(
  classname = "ShuffledDeck", 
  public = list(
    deck = NULL,
    initialize = function(deck = cards) {
      self$deck <- sample(deck)
    },
    reshuffle = function() {
      self$deck <- sample(cards)
      invisible(self)
    },
    n = function() {
      length(self$deck)
    },
    draw = function(n = 1) {
      if (n > self$n()) {
        stop("Only ", self$n(), " cards remaining", call. = FALSE)
      }
      
      output <- self$deck[seq_len(n)]
      self$deck <- self$deck[-seq_len(n)]
      output
    }
  ))
```


```{r}
my_deck <- ShuffledDeck$new()
my_deck$draw(52)

my_deck$draw()

my_deck$reshuffle()$draw(5)
my_deck$deck
```

3. Why not model bank account // deck of cards with S3?

S3 uses copy-on-modify. Every deposit or card draw would create a new copy of the object. 

4.

```{r}
Timezone <- R6Class(
  classname = "Timezone",
  public = list(
    get = function() {
      Sys.timezone()
    },
    set = function(value) {
      stopifnot(value %in% OlsonNames())
      
      old <- self$get()
      Sys.setenv(TZ = value)
      invisible(old)
    }
  )
)
```


```{r}
tz <- Timezone$new()
tz$get() # Asia/Tokyo

old <- tz$set("Antarctica/South_Pole") # stores 'old' as returned invisibly
tz$get()

## reset
tz$set(old)
tz$get()
```

5.

```{r remedy001}

WorkingDirectory <- R6Class(
  classname = "WorkingDirectory", 
  public = list(
    get = function() {
      getwd()
    },
    set = function(value) {
      old <- self$get()
      setwd(value)
      invisible(old)
    }
  ))

asdf <- WorkingDirectory$new()
asdf$get()
hjkl <- asdf$set("lobsters")
asdf$get()
asdf$set(hjkl)
asdf$get()
```

6.

S3 not suitable for modelling state that changes over time. S3 should ~return SAME result when called with the same inputs.

7.

R6 objects are built on top of environments. 'class' attribute containing name, super class name, "R6" element.


## 14.3: Controlling access


- `private`: create fields + methods only available from within class.
- `active`: allow usage of accessor functions to define dynamic/active fields

### 14.3.1: Privacy

- 'private': argument similar to 'public' >>> input named list of methods (functions) and fields
- fields + methods defined in `private` accessed in methods via `private$` instead of `self$`. These can NOT be accessed outside of the class.

Ex. `$age` and `$name` as private fields within 'Person' class.

```{r}
Person <- R6Class("Person",
                  public = list(initialize = function(name, age = NA) {
                    private$name <- name
                    private$age
                  },
                  print = function(...) {
                    cat("Person: \n")
                    cat(" Name: ", private$name, "\n", sep = "")
                    cat(" Age: ", private$age, "\n", sep = "")
                  }
                  ),
                  private = list(
                    age = NA,
                    name = NULL
                  )
)

had3 <- Person$new("Hadley")
had3
had3$name
```

Distinction `public` vs. `private` important as define what you allow others to access. Private methods less important in R vs. other languages due to simpler object hierarchies in R.



### 14.3.2: Active fields 

'Active': define components that look like fields from outside but are defined with functions (~methods). 
'Active bindings': Each active binding is a function that takes a single argument `value`. If argument is `missing()`, then being retrieved or modified.

Ex. Make active field 'random' that returns a different value every time you access it.

```{r}
Rando <- R6Class("Rando", active = list(
  random = function(value) {
    if (missing(value)) {
      runif(1)
    } else {
      stop("Can't set `$random`", call. = FALSE)
    }
  }
))

x <- Rando$new()

x$random
x$random
x$random
```

'Active' fields useful with 'Private' fields as can implement components that look like fields from the outside but provide additional checks. 

Ex. Make read-only 'age' field, ensure 'name' is a length 1 char vector.

```{r}
Person <- R6Class("Person", 
  private = list(
    .age = NA,
    .name = NULL),
  active = list(
    age = function(value) {
      if (missing(value)) {
        private$.age
      } else {
        stop("`$age` is read-only", call. = FALSE)
      }
    },
    name = function(value) {
      if (missing(value)) {
        private$.name
      } else {
        stopifnot(is.character(value), length(value) == 1)
        private$.name <- value
        self
      }
    }
  ),
  public = list(
    initialize = function(name, age = NA) {
      private$.name <- name
      private$.age <- age
    }
  ))

had4 <- Person$new("Hadley", age = 24)
had4$name
had4$name <- 10
had4$age
had4$age <- 20
```


### exercise 

1.

```{r}
BankAccountStrict2 <- R6Class(
  classname = "BankAccountStrict2",
  public = list(
    deposit = function(dep = 0) {
      private$balance <- private$balance + dep
      invisible(self)
    },
    withdraw = function(draw = 0) {
      if (private$balance - draw < 0) {
        stop(
          "Your 'withdraw' must be smaller ",
          "than your 'balance'.",
          .call = FALSE
        )
      }
      private$balance <- private$balance - draw
      invisible(self)
    }
  ),
  private = list(
    balance = 0
  )
)

my_account_strict_2 <- BankAccountStrict2$new()

my_account_strict_2$deposit(5)
my_account_strict_2$withdraw(10)
```



2.

```{r}
Password <- R6Class(
  classname = "Password",
  public = list(
    print = function(...) {
      cat("<Password>: ******\n")
      invisible(self)
    },
    set = function(value) {
      private$password <- value
    },
    check = function(password) {
      identical(password, private$password)
    }
  ),
  private = list(
    password = NULL
  )
)

my_pw <- Password$new()
my_pw$set("snuffkin")
my_pw$password
my_pw
```



3.

```{r}
Rando <- R6Class(
  classname = "Rando",
  private = list(
    last_random = NULL
  ),
  active = list(
    random = function(value) {
      if (missing(value)) {
        private$last_random <- runif(1)
        private$last_random
      } else {
        stop("Can't set '$random'", call. = FALSE)
      }
    },
    previous = function(value) {
      if (missing(value)) {
        private$last_random
      }
    }
  )
)

x <- Rando$new()
x$random
x$random
x$previous
x$random(5)

y <- Rando$random(5)
```

4.

```{r}
A <- R6Class(
  classname = "A",
  private = list(
    field = "foo",
    method = function() {
      "bar"
    }
  )
)

B <- R6Class(
  classname = "B",
  inherit = A,
  public = list(
    test = function() {
      cat("Field: ", super$field, "\n", sep = "")
      cat("Method: ", super$method(), "\n", sep = "")
    }
  )
)

B$
  new()$
  test()
```

## 14.4: Reference semantics

Reference semantics: objects are NOT copied when modified

```{r}
y1 <- Accumulator$new()
y2 <- y1

y1$add(10)
c(y1 = y1$sum, y2 = y2$sum)
```

Use `$clone()` to explicitly copy object:

```{r}
y1 <- Accumulator$new()
y2 <- y1$clone()

y1$add(10)
c(y1 = y1$sum, y2 = y2$sum)
```

For recursive clone nested R6 objects use: `$clone(deep = TRUE)`.

- Harder to reason about code with R6 objects as you need context.
- Write a `$finalize()` to complement `$initialize()` to think about when R6 objects are deleted.
- If field is R6 object, it must be created inside `$initialize()`, not `R6Class()`

### 14.4.1: Reasoning

```{r}
x <- list(a = 1)
y <- list(b = 2)

z <- f(x, y)
```

For MOST functions `f(x, y)` ONLY modified `z`.

```{r}
x <- List$new(a = 1)
y <- List$new(b = 2)

z <- f(x, y)
```

Now if `f()` calls methods of `x` or `y`, it can modify them along WITH `z`. 

Write functions that either return a value OR modify R6 inputs >> NOT BOTH.


### 14.4.2: Finalizer

"Finalized": when object is deleted. For most objects with copy-on-modify semantics there are many transient versions of an object.


Ex. 2 factor objects: 2nd created when levels modified. First object destroyed by GC.

```{r}
x <- factor(c("a", "b", "c"))
x
levels(x) <- c("c", "b", "a")
x
```

R6 objects are only deleted ONCE. Finalizers ~ `on.exit()`, cleaning up any resources created by initializer. 

Ex. Wraps up temporary file, automatically deletes when class is finalized.

```{r}
TemporaryFile <- R6Class(
  "TemporaryFile",
  list(
    path = NULL,
    initialize = function() {
      self$path <- tempfile()
    },
    finalize = function() {
      message("Cleaning up ", self$path)
      unlink(self$path)
    }
  ))
```


Finalizer method run when object is deleted or when R exits.

Only use finalizer to clean up private resources allocated by initializer to avoid finalizer being called anywhere in R code.

```{r}
tf <- TemporaryFile$new()

rm(tf)
```

### 14.4.3: R6 fields

If use R6 class as default value of field, it will be shared across ALL instances of the object.

Ex. Create temp DB for every `TemporaryDatabase$new()` but current code always uses the same path. 

```{r}
TempDB <- R6Class(
  "TempDB",
  list(
    con = NULL, 
    file = TemporaryFile$new(),
    initialize = function() {
      self$con <- DBI::dbConnect(RSQLite::SQLite(), path = file$path)
    },
    finalize = function() {
      DBI::dbDisconnect(self$con)
    }
  )
)

db_a <- TempDB$new()
db_b <- TempDB$new()

db_a$file$path == db_b$file$path
```

"Mutable default argument" problem in Python.

`TemporaryFile$new()` called ONLY once when `TempDB` class is defined. 

Solution: Necessary to call `TemporaryFile$new()` every time `TempDB$new()` is called. So needs to be put inside `$initialize()`.

```{r}
TempDB <- R6Class(
  classname = "TempDB",
  list(
    con = NULL,
    file = NULL,
    initialize = function() {
      self$file <- TemporaryFile$new()
      self$con <- DBI::dbConnect(RSQLite::SQLite(), path = file$path)
    },
    finalize = function() {
      DBI::dbDisconnect(self$con)
    }
  )
)

db_a <- TempDB$new()
db_b <- TempDB$new()

db_a$file$path == db_b$file$path
```

### exercise 

1. 

```{r}
FileWriter <- R6Class(
  classname = "FileWriter",
  public = list(
    con = NULL,
    initialize = function(filename) {
      self$con <- file(filename, open = "a")
    },
    finalize = function() {
      close(self$con)
    },
    append_line = function(x) {
      cat(x, "\n", sep = "", file = self$con)
    }
  )
)

tmp_file <- tempfile()
my_fw <- FileWriter$new(tmp_file)

readLines(tmp_file)

my_fw$append_line("blah")
my_fw$append_line("meep meep")
readLines(tmp_file)
```

## 14.5: Why R6


R6 over RC ('reference classes'):

- R6 is simpler. Both built on top of environments but R6 uses S3 and RC uses S4. To fully understand RC need to also know more complicated S4.

- R6 has documentation: https://r6.r-lib.org

- R6 has simpler mechanism for cross-package subclassing.

- RC mingles variables and fields in the same stack of environments so you need to get and set fields like regular values. R6 places fields in a separate environment so you can get and set fields with a prefix. More explicit.

-- RC: `field`, `field <<- value`
-- R6: `self$field`, `self$field <- value`

- Speed: R6 > RC. 

- RC is tied to R. Any bugs fixed can only come from new versions of R. Difficult for packages that need to work across different versions.

- R6 and RC are similar so only need slightly additional knowledge for RC if necessary.



# 15 S4

Formal approach to OOP, similar to S3 but stricter and more specialized implementation. 

- Slot: Named component of object accessed >>> `@` operator. 

{methods}: part of R but not from batch. Good to specify that you're using S4. 

## 15.2: Basics

`setClass()`: define class name and slots, names and class of 'class' data.

```{r}
setClass("Person",
         slots = c(
           name = "character",
           age = "numeric"
         ))
```

Once class is defined, create new objects via `new()` with name of class and value for each slot.

See class with `is()`. Access slots with `@` and `slot()`.

```{r}
john <- new("Person", name = "John Smith", age = NA_real_)

is(john)

john@name
slot(john, "age")
```

Only use `@` in own methods. For other people's classes, find 'accessor' functions. 

Accessors: S4 generics that allow multiple classes to share same external interface.

```{r}
setGeneric("age", function(x) standardGeneric("age"))
setGeneric("age<-", function(x, value) standardGeneric("age<-"))

setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```


If using S4 class defined in package. `class?___` for help. 

Identify S4 objects and generics:

```{r}
sloop::otype(john)
sloop::ftype(age)
```

### exercise

1.

```{r}
example_12345 <- lubridate::period(c(1, 2, 3, 4, 5), 
                                   c("second", "minute", "hour", "day", "week"))
example_12345
str(example_12345)
```

2.

`?method()`
`?genericName`
`methods?genericName`
`ClassName?methodName`

## 15.3: Classes

Define S4 class, use `setClass()`:

- class `name`: use UpperCamelCase
- Named character vector `slots`: Describe name and classes. 

Ex. Person >>> `c(name = "character", age = "numeric")`

- `prototype`: list of default values for each slot. Optional but should always provide.

```{r}
setClass("Person",
         slots = c(
           name = "character",
           age = "numeric"
         ),
         prototype = list(
           name = NA_character_,
           age = NA_real_
         )
)

me <- new("Person", name = "Hadley")
str(me)
```

### 15.3.1: Inheritance

`contains`: Specifies class of inheritance for slots and behaviors. 

```{r}
setClass("Employee",
         contains = "Person",
         slots = c(
           boss = "Person"
         ),
         prototype = list(
           boss = new("Person")
         ))

str(new("Employee"))
```

### 15.3.2: Introspection

`is()`: determine what class an object inherits from

```{r}
is(new("Person"))
is(new("Employee"))

## test if object inherits from specific class
is(john, "person")
```

### 15.3.3: Redefinition

Unlike other languages, class definition and object construction happen at run time.

When use `setClass()` >> register class definition in hidden global variable. Can create invalid ojects if redefine class after already instantiated object:

```{r}
setClass("A", slots = c(x = "numeric"))
a <- new("A", x = 10)

setClass("A", slots = c(a_different_slot = "numeric"))
a
```

### 15.3.4: Helper

`new()`: low-level constructor for developer. User-facing classes should have user-friendly helper. 

- Have same name as class
- Have thoughtfully crafted UI with carefully chosen defauls, conventions
- Create error messages for end-user
- Finish by callling `methods::new()`


`age` == optional but `name` == required

```{r}
Person <- function(name, age = NA) {
  age <- as.double(age)
  new("Person", name = name, age = age)
}

Person("Hadley")
```

### 15.3.5: Validator

Constructor automatically checks for correct classes:

```{r}
Person(mtcars)
```

`Person` class is vector class, so for multiple people. `@name` and `@age` can be diffferent length.

```{r}
Person("hadley", age = c( 30, 38))
```

Enforce additional constraints >>> write validator with `setValidity()`. Takes class and function == `TRUE` IF input is valid. 

```{r}
setValidity("Person", function(object) {
  if (length(object@name) != length(object@age)) {
    "@name and @age must be same length"
  } else {
    TRUE
  }
})

Person("Hadley", age = c(30, 38))
```

Validity method is only called automatically by `new()` >>> can still create invalid object by modifying it:

```{r}
alex <- Person("Alex", age = 30)

alex@age <- 1:10
alex

validObject(alex)
```


### exercise

1.


```{r}
setClass("Person", 
         slots = c(
           name = "character", 
           age = "numeric",
           given = "character",
           family = "character",
           role = "character",
           email = "character",
           comment = "character"
         ),
         prototype = list(
           name = NA_character_,
           age = NA_real_,
           given = NA_character_,
           family = NA_character_,
           role = NA_character_,
           email = NA_character_,
           comment = NA_character_
         )
)

# Helper to create instances of the Person class
Person <- function(name, age = NA, 
                   given = NA_character_,
                   family = NA_character_,
                   role = NA_character_,
                   email = NA_character_,
                   comment = NA_character_) {
  age <- as.double(age)
  
  new("Person", name = name, age = age, 
      given = given, family = family, 
      role = role, email = email,
      comment = comment)
}

# Validator to ensure that each slot is of length one
setValidity("Person", function(object) {
  invalids <- c()
  if (length(object@name)    != 1 |
      length(object@age)     != 1 |
      length(object@given)   != 1 |
      length(object@family)  != 1 |
      length(object@email)   != 1 |
      length(object@comment) != 1) {
    invalids <- paste0("@name, @age, @given, @family, @email, ",
                       "@comment must be of length 1")
  } 
  
  if (!all(object@role %in% c(NA_character_, 
                              "aut", "com", "cph", "cre", "ctb",
                              "ctr", "dtc", "fnd", "rev", "ths", "trl"))) {
    invalids <- c(invalids, paste(
      "@role (s) must be one of", 
      paste (c(NA_character_, 
               "aut", "com", "cph", "cre", "ctb",
               "ctr", "dtc", "fnd", "rev", "ths", "trl"),
             collapse = ", "), ".")
    )
  }
  if (length(invalids)) return(invalids)  
  TRUE
})
```



2.







3. 



## 15.4: Generics and methods

Generic: perform method dispatch >> find specific implementation for combination of classes passed to the generic.

`setGeneric()` + `standardGeneric()`: create new S4 generic. Use lowerCamelCase.

```{r}
setGeneric("myGeneric", function(x) standardGeneric("myGeneric"))
```

Do NOT use `{}` as for special case.

### 15.4.1: Signature

`signature`: control arguments used for method dispatch. If NOT supplied, all arguments besides `...` are used. It is occasionally useful to remove arguments from dispatch >>> `verbose = TRUE | quiet = FALSE`.

```{r}
setGeneric("myGeneric",
           function(x, ..., verbose = TRUE) standardGeneric("myGeneric"),
           signature = "x")
```

### 15.4.2: Methods

`setMethod()`: define S4 methods. 

- name of generic, name of class, method

```{r}
setMethod("myGeneric", "Person", function(x) {
  # blah blah
})
```

`signature`: specifies the argument classes for which method applies. Can include multiple arguments and avoids having to implement double-dispatch like in S3. 

`methods("generic") | methods(class = "class")`: list all methods belonging to generic or associated with class. 

`selectMethod("generic", "class")`: find implementation of specific method

### 15.4.3: Show method

`show()`: controls how object appears when printed. Find using `args()` of the generic.

```{r}
args(getGeneric("show"))
```

```{r}
setMethod("show", "Person", function(object) {
  cat(is(object)[[1]], "\n",
      "  Name: ", object@name, "\n",
      "  Age: ", object@age, "\n",
      sep = "")
})

john
```


### 15.4.4: Accessors

Slots: internal implementation detail. User code should avoid accessing directly. All user-accessible slots should be accompanied by accessors. 

If slot is unique to class can be function:

```{r}
person_name <- function(x) x@name
```

Define generic so multiple classes can use same interface

```{r}
setGeneric("name", function(x) standardGeneric("name"))
setMethod("name", "Person", function(x) x@name)

name(john)
```

If slot is write-able >>> provide setter function. Include `validObject()` to prevent users from creating invalid objects.

```{r}
setGeneric("name<-", function(x, value) standardGeneric("name<-"))
setMethod("name<-", "Person", function(x, value) {
  x@name <- value
  validObject(x)
  x
})

name(john) <- "Bojangles Johnson"
name(john)

name(john) <- letters
```

### exercise


1.

```{r}
setGeneric("age", function(x) standardGeneric("age"))
setMethod("age", "Person", function(x) x@age)

setGeneric("age<-", function(x, value) standardGeneric("age<-"))
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  validObject(x)
  x
})
```

2.

Generic definition: name for generic and then name for incorporating method dispatch via `standardGeneric()`.

3.

`is(object)` returns class of object. Contains subclass >> superclass >> superclass, etc. To return most specific subclass, need to specify first element of the object.


4.





## 15.5 Method dispatch

S4 dispatch: 

- Multiple inheritance: class can have multiple parents
- Multiple dispatch: generic can use multiple arguments to pick method

Difficult to understand which method selected for given combination of inputs. Keep things simple unless absolutely necessary. 

### 15.5.1: Single dispatch

To find method that gets called start with most specific class of actual arguments and follow until find method that exists. If NO method found then method dispatch fail == error. Always define methods for terminal modes.

Pseudo-classes: don't actually exist but can define useful behaviors. 

- ANY: which matches with any class.
- MISSING: If method defined for MISSING, will match whenever argument is missing. 

### 15.5.2: Multiple inheritance

Start from actual class supplied to generic and follow until find defined method. If multiple methods found, pick method closest to supplied class. IF methods are same distance then "ambiguous" method. Warning shown and method for class that comes earlier in alphabet will be picked (bad!). Should always strive to resolve through providing a more precise method! ANY will never contribute to ambiguity as it is always farthest away than method for a real class. 

With multiple inheritances hard to prevent ambiguity AND ensure every terminal method has implementation AND minimize # of defined methods.

### 15.5.3: Multiple dispatch

Each method is specified by multiple classes. Fewer terminal class combinations so at minimum can define a single method and have default behavior for ALL inputs. 


### 15.5.4: Multiple dispatch and multiple inheritance

Bigger graph == more confusion.

### exercise

1.


2.


3.


## 15.6: S4 and S3


With S4 need to interact with existing S3 classes and generics.

### 15.6.1: Classes

`slots` and `contains` can use S4 classes, S3 classes, implicit class of base type.

To use S3 class >>> register with `setOldClass()`. Call for each S3 class and give 'class' attribute. 

```{r}
setOldClass("data.frame")
setOldClass(c("ordered", "factor"))
setOldClass(c("glm", "lm"))

setClass("factor",
         contains = "integer",
         slots = c(
           levels = "character"
         ),
         prototype = structure(
           integer(),
           levels = character()
         ))

setOldClass("factor", S4Class = "factor")
```

Definitions should be provided by creator of S3 class. Request package maintainer to add call to package.

If S4 object inherits from S3 class or base type >>> special virtual slot `.Data` containing underlying base type or S3 object.

Possible to define S3 methods for S4 generics and vice-versa (if set `setOldClass()`). 
### 15.6.2: Generics

Convert existing S3 generic to S4 generic. Existing function becomes default method (ANY). 

```{r}
setGeneric("mean")
selectMethod("mean", "ANY")
```




# 16 Trade-offs

## 16.2: S4 vs. S3

S4 is more formal, verbose, strict vs. S3. Well suited for large teams as structure provided by system itself. Needs more upfront design vs. S3. Better investment for large projects where greater resources are available. 

S4: Used in Bioconductor for data structures built in S4. 

S4: Complex systems of interrelated objects, minimalize code duplication through careful implementation of methods. Ex. {Matrix}

S4: Easy to provide a general method that works for all inputs and more specialized methods where inputs allows for a more efficient implementation. Careful planning needed to avoid method dispatch ambiguity but higher performance.

S4: increased complexity vs. S3 and lack single source of documentation. 


## 16.3: R6 vs. S3

R6: encapsulated objects > generic functions. Reference semantics (modify-in-place). 

Generic: regular function that lives in global namespace. 

R6 method: belongs to object and lives in local namespace. Invoke via `$` and can method chain.

Reference semantics: methods simultaneously return value AND modify object. 

### 16.3.1: Namespacing

Global namespace: multiple packages can use same verbs for working with different types of objects. Generic functions provide uniform API to perform typical actions with a new objects due to strong name conventions. Works well for data analysis as do same thing to differen types of objects (e.g. statistical models >>> can always use `summary()`, `predict()`, etc.). 

- Disadvantage: More thought required for naming. Avoid multiple generics with same name in different packages or else use `::` a lot. Not a problems with R6 as methods scoped to object. S3 generics must have same core arguments. Necessity use non-specific names `x`, `.data`, etc. Use of `...` to pass additional arguments but misspelled arguments will NOT create error. Creating S3 method is expensive as have to also create generic and think about naming. 

R6 advantages: R6 methods can have more variety + use specific/evocative argument names. Creating R6 method is cheap due to local namespacing. Most encapsulated OO languages encourage create many small methods >> each do one small thing well with evocative name. 


### 16.3.2: Threading state

S3 challenges when want to return a value AND modify object. Function should be called for return value OR side effect but may be needed in certain cases. 

Ex. "stack" of objects:

`push()`: add new object to top of stack
`pop()`: return top most value and then remove 

A stack contains a list of items, pushing an object to stack = append to list.

```{r}
new_stack <- function(items = list()) {
  structure(list(items = items), class = "stack")
}

push <- function(x, y) {
  x$items <- c(x$items, list(y))
  x
}
```


`pop()`: return value (object at top of stack) AND side-effect (remove object at top)

Need to return value AND updated object as can't modify input object in S3. 


```{r}
pop <- function(x) {
  n <- length(x$items)
  item <- x$items[[n]]
  x$items <- x$items[-n]
  
  list(item = item, x = x)
}

s <- new_stack()
s <- push(s, 10)
s <- push(s, 20)

out <- pop(s)
out$item

s <- out$x
s
```

Threading state/accumulator programming: No matter how deeply `pop()` is called, you have to thread the modified stack object all the way back to where it lives. 

Functional programming langugages use 'multiple assign'/'destructruing bind' operators to assign multiple values in a single step. 



R6 implementation of "stack" is much simpler as `$pop()` can modify-in-place AND return only top-most value:

```{r}
Stack <- R6Class("Stack", list(
  items = list(),
  push = function(x) {
    self$items <- c(self$items, x)
    invisible(self)
  },
  pop = function() {
    item <- self$items[[self$length()]]
    self$items <- self$items[-self$length()]
    item
  },
  length = function() {
    length(self$items)
  }
))

s <- Stack$new()

s$
  push(10)$
  push(20)$
  pop()

s$items
```

### 16.3.3: Method chaining

Commonly used in other programming languages >> Python, JS, etc.

Any R6 method that is primarily called for its side-effects (~modify-in-place) should return `invisible(self)`. Useful auto-complete vs. only creator of class can add new methods (NO multiple dispatch).





# IV. Meta-programming


Code: data that can be inspected and modified programatically. 

`library(purrr)` > `library("purrr")`

Non-standard evaluation (NSE): property of the arguments of a function, what IS standard then?

# 17 Big picture

## 17.2 Code is data

`rlang::expr()`: Capture code and compute on as you can with any other type of data. 

```{r}
expr(mean(x, na.rm = TRUE))

expr(10 + 100 + 1000)
```

Expression: captured code. Collective term for 4 types (call, symbol, constant, pairlist)

`enexpr()`: capture code passed to a function >> user input. 

```{r}
capture_it <- function(x) {
  enexpr(x)
}

capture_it(a + b + c)
```

Once expression is captured, can inspect and modify it. Complex expressions behave as lists so use `[[` and `$`.

```{r}
f <- expr(f(x = 1, y = 2))

f$z <- 3
f

f[[2]] <- NULL
f
```

## 17.3 Code is a tree

Abstract syntax tree (AST): code represented as tree structure. In R can manipulate and inspect tree.

`lobstr::ast()`: Displays underlying tree structure of a function. Function calls form the branches, shown as recetangles. Leaves of tree are symbols and/or constants.

```{r}
lobstr::ast(f(a, "b"))
```

Nested function calls create more deeply branching trees:

```{r}
lobstr::ast(f1(f2(a, b), f3(1, f4(s))))
```

ALL R expressions can be displayed including prefix forms:

```{r}
lobstr::ast(1 + 2 * 3)
```

## 17.4 Code can generate code

`rlang::call2()`: code to create new trees, construct function call from components.

```{r}
call2("f", 1, 2, 3)
call2("+", 1, call2("*", 2, 3))
```

`!!`, unquote operator: build complex code trees by combining simpler code trees with a template. `!!x` inserts code tree stored in 'x' into the expression.

```{r}
xx <- expr(x + x)
yy <- expr(y + y)

expr(!!xx / !!yy)
```

Output preserves operator precedence. Unquoting useful when wrap into a function. 

Use `enexpr()` to capture user expression, then `expr()` and `!!` to create a new expression using a template. 

Ex. generate expression that computes the coefficent of variation:

```{r}
cv <- function(var) {
  var <- enexpr(var)
  expr(sd(!!var) / mean(!!var))
}

cv(x)
cv(x + y)
```

```{r}
cv(`)`)
```


## 17.5 Evaluation runs code

`evaluate`: execute/run an expression. Evaluating an expression requires an environment, which tells R what symbols in the expression mean. 

`base::eval()`: primary tool for evaluating expressions >>> takes expression and environment as arguments.

```{r}
eval(expr(x + y), env(x = 1, y = 10))

eval(expr(x + y), env(x = 2, y = 100))
```

If 'environment' is omitted, it uses current environment:

```{r}
x <- 10
y <- 100
eval(expr(x + y))
```

Advantages of evaluating code manuallly: tweak environment.

- temporarily override functions to implement a DLS
- add data mask to refer to variables in a data frame as if they are variables in an environment. 

## 17.6 Customizing evaluation with functions

Names can be bound to functions which can override the behavior of existing functions.

Ex. `*` and `+` overridden to work with strings instead of numeric: 

```{r}
string_math <- function(x) {
  e <- env(
    caller_env(),
    `+` = function(x, y) paste0(x, y),
    `*` = function(x, y) strrep(x, y)
  )
  
  eval(enexpr(x), e)
}

name <- "Hadley"
string_math("Hello" + name)
string_math(("x" * 2 + "-y") * 3)
```

ex. {dplyr} takes code and generates SQL for execution in a DB:


```{r}
con <- DBI::dbConnect(RSQLite::SQLite(), filename = ":memory:")
mtcars_db <- copy_to(con, mtcars)

mtcars_db %>% 
  filter(cyl > 2) %>% 
  select(mpg:hp) %>% 
  head(10) %>% show_query()

DBI::dbDisconnect(con)
```

## 17.7 Customizing evaluation with data


Rebinding functions is powerful but requires investment. More practical application is modifying evaluation to look for variables ina a data frame instead of environment. 

Ex. `subset()`, `transform()`, `ggplot2::aes()`, `dplyr::mutate()`. 

`tidyeval::eval_tidy()`: expression, environment, data mask as arguments. 

```{r}
df <- data.frame(x = 1:5, y = sample(5))

eval_tidy(expr(x + y), df)
```

Data mask: useful fo interactive analysis as can write `x + y` instead of `df$x + df$y` but comes with the cost of ambiguity. 

Wrap with `enexpr()` >>> similar to `base::with()`

```{r}
with2 <- function(df, expr) {
  eval_tidy(enexpr(expr), df)
}

with2(df, x + y)
```

## 17.8 Quosures

Bug in `with2()`. Evaluation of captured expression where it's being written and not the environment within created function itself. 

```{r}
with2 <- function(df, expr) {
  a <- 1000
  eval_tidy(enexpr(expr), df)
}

df <- data.frame(x = 1:3)
a <- 10
with2(df, x + a)
```

Needs to evalute `a = 10` rather than `a = 1000` inside the function environment.

`quosure`: bundles an expression with an environment. Use `enquo()` instead of `enexpr()`. 

```{r}
with2 <- function(df, expr) {
  a <- 1000
  eval_tidy(enquo(expr), df)
}

with2(df, x + a)
```

If using a data mask, need to ALWAYS use `enquo()` instead of `enexpr()`. 


# 18 Expressions

Expression: capture intent of code without execution. object that captures the structure of the code without evaluating it. 

```{r}
z <- rlang::expr(y <- x * 10)
z
```

Ealuate expression with `base::eval()`:

```{r}
x <- 4 
eval(z)
y
```

Expression: list of calls, created through parsing text. Expressions can become text via deparsing.



## 18.2 Abstract syntax trees (AST)

AST: hierarchical structure, represented as tree. 

### 18.2.1: Drawing

Use `lbostr::ast()`

```{r}
lobstr::ast(f(x, "y", 1))
```

Leaves: symbols (purple) or constants, strings always ""

Branches: Call objects/function calls. Orange. 

```{r}
lobstr::ast(f(g(1, 2), h(3, 4, i())))
```


### 18.2.2: Non-code components

Only captures important structural details, NOT whitespace or comments.

### 18.2.3: Infix calls

Any call in R can be written in tree form as can be switched to prefix form. 

```{r}
x <- 5
y <- x * 10
y
`<-`(y, `*`(x, 10))
y

lobstr::ast(y <- x * 10)
```

### exercise

1.

```{r}
ast( f(g(h()), `+`(`+`(1, 2), 3), `*`(`(`(`+`(x, y))), z)  )
```


2.


3.

4.


5.





## 18.3 Expressions

Expression: any member of the set of base types created by parsing code

- constant scalars, symbols, call objects, pairlists

### 18.3.1: Constants

Simplest components of AST. 

Constant: either `NULL` or length-1 atomic vector/scalar. Self-quoting as expression used to represent a constant is the SAME constant.

Ex. `TRUE`, `1L`, `2.5`, "x" >>> `rlang::is_syntactic_literal()`

```{r}
identical(expr(TRUE), TRUE)
identical(expr(1), 1)
identical(expr("x"), "x")
identical(expr(2L), 2L)
```

### 18.3.2: Symbols

Symbol: represents name of object 

Ex. 'x', 'mtcars', 'mean'

Create via capture code that references an object with `expr()` or turn string into a symbol with `rlang::sym()`:

```{r}
expr(x)
sym("x")
```

Convert back into string with `as.character()` or `rlang::as_string()`. 

Symbol are printed without quotes. Use `is.symbol()` and `str()`

```{r}
str(expr(x))
is.symbol(expr(x))
```

### 18.3.3: Calls

Call object: captured function call. Special type of list where 1st components specifies the function to call. Other components are arguments for function call. Call objects create branches in AST as calls can be nested inside other calls.

ID call object when printed as it looks like a function call. `typeof() | str()` returns "language". `is.call()` returns `TRUE`. 

```{r}
ast(read.table("importante.csv", row.names = FALSE))

x <- expr(read.table("importante.csv", row.names = FALSE))
typeof(x)
is.call(x)
```

#### 18.3.3.1: Subsetting

Calls behave as lists. Use subsetting tools. 

Call:

```{r}
x[[1]]

is.symbol(x[[1]])
```
Arguments:

```{r}
as.list(x[-1])
```

Extract individual arguments with `[[` or `$` if named

```{r}
x[[2]]
x$row.names

length(x) - 1
```

Extracting specific arguments is difficult due to flexible rules for argument matching. Use `rlang::call_standardize()`

```{r}
rlang::call_standardise(x)
```

#### 18.3.3.2: Function position

Function position: first elemenet of call object. Contains function that will be called when object is evaluated >>> as symbol.

```{r}
ast(foo())

ast("foo"())
```

If function from another package, R6 object method, function factory created function then function position will be different than expected.

#### 18.3.3.3: Constructing

COnstruct call object from components with `rlang::call2()`. 

```{r}
call2("mean", x = expr(x), na.rm = TRUE)
call2(expr(base::mean), x = expr(x), na.rm = TRUE)
call2("<-", expr(x), 10)
```

### 18.3.4: Summary

### exercise 


1.


```{r}
expr(c(1, 1))
```


2.

```{r}
expr(read.csv("foo.csv", header = TRUE))[-1]
```

First argument is always the function call. So if removed the next element is assumed to be the function call.


3. 

```{r}
x <- 1:10

call2(median, x, na.rm = TRUE)
call2(expr(median), x, na.rm = TRUE)
call2(median, expr(x), na.rm = TRUE)
call2(expr(median), expr(x), na.rm = TRUE)
```


4. 

`mean()` uses `...` argument. Use specific S3 method for `rlang::call_standardise()` to be effective. 


5. 

```{r}
x <- expr(foo(x = 1))
x

names(x) <- c("x", "y")
```
R ignores added metadata to name of object.


## 18.4 Parsing and grammar

Parsing: process which computer language takes a string and constructs and expression

Grammar: set of rules that governs the parsing process

### 18.4.1: Operator precedence

Infix functions: two sources of ambiguity

- Ex. `1 + 2 * 3` >>> 7 or 9?

```{r}
ast(1 + 2 * 3)
```


`!` has lower precedence:

```{r}
ast(!x %in% y)
```

```{r}
ast((1 + 2) * 3)
```


### 18.4.2: Associativity

Repeated usage of the same infix function.

Ex. `1 + 2 + 3` == `(1 + 2) + 3` or `1 + (2 + 3)`?

Some S3 classes define `+` in non-associative ways. {ggplot2} layering system.

Most operators are LEFT-associative >>> operations on left are evaluated first.

```{r}
ast(1 + 2 + 3)
```

Exceptions: Exponentiaton + assignment

```{r}
ast(2^2^3)
ast(x <- y <- z)
```

### 18.4.3: Parsing and deparsing

Parse code in a string: `rlang::parse_expr()`

```{r}
x1 <- "y <- x + 10"
x1
is.call(x1)

x2 <- rlang::parse_expr(x1)
x2
is.call(x2)
```

Always returns single expression. FOr multiple separated by `;` or `\n` use `rlang::parse_exprs()`. Returns as list.

```{r}
x3 <- "a <- 1; a + 1"
rlang::parse_exprs(x3)
```

Base R: 

Use `parse()` >>> used mainly for parsing R code stored in files. 


Deparsing: Given an expression create the string. Use `rlang::expr_text()`.

```{r}
z <- expr(y <- x + 10)
expr_text(z)
```

Not perfectly symmetric due to AST lose backticks, comments, whitespace, etc.

### exercise

1.

```{r}
ast(f((1)))

ast(`(`(1 + 1))
```

`(` can be part of prefix function syntax but also represent call to `(` function itself.

2.
`=`  used for assignment AND for naming arguments inside function calls.

```{r}
ast({b = c(c = 1)})
```


3.

Exponentials are an exception to left-associative rule.



4.

```{r}
!1 + !1

ast(!1+ !1)
```

Non-zero numeric  == TRUE



5.

`<-` assignment is right-associative

6.



7.

8.

9.


## 18.5 Walking AST with recursive functions

Use ASTs for more complicated problems.

{codetools}

- `findGlobals()`: locate all global variables used by function
- `checkUsage()`: check for common problems. ex. unused local variables, parameters, partial argument matching. 

Recursive case: handles nodes in tree. "Something" to each child of node, then combine results together. Handle calls and pairlists for expressions.

Base case: handles leaves in tree. Function eventually termminates by solving cases directly. Handle symbols and constants for expressions.

`expr_type()`: constant for constant, symbol for symbol, etc. type for all else.

```{r}
expr_type <- function(x) {
  if (rlang::is_syntactic_literal(x)) {
    "constant"
  } else if (is.symbol(x)) {
    "symbol"
  } else if (is.call(x)) {
    "call"
  } else if (is.pairlist(x)) {
    "pairlist"
  } else {
    typeof(x)
  }
}

expr_type(expr("a"))
#> [1] "constant"
expr_type(expr(x))
#> [1] "symbol"
expr_type(expr(f(1, 2)))
```
`switch_expr()` & `recurse_call()`: 

```{r}
switch_expr <- function(x, ...) {
  switch(expr_type(x),
    ...,
    stop("Don't know how to handle type ", typeof(x), call. = FALSE)
  )
}

recurse_call <- function(x) {
  switch_expr(x,
    # Base cases
    symbol = ,
    constant = ,

    # Recursive cases
    call = ,
    pairlist =
  )
}
```


### 18.5.1: Find T and F

Check if use of logical abbreviations == bad code. Return TRUE if input contains logical abbrev. else FALSE.

```{r}
expr_type(expr(TRUE))
expr_type(expr(T))
```

TRUE: logical vector length 1
T: name/symbol

```{r}
logical_abbr_rec <- function(x) {
  switch_expr(x,
              constant = FALSE,
              symbol = as_string(x) %in% c("F", "T"))
}

logical_abbr_rec(expr(TRUE))

logical_abbr_rec(expr(T))
```

Use wrapper providing defaults >>> ex. quote input so not need to use `expr()` every time.

```{r}
logical_abbr <- function(x) {
  logical_abbr_rec(enexpr(x))
}

logical_abbr(TRUE)

logical_abbr(T)
```

Implement for recursive case: Calls and pairlists. Apply function recursively to each subcomponent and return TRUE if ANY contains logical abbrev.

```{r}
logical_abbr_rec <- function(x) {
  switch_expr(x, 
              constant = FALSE,
              symbol = as_string(x) %in% c("F", "T"),
              
              call = ,
              pairlist = purrr::some(x, logical_abbr_rec))
}

logical_abbr(mean(x, na.rm = T))
logical_abbr(function(x, na.rm = T) FALSE)
```

### 18.5.2: Find all variables created by assignment

AST for assignment:

```{r}
ast(x <- 10)
```
call object `<-`:

[[1]]: symbol `<-`
[[2]]: name of variable being assigned
[[3]]: value to be assigned to variable

Return char vec for results > symbols == lists == ^ complicated.

```{r}
find_assign_rec <- function(x) {
  switch_expr(x,
    constant = ,
    symbol = character()
  )
}
find_assign <- function(x) find_assign_rec(enexpr(x))

find_assign("x")
#> character(0)
find_assign(x)
```

Recursive: 

`flat_map_chr()` expects `.f` return char vec of 'n' length and flatten all results into a single char vec. 

```{r}
flat_map_chr <- function(.x, .f, ...) {
  purrr::flatten_chr(purrr::map(.x, .f, ...))
}

flat_map_chr(letters[1:3], ~ rep(., sample(3, 1)))
```

Pairlists: iterate over elements of pairlist (function arguments), combine results. 

Calls: if call == `<-` then return [[2]] of call (name of variable being assigned).

```{r}
find_assign_rec <- function(x) {
  switch_expr(x,
    # Base cases
    constant = ,
    symbol = character(),

    # Recursive cases
    pairlist = flat_map_chr(as.list(x), find_assign_rec),
    call = {
      if (is_call(x, "<-")) {
        as_string(x[[2]])
      } else {
        flat_map_chr(as.list(x), find_assign_rec)
      }
    }
  )
}

find_assign(a <- 1)
#> [1] "a"
find_assign({
  a <- 1
  {
    b <- 2
  }
})

find_assign("x")
```

Same variable assigned multiple times? Wrap with `unique()`

```{r}
find_assign({
  a <- 1
  a <- 2
})

find_assign <- function(x) unique(find_assign_rec(enexpr(x)))

find_assign({
  a <- 1
  a <- 2
})
```

Nested calls to `<-`: Recursion terminates at first `<-`

```{r}
find_assign({
  a <- b <- c <- 1
})
```

Create recursive function >>> separate out function for calls.

```{r}
ast(a <- b <- c <- 1)

## first take out first `<-` found
## then take out first `<-` from list of calls
## then iterate over next until all found then terminate recursion
```

```{r}
find_assign_call <- function(x) {
  if (is_call(x, "<-") && is_symbol(x[[2]])) {
    lhs <- as_string(x[[2]])
    children <- as.list(x)[-1]
  } else {
    lhs <- character()
    children <- as.list(x)
  }

  c(lhs, flat_map_chr(children, find_assign_rec))
}

find_assign_rec <- function(x) {
  switch_expr(x,
    # Base cases
    constant = ,
    symbol = character(),

    # Recursive cases
    pairlist = flat_map_chr(x, find_assign_rec),
    call = find_assign_call(x)
  )
}

find_assign(a <- b <- c <- 1)
#> [1] "a" "b" "c"
find_assign(system.time(x <- print(y <- 5)))
```

### exercise 


1.




2.






3.




4.


## 18.6 Specialized data structures 


### 18.6.1: Pairlists

Replaced by lists. Formal arguments to function are stored in pairlist. Treat as list. Uses linked list data structure > arrays. Subsetting is slower. 

```{r}
f <- expr(function(x, y = 10) x + y)

args <- f[[2]]
args
typeof(args)

pl <- pairlist(x = 1, y = 2)
length(pl)
pl$x
```

### 18.6.2: Missing arguments

Empty symbol: represent missing arguments. `...`

```{r}
missing_arg()
typeof(missing_arg())

rlang::is_missing(missing_arg())

f <- expr(function(x, y = 10) x + y)
args <- f[[2]]
is_missing(args[[1]])

f <- expr(function(...) list(...))
args <- f[[2]]
is_missing(args[[1]])
```

If bound to variable >>> error when attempt to access. Store in another data structure. Use `lrnag::maybe_missing()` to preserve. 

```{r}
m <- missing_arg()
m

ms <- list(missing_arg(), missing_arg())
```


### 18.6.3: Expression vectors

Expression vectors: `expression()` and `parse()`. Behaves as lists. 


```{r}
exp1 <- parse(text = c("
x <- 4
x
"))
exp2 <- expression(x <- 4, x)

typeof(exp1)
#> [1] "expression"
typeof(exp2)
#> [1] "expression"

exp1
#> expression(x <- 4, x)
exp2

length(exp1)
#> [1] 2
exp1[[1]]
```


# 19 Quasiquotations


Quotation: capturing an unevaluated expression.

Unquotation: Selectively evaluate parts of a quoted expression.

Quasiquotation: create functions that combine code written by function author and code written by function user.


## 19.2 Motivation

Ex. strings

```{r}
paste("Good", "morning", "Hadley")
paste("Good", "afternoon", "Alice")
```

Create a function so we don't have to use quotation marks!

```{r}
cement <- function(...) {
  args <- ensyms(...)
  paste(purrr::map(args, as_string), collapse = " ")
}

cement(Good, morning, Hadley)
cement(Good, afternoon, Alice)
```

If use variables then can not use.

```{r}
name <- "Hadley"
time <- "morning"

paste("Good", time, name)
cement(Good, time, name)
```

Explicitly unquote input to remove quotation marks. 

`!!`: Use unquote operator.

```{r}
paste("Good", time, name)
cement(Good, !!time, !!name)
```
## 19.2.1: Vocabulary

Evaluated argument: obeys R's evaluation rules
Quoted argument: captured by function, processed in custom ways.

Ex. `paste()` evaluates all arguments, `cement()` quotes all arguments.


### exercise

1.

```{r}
library(MASS) # package name quoted
mtcars2 <- subset(mtcars, cyl == 4) ## cyl quoted, mtcars evaluated
with(mtcars2, sum(vs))  ##  mtcars2 evaluated, sum(vs) quoted
sum(mtcars2$am) ## am quoted by `$()`, mtcars$am evaluated
rm(mtcars2)    ## mtcars2 quoted
```


2.




## 19.3 Quoting

### 19.3.1: Capturing expressions

`expr()`: captures argument as provided

```{r}
expr(x + y)
expr( 1 / 2 /3)
```

Not useful inside a function:

```{r}
f1 <- function(x) expr(x)
f1(a + b + c)
```

`enexpr()`: Captures what caller supplied to function by looking at internal promise object that powers lazy evaluation.

`enexprs()`: For all arguments inside `...`

```{r}
f2 <- function(x) enexpr(x)
f2(a + b + c)

f <- function(...) enexprs(...)
f(x = 1, y = 10 * z)
```

`exprs()`: list of expressions

```{r}
exprs(x = x ^ 2, y = y ^ 3, z = z ^ 4)
```

USER supplied expressions: `enexpr() | enexprs()`
DEVELOPER supplied expressions: `expr() | exprs()`

### 19.3.2: Capturing symbols

`ensym() | ensyms()`: User to specify variable name > arbitrary expression. Variants of `enexpr() | enexprs()` that check captured expressions for symbol or string. Error if else.

```{r}
f <- function(...) ensyms(...)

f(x)
f("x")
```


### 19.3.3: Base R

Base do not support unquoting. 

`quote()` == `expr()`

```{r}
quote(x + y)
```


`substitute()` == `enexpr()`

```{r}
f3 <- function(x) substitute(x)
f3(x + y)
```

`alist()` == `exprs()`

```{r}
alist(x = 1, y = x + 2)
```
`substitute()` == `enexprs()`

```{r}
f <- function(...) as.list(substitute(...()))
f(x = 1, y = 10 * z)
```

`bquote()`: limited form of quasiquotation

`~`: formula - quoting function that also captures environment.

### 19.3.4: Substitution

`substitute()` used for capturing unevaluated arguments. Can also substitute symbols defined in current environment for expressions. Provide clarity on intent.

```{r}
f4 <- function(x) substitute(x * 2)
f4(a + b + c)

substitute(x * y * z, list(x = 10, y = quote(a + b)))
```

### 19.3.5: Summary 

Quoting:
- Supplied by DEVELOPER or USER? 
-- Fixed: supplied in body of function
-- Varying: supplied via an argument

- Capture single or multiple expressions?

### exercise

1.

2.


```{r}
## return arguments defined WITHIN body of `f1()`
f1 <- function(x, y) {
  exprs(x = x, y = y)
}

f1(a + b, c + d) # x, y

## return arguments supplied to `f2()`
f2 <- function(x, y) {
  enexprs(x = x, y = y)
}

f2(a + b, c + d) # a + b      c + d
```




3.


4.

5.

6.


## 19.4 Unquoting

Unquoting: selectively evaluate parts of expression >>> merge ASTs using a template AST. 

Evaluate code inside `expr()` >> `expr(!!x)` == `x`

### 19.4.1: Unquoting 1 argument

`!!`: unquote single argument in a function call. Single expression input, evaluates it, inline result in AST. WOrk with symbols and constants.

```{r}
x <- expr(-1)
expr(f(!!x, y))

a <- sym("y")
b <- 1
expr(f(!!a, !!b))
```

IF right side of `!!` is a function call >>> evaluate and insert results.

```{r}
mean_rm <- function(var) {
  var <- ensym(var)
  expr(mean(!!var, na.rm = TRUE))
}

expr(!!mean_rm(x) + !!mean_rm(y))
expr(mean_rm(x))
```

`!!` preservces operator precedence:

```{r}
x1 <- expr(x + 1)
x2 <- expr(x + 2)

expr(!!x1 / !!x2)
```

### 19.4.2: Unquoting a function

Use `!!` to replace functions.

```{r}
f <- expr(foo)
expr((!!f)(x, y))
expr(!!f(x, y)) ## unquotes result of f(x, y) first!

f <- expr(pkg::foo)
expr((!!f)(x, y))

## use `call2()` instead to avoid parentheses hell
f <- expr(pkg::foo)
call2(f, expr(x), expr(y))
```

### 19.4.3: Unquoting missing argument

Use `rlang::maybe_missing()`:

```{r}
arg <- missing_arg()
expr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))
```

### 19.4.4: Unquoting special forms

`$` cause syntax error wit hunquoting. `$` must always be followed by name of a variable NOT an expression. Use prefix form '`$`()'.

```{r}
expr(df$!!x)

x <- expr(x)
expr(`$`(df, !!x))
```

### 19.4.5: Unquoting many arguments

`!!!` (unquote-splice): one-to-many replacement. List of expressions and inserts at location of `!!!`. Can be used in any rlang function with `...` quoted OR evaluated.

```{r}
xs <- exprs(1, a, -b)
expr(f(!!!xs, y))

ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
```


### 19.4.6: `!!`

Repeated application of `!`

```{r}
!TRUE
!!TRUE
!!!TRUE
```

Behave as operators on precedence level of `+` and `-`. If misused, can get silent errors. 


For actual double negation use `!(!x)`, parentheses.

### 19.4.7: Non-standard ASTs

Unquoting can lead to non-standard ASTs >>> ASTs with components that are NOT expressions. 

Inline compelx objects >>> attributes NOT printed.
- Use `rlang::expr_print()` and `lobstr::ast()`

```{r}
x1 <- expr(class(!!data.frame(x = 10)))
x1
eval(x1)

expr_print(x1)
lobstr::ast(!!x1)
```


### exercise 


1.




2.


## 19.5 Non-quoting

Base R: uses `bquote()` for quasiquotation. `.()` for unquoting.

```{r}
xyz <- bquote((x + y + z))
bquote(-.(xyz) / 2)
```

Limitations:
- Only easily used for own code, hard to apply to code supplied by user.
- No unquote-splice operator for multiple expressions in a list
- Inability to handle code within environment

Base R prefers to selectively turn quoting off rather than unquoting.

1. A pair of quoting and non-quoting functions. Refer to variable indirectly via `[[` for name of variable as a string instead. 

```{r}
x <- list(var = 1, y = 2)
var <- "y"

x$var
x[[var]]
```


2. Pair of quoting and non-quoting arguments. 
Ex. `rm()`: provide bare variables names in `...` or char vec of variable names in `list()`

```{r}
x <- 1
rm(x)

y <- 2
vars <- c("y", "vars")
rm(list = vars)
```


3. Argument control arguments that are quoting vs. non-quoting.
Ex. `library()`: 'character.only' argument controls quoting behavior of first argument 'package'. Similarly in `demo()`, `detach()`, `example()`, `require()`.

```{r}
library(MASS)

pkg <- "MASS"
library(pkg, character.only = TRUE)
```


4. Quoting if evaluation fails. 

Ex. `help()`: first argument non-quoting if evaluate to string, if fail then quoted. Similar with `ls()`, `page()`, `match.fun()`.

```{r}
help(var)

var <- "mean"
help(var)

var <- 10
help(var)
```

Base modelling + plotting functions use NSE.

Ex. `lm()` quotes 'weight' and subset' arguments.
`plot()` quotes aesthetic arguments when using a formula. 

```{r}
plot(
  Sepal.Length ~ Petal.Length,
  data = iris,
  col = Species, # instead of col = iris$Species 
  pch = 20,
  cex = 2
)
```


## 19.6 `...`

`!!!`: useful as can have list of expressions to insert into a call. 

Ex. 1: Elements in `...` stored in list. List of data frames to bind together?

```{r}
dfs <- list(
  a = data.frame(x = 1, y = 2),
  b = data.frame(x = 3, y = 4)
)
```

Could specify `dfs$a` and `dfs$b` but what about lists of arbitrary lengths?

```{r}
dplyr::bind_rows(!!!dfs)
```

"spatting" or "argument unpacking".

Ex. 2: Supply argument name indirectly. Create single col df where column name is specified in variable. 

```{r}
var <- "x"
val <- c(4, 3, 9)
```

Create df and then change names via `setNames(data.frame(val), var)`?

Unquote left side of `=` to interpret 'var' literally, use value stored inside 'var' variable.

```{r}
tibble::tibble(!!var := val)
```

Need use `:=` as R can not have expressions as argument names. Used in {data.table} as well.

### 19.6.1: Examples

Tidy dots: use `list2()`.

Ex. create wrapper around `attributes()` to set attributes flexibly. 

```{r}
set_attr <- function(.x, ...) {
  attr <- rlang::list2(...)
  attributes(.x) <- attr
  .x
}

attrs <- list(x = 1, y = 2)
attr_name <- "z"

1:10 %>% 
  set_attr(w = 0, !!!attrs, !!attr_name := 3) %>% 
  str()
```

## 19.6.2: `exec()`

For functions without tidy dots use `exec()`. Supply arguments directly in `...` or indirectly via a list.

```{r}
exec("mean", x = 1:10, na.rm = TRUE, trim = 0.1)

args <- list(x = 1:10, na.rm = TRUE, trim = 0.1)
exec("mean", !!!args)

params <- list(na.rm = TRUE, trim = 0.1)
exec("mean", x = 1:10, !!!params)
```

Supply argument names indirectly:

```{r}
arg_name <- "na.rm" 
arg_val <- TRUE
exec("mean", 1:10, !!arg_name := arg_val)
```

Vector of function names or list of functions with same arguments:

```{r}
x <- c(runif(10), NA)
funs <- c("mean", "median", "sd")

purrr::map_dbl(funs, exec, x, na.rm = TRUE)
```

`exec()` evaluates expression vs. `call2()` returns an expression


### 19.6.3: `dots_list()`

`list2()`: default ignore empty arguments. Change order of variables without worrying about final `,`. 

`list2()`: wrapper around `rlang::dots_list()` with defaults. Call `dots_list()` directly for more control over settings. 

* `.ignore_empty` allows you to control exactly which arguments are ignored. The default ignores a single trailing argument to get the behaviour described above, but you can choose to ignore all missing arguments, or no missing arguments.

* `.homonyms` controls what happens if multiple arguments use the same name:

* If there are empty arguments that are not ignored, `.preserve_empty` controls what to do with them. The default throws an error; setting `.preserve_empty = TRUE` instead returns missing symbols. This is useful if you’re using `dots_list()` to generate function calls.

### 19.6.4: Base R 

`do.call()`: 

'what': give function to call
'args': list of arguments to pass to function. 

Ex. `do.call("f", list(x, y, z))` == `f(x, y, z)`

```{r}
do.call("rbind", dfs)

args <- list(val)
names(args) <- var 

do.call("data.frame", args)
```


Some base functions avoid `do.call()` by taking components of list or taking both `...` and `.dots` and concatenate together.

### exercise 


1.

exec() takes a function and its arguments as input, as well as an environment. This allows to construct a call from the function and the arguments and evaluate it in the supplied environment. As the ... argument is handled via list2(), exec() supports tidy dots (quasiquotation), which means that arguments and names (on the left-hand-side of :=) can be unquoted via !! and !!!.



2.


3.


set_attr() expects an object to be passed as the x argument and its new attributes via the dots. Unfortunately, this prohibits us to provide attributes named x as these would collide with the argument name of our object. Even omitting the object’s argument name doesn’t help in this case - as can be seen in the example where the object is consequently treated as an unnamed attribute.

However, we may name the first argument .x, which seems clearer and less likely to invoke errors. In this case 1:10 will get the (named) attribute x = 10 assigned:



## 19.7 Case studies

### 19.7.1: `lobstr::ast()`

```{r}
z <- expr(foo(x, y))
lobstr::ast(z)

## use !!
lobstr::ast(!!z)
```


### 19.7.2: Map-reduce to generate code

Linear model with coefficients:

```{r}
intercept <- 10
coefs <- c(x1 = 5, x2 = -4)
```

Turn character names vector in a list of symbols >>> `rlang::syms()`

```{r}
coef_sym <- syms(names(coefs))
coef_sym
```

COmbine each variable name with coefficient. Add intercept to summands vector.

```{r}
summands <- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))
summands

summands <- c(intercept, summands)
summands
```

Reduce individual terms to a single sum:

```{r}
eq <- reduce(summands, ~ expr(!!.x + !!.y))
eq
```

Function:

```{r}
linear <- function(var, val) {
  var <- ensym(var)
  coef_name <- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))
  
  summands <- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))
  summands <- c(val[[1]], summands)
  
  reduce(summands, ~ expr(!!.x + !!.y))
}

linear(x, c(10, 5, -4))

linear(xy, c(10, 5, -4))

linear(coefthingy, c(10, 5, -4))
```

### 19.7.3: Slicing an array

Extract slice of an array using a dimension and index.

Generate call with multiple missing arguments. 

```{r}
indices <- rep(list(missing_arg()), 3)
expr(x[!!!indices])

indices[[2]] <- 1
expr(x[!!!indices])

slice <- function(x, along, index) {
  stopifnot(length(along) == 1)
  stopifnot(length(index) == 1)
    
  nd <- length(dim(x))
  indices <- rep(list(missing_arg()), nd)
  indices[[along]] <- index
  
  expr(x[!!!indices])
}

x <- array(sample(30), c(5, 2, 3))
slice(x, 1, 3)
#> x[3, , ]
slice(x, 2, 2)
#> x[, 2, ]
slice(x, 3, 1)
#> x[, , 1]
```



### 19.7.4: Creating functions

Create function from components >>> arguments, body, environment

```{r}
new_function(
  exprs(x = , y = ),
  expr({x + y})
)
```

Empty arguments in `exprs()` generate arguments with NO defaults.

Alternative to function factories with scalar/symbol arguments. 

Ex. Generate function to raise function to a power of a number:

```{r}
power <- function(exponent) {
  new_function(
    exprs(x = ),
    expr({
      x ^ !!exponent
    }),
    caller_env()
  )
}

power(0.5)
```

`graphics::curve()`: plot mathematical expressions without creating a function.

```{r}
curve(sin(exp(4 * x)), n = 1000)
```


`x`: pronoun, NOT represent a single concrete value. A placeholder that varies over the range of the plot. 

Turn expression into a function with single argument `x`.

```{r}
curve2 <- function(expr, xlim = c(0, 1), n = 100) {
  expr <- enexpr(expr)
  f <- new_function(exprs(x = ), expr)
  
  x <- seq(xlim[1], xlim[2], length = n)
  y <- f(x)

  plot(x, y, type = "l", ylab = expr_text(expr))
}
curve2(sin(exp(4 * x)), n = 1000)
```


### exercise


1.


2.


3.






# 20 Evaluation

User: inverse of quotation = unquotation, give user the ability to selectively evaluate parts of an otherwise quoted argument

Developer: complement of quotation = evaluation, give developer ability to evaluate quoted expressions in custom environment to achieve specific goals

Quosure: data structure that captures expression along with environment >> found in function arguments.

Data mask: Ability to easily evaluate expression in context of data frame. 

TIdy evaluation: Approach to NSE to use functions interactively AND inside other functions.

## 20.2 Evaluation basics

`eval()`

- 'expr': object to evaluate, symbol or expression. use with `expr()`. Evaluated and NOT quoted. 

```{r}
x <- 10
eval(expr(x))

y <- 2
eval(expr(x + y))
```

- 'env': environment in which expression should be evaluated. Default = current environment.

```{r}
eval(expr(x + y), env(x = 1000))
```

### 20.2.1: Application `local()`

After creation of intermediate variables, remove somehow. Use `rm()` or use `local()`.

```{r}
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  
  x + y 
})

foo

x

y
```

`local()`: captures input expression, creates new "local" environment for evaluation. Emulates running `epxr()` as though inside a function. 

```{r}
local2 <- function(expr) {
  env <- env(caller_env())
  eval(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y 
})

foo;x;y
```


`base::local()`: complicated as uses `eval()` and `substitute()` together. 

### 20.2.2: Application `source()`

Read in file from disk, use `parse_expr()` to parse string into a list of expressions, use `eval()` to evaluate each element in turn. 

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}
```

### 20.2.3: `function()`

If available functions print 'srcref' attribute, which doesn't know quasiquotation so returns evaluated value of code in `f`. Use `new_function()` or remove 'srcref' attribute to avoid problem. 

```{r}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))

f
f()
```

### exercise 


1.



2.


3.


4.



5.

## 20.3 Quosures

Quosure: `eval()` needs both expression AND environment. Necessitate data structure to hold both. Quosure object contains expression AND environment. Quotes expression and encloses the environment. 

### 20.3.1: Creating 

- `enquo() | enquos()`: capture user-supplied expressions

```{r}
foo <- function(x) enquo(x)

foo(a + b)
```

- `quo() | quos()`: match `expr() | exprs()`. `expr()` or careful unquoting may be more correct.

```{r}
quo(x + y + z)
```

- `new_quosure()`: Create quosure from expressio nand environment components.

```{r}
new_quosure(expr(x + y), env(x = 1, y = 10))
```

### 20.3.2: Evaluating 

`eval_tidy()`: evaluation function, input of single quosure. 

```{r}
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))

eval_tidy(q1)

eval(get_expr(q1), get_env(q2))
```

### 20.3.3: Dots

Possible for arguments to `...` be associated with different environment. 

Ex. Quosures with 'x' expression but in different environments

```{r}
f <- function(...) {
  x <- 1
  g(..., f = x)
}

g <- function(...) {
  enquos(...)
}

x <- 0
qs <- f(global = x)
qs

map_dbl(qs, eval_tidy)
```

### 20.3.4: Under the hood

Formulas: capture expression and environment. 

```{r}
f <- ~runif(3)
str(f)
```
Quosures are subclass of formulas. Quosures are call objects with attribute taht stores environment. 

```{r}
q4 <- new_quosure(expr(x + y + z))
class(q4)
is_call(q4)
attr(q4, ".Environment")

get_expr(q4)
get_env(q4)
```

Use `get_expr()` and `get_env()` to extract expression or environment. 

### 20.3.5: Nested quosures 

Use quasiquotation to embed quosure in expression.

Ex. inlines 2 quosures into an expression

```{r}
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))

x <- expr(!!q2 + !!q3)

eval_tidy(x)
x
expr_print(x) ## quosures colored according to environment
```

### exercise 

```{r}
q1 <- new_quosure(expr(x), env(x = 1))
q1
#> <quosure>
#> expr: ^x
#> env:  0x5fec4f8

q2 <- new_quosure(expr(x + !!q1), env(x = 10))
q2
#> <quosure>
#> expr: ^x + (^x)
#> env:  0x66c6948

q3 <- new_quosure(expr(x + !!q2), env(x = 100))
q3

expr_print(q3)
```

## 20.4: Data masks 

Data mask: data frame where evaluated code will look first for variable definitions. 

Ex. `with() | subset() | transform()`, used in {dplyr}, {ggplot2}

### 20.4.1: Basics 

Data mask: mingle variables from environment and data frame in a single expression. Supply as 2nd argument to `eval_tidy()`.

```{r}
q1 <- new_quosure(expr(x * y), env(x = 100))
df <- data.frame(y = 1:10)

eval_tidy(q1, df)
```

```{r}
with2 <- function(data, expr) { 
  expr <- enquo(expr)
  eval_tidy(expr, data)
}
```

```{r}
x <- 100
with2(df, x * y)
```

Base R: 

```{r}
with3 <- function(data, expr) {
  expr <- substitute(expr)
  eval(expr, data, caller_env())
}
```


### 20.4.2: Pronouns

Data masks introduce ambiguity. Don't know if 'x' from data mask OR the environment.

```{r}
with2(df, x)
```

`.data`: always refer to 'x' in data mask

`.env`: always refer to 'x' in environment

```{r}
x <- 1 
df <- data.frame(x = 2)

with2(df, .data$x)
with2(df, .env$x)
```

Subset with `[[`.


### 20.4.3: Application `subset()`

Select rows of data frame ~ `dplyr::filter()`. Data + expression evaluated in context of data to filter. DOn't have to refer to `df$x` `df$y` every time.

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))

# Shorthand for sample_df[sample_df$a >= 4, ]
subset(sample_df, a >= 4)
#>   a b c
#> 4 4 2 4
#> 5 5 1 1

# Shorthand for sample_df[sample_df$b == sample_df$c, ]
subset(sample_df, b == c)
```

`subset2()`: data frame 'data' and expression 'rows' arguments. 'rows' evaluated using 'data' as data mask. Use results to subbset the data frame with `[`.

```{r}
subset2 <- function(data, rows) {
  rows <- enquo(rows)
  rows_val <- eval_tidy(rows, data)
  stopifnot(is.logical(rows_val))
  
  data[rows_val, , drop = FALSE]
}

subset2(sample_df, b == c)
```


### 20.4.4: Application `transform()`


`base::transform()`: add new variables to dataframe. Evaluate expressions in context of existing variables. 

```{r}
df <- data.frame(x = c(2, 3, 1), y = runif(3))
transform(df, x = -x, y2 = 2 * y)
```


`transform2()`: Capture unevaluated `...` with `enquos(...)`. Evaluate each expression with `for` loop. 

```{r}
transform2 <- function(.data, ...) {
  dots <- enquos(...)

  for (i in seq_along(dots)) {
    name <- names(dots)[[i]]
    dot <- dots[[i]]

    .data[[name]] <- eval_tidy(dot, .data)
  }

  .data
}

transform2(df, x2 = x * 2, y = -y)
```


### 20.4.5: Application `select()`


Data mask ~ data frame but useful to provide a list. 'select' argument in `base::subset()`. Refer to variables as if they were numbers.

```{r}
df <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)
subset(df, select = b:d)
```

Create named list where each component gives position of corresponding variable. 

```{r}
vars <- as.list(set_names(seq_along(df), names(df)))

seq_along(df)
names(df)

str(vars)
```


### exercise 

1.


A for loop applies the processing steps regarding .data iteratively. This includes updating .data and reusing the same variable names. This makes it possible to apply transformations sequentially, so that subsequent transformations can refer to columns that were just created.

2. 


3. 


```{r}
arrange2 <- function(.df, ..., .na.last = TRUE) {
  browser()
  # Capture and quote arguments, which determine the order
  args <- enquos(...)  
  
  # `!!!`: unquote-splice arguments into order()
  # `!!.na.last`: pass option for treatment of NAs to order()
  # return expression-object
  order_call <- expr(order(!!!args, na.last = !!.na.last))
  
  # Evaluate order_call within .df
  ord <- eval_tidy(order_call, .df)    
  # Ensure that no rows are dropped
  stopifnot(length(ord) == nrow(.df))  
  
  # Reorder rows via integer subsetting
  .df[ord, , drop = FALSE]  
}

arrange2(mtcars, cyl)
```

## 20.5 Using tidy evaluation

### 20.5.1: Quoting & unquoting

```{r}
resample <- function(df, n) {
  idx <- sample(nrow(df), n, replace = TRUE)
  df[idx, , drop = FALSE]
}
```

Create function resample and subset in single step.

Below NOT work as `subsample()` not quote arguments so `cond` is evaluated normally, error when try find binding for `x`. 

```{r}
subsample <- function(df, cond, n = nrow(df)) {
  df <- subset2(df, cond)
  resample(df, n)
}

df <- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)
subsample(df, x == 1)
```

Need to quote `cond`, then unquote when pass to `suset2()`. 

```{r}
subsample <- function(df, cond, n = nrow(df)) {
  cond <- enquo(cond)
  
  df <- subset2(df, !!cond)
  resample(df, n)
}

subsample(df, x == 1)
```

### 20.5.2: Handling ambiguity

```{r}
threshold_x <- function(df, val) {
  subset2(df, x >= val)
}
```

Return incorrect silently when `x` exists in calling environment but not in `df`:

```{r}
x <- 10 
no_x <- data.frame(y = 1:3)

threshold_x(no_x, 2)
```

Also if `val` exists in `df`:

```{r}
has_val <- data.frame(x = 1:3, val = 9:11)
threshold_x(has_val, 2)
```

Fail as tidy  evaluation is ambiguous, each variable can be found in either data mask OR environment. Remove ambiguity with `.data` and `.env` pronouns.

```{r}
threshold_x <- function(df, val) {
  subset2(df, .data$x >= .env$val)
}

x <- 10
threshold_x(no_x, 2)
threshold_x(has_val, 2)
```

Or use unquoting:

```{r}
threshold_x <- function(df, val) {
  subset2(df, .data$x >= !!val)
}
```

If unquote, `val` early evaluated by `enquo()`. If pronoun, `val` lazy evaluated by `eval_tidy()`. 


### 20.5.3: Quoting and ambiguity

```{r}
threshold_var <- function(df, var, val) {
  var <- as_string(ensym(var))
  subset2(df, .data[[var]] >= !!val)
}

df <- data.frame(x = 1:10)
threshold_var(df, x, 8)

threshold_expr <- function(df, expr, val) {
  expr <- enquo(expr)
  subset2(df, !!expr >= !!val)
}
```

It’s not possible to evaluate expr only in the data mask, because the data mask doesn’t include any functions like + or ==. Here, it’s the user’s responsibility to avoid ambiguity. As a general rule of thumb, as a function author it’s your responsibility to avoid ambiguity with any expressions that you create; it’s the user’s responsibility to avoid ambiguity in expressions that they create.

### exercise

We can see, that threshold_var2() no longer coerces the symbol to a string. Therefore `$` instead of [[ can be used for subsetting. Initially we suspected partial matching would be introduced by `$`, but .data deliberately avoids this problem.

The prefix call to `$()` is less common than infix-subsetting using `[[`, but ultimately both functions behave the same.


## 20.6 Base Evaluation

* `substitute()`: and evaluation in caller environment. ex: `subset()`. 

* `match.call()`: call manipulation, evaluation in caller environment. ex: `write.csv()`, `lm()`. 


### 20.6.1: `substitute()`

`substitute()` + `eval()`: most common form of NSE in base R. 

`subset_base()`: argument evaluated in caller environment.
`subset_tidy()`: argument evaluated in environment where defined.

```{r}
subset_base <- function(data, rows) {
  rows <- substitute(rows)
  rows_val <- eval(rows, data, caller_env())
  stopifnot(is.logical(rows_val))

  data[rows_val, , drop = FALSE]
}

subset_tidy <- function(data, rows) {
  rows <- enquo(rows)
  rows_val <- eval_tidy(rows, data)
  stopifnot(is.logical(rows_val))

  data[rows_val, , drop = FALSE]
}
```


### 20.6.1.1: Programming with `subset()`

* `base::subset()`: always evaluates rows in calling environment, but if `...` used, then expression might need to be evaluated elsewhere.

```{r}
f1 <- function(df, ...) {
  xval <- 3
  subset_base(df, ...)
}

my_df <- data.frame(x = 1:3, y = 3:1)
xval <- 1
f1(my_df, x == xval)
```

`subset_base()` can NOT work with functionals >>> `map()` or `lapply()`:

```{r}
local({
  zzz <- 2
  dfs <- list(data.frame(x = 1:3), data.frame(x = 4:6))
  lapply(dfs, subset_base, x == zzz)
})
```

* `subset()`: calling from another function requires care, need use `substitute()` to capture call to `subset()` complete expression and then evaluate. No syntactic marker for unquoting in `substitute()`. 

```{r}
f2 <- function(df1, expr) {
  call <- substitute(subset_base(df1, expr))
  expr_print(call)
  eval(call, caller_env())
}

my_df <- data.frame(x = 1:3, y = 3:1)
f2(my_df, x == 1)
```


* `eval()` does NOT provide pronouns so no way to require part of expression to come from data. Need manually check for presence of `z` in `df`.

```{r}
f3 <- function(df) {
  call <- substitute(subset_base(df, z > 0))
  expr_print(call)
  eval(call, caller_env())
}

my_df <- data.frame(x = 1:3, y = 3:1)
z <- -1
f3(my_df)
```

### `[`


`subset()` > `[`

* `drop = FALSE` by default, always guaranteed to return data frame
* drop rows where condition evaluates to NA

`subset(df, x == y) != df[x == y, ]`

`df[x == y & !is.na(x == y), , drop = FALSE]`

### 20.6.2: `match.call()`

Capture complete  call with `match.call()`, modify, evaluate result. 

```{r}
g <- function(x, y, z) {
  match.call()
}
g(1, 2, z = 3)
```

```{r}
write.csv <- function(...) {
  call <- match.call(write.table, expand.dots = TRUE)

  call[[1]] <- quote(write.table)
  call$sep <- ","
  call$dec <- "."

  eval(call, parent.frame())
}

write.csv <- function(...) {
  write.table(..., sep = ",", dec = ".")
}
```

### 20.6.2.1: Wrapping modelling functions

```{r}
lm2 <- function(formula, data) {
  lm(formula, data)
}

lm2(mpg ~ disp, mtcars)
```

Suboptimal: `lm()` captures call and display when printing. Need to capture arguments, create call to `lm()` with unquoting, evaluate call. 


```{r}
lm3 <- function(formula, data, env = caller_env()) {
  formula <- enexpr(formula)
  data <- enexpr(data)

  lm_call <- expr(lm(!!formula, data = !!data))
  expr_print(lm_call)
  eval(lm_call, env)
}

lm3(mpg ~ disp, mtcars)
```

Wrapping base NSE function:

* Capture unevaluated arguments using `enexpr()`, capture caller environment using `caller_env()`.
* Generate new expression using `expr()` and unquoting
* Evaluate expression in caller environment. Arguments need to be defined in caller environment. `env` argument for setting default environment yourself.

Use `enxpr()` for unquoting to generate formulas dynamically: 

```{r}
resp <- expr(mpg)
disp1 <- expr(vs)
disp2 <- expr(wt)
lm3(!!resp ~ !!disp1 + !!disp2, mtcars)
```


### 20.6.2.2: Evaluation environment

Mingle objects supplied by user with objects created inside function. 

Auto-resampling `lm()`:

```{r}
resample_lm0 <- function(formula, data, env = caller_env()) {
  formula <- enexpr(formula)
  resample_data <- resample(data, n = nrow(data))

  lm_call <- expr(lm(!!formula, data = resample_data))
  expr_print(lm_call)
  eval(lm_call, env)
}

df <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))
resample_lm0(y ~ x, data = df)
```

NOT work as evaluating `lm_call` in caller environment but `resample_data` exists in execution environment. 

1. Unquote data frame into call. Inlining expressions. 

```{r}
resample_lm1 <- function(formula, data, env = caller_env()) {
  formula <- enexpr(formula)
  resample_data <- resample(data, n = nrow(data))

  lm_call <- expr(lm(!!formula, data = !!resample_data))
  expr_print(lm_call)
  eval(lm_call, env)
}
resample_lm1(y ~ x, data = df)$call
```

2. Create new environment that inherits from caller, bind vars that created inside function to that environment.

```{r}
resample_lm2 <- function(formula, data, env = caller_env()) {
  formula <- enexpr(formula)
  resample_data <- resample(data, n = nrow(data))

  lm_env <- env(env, resample_data = resample_data)
  lm_call <- expr(lm(!!formula, data = resample_data))
  expr_print(lm_call)
  eval(lm_call, lm_env)
}
resample_lm2(y ~ x, data = df)
```


### exercise

1.

```{r}
lm3a <- function(formula, data) {
  formula <- enexpr(formula)
  
  lm_call <- expr(lm(!!formula, data = data))
  eval(lm_call, caller_env())
}
lm3a(mpg ~ disp, mtcars)$call
```

In this function, lm_call is evaluated in the caller environment, which happens to be the global environment. In this environment, the name data is bound to utils::data. To fix the error, we can either set the evaluation environment to the functions execution environment or unquote the data argument when building the call to lm().

```{r}
# Change evaluation environment
lm3b <- function(formula, data) {
  formula <- enexpr(formula)
  
  lm_call <- expr(lm(!!formula, data = data))
  eval(lm_call, current_env())
}

lm3b(mpg ~ disp, mtcars)$call
```

When we want to unquote an argument within a function, we first need to capture the user-input (by enenxpr()).

```{r}
lm3c <- function(formula, data) {
  formula <- enexpr(formula)
  data_quo <- enexpr(data)
  
  lm_call <- expr(lm(!!formula, data = !!data_quo))
  eval(lm_call, caller_env())
}
lm3c(mpg ~ disp, mtcars)$call
```



2.


```{r}
lm(mpg ~ disp, data = mtcars)
lm(mpg ~ I(1 / disp), data = mtcars)
lm(mpg ~ disp * cyl, data = mtcars)
```




```{r}
lm_wrap <- function(pred, resp = mpg, data = mtcars, env = caller_env()) {
  pred <- enexpr(pred)
  resp <- enexpr(resp)
  data <- enexpr(data)
  
  formula <- expr(!!resp ~ !!pred)
  lm_call <- expr(lm(!!formula, data = !!data))
  eval(lm_call, envir = env)
}

# Test if the output looks ok
lm_wrap(I(1 / disp) + disp * cyl)
#> 
#> Call:
#> lm(formula = mpg ~ I(1/disp) + disp * cyl, data = mtcars)
#> 
#> Coefficients:
#> (Intercept)    I(1/disp)         disp          cyl     disp:cyl  
#>   -1.22e+00     1.85e+03     7.68e-02     1.18e+00    -9.14e-03

# Test if the result is identical to calling lm() directly
identical(
  lm_wrap(I(1 / disp) + disp * cyl),
  lm(mpg ~ I(1 / disp) + disp * cyl, data = mtcars)
)
```


3.

```{r}
resample_lm0 <- function(
  formula, data,
  resample_data = data[sample(nrow(data), replace = TRUE), ,
                       drop = FALSE],
  env = current_env()
) {
  formula <- enexpr(formula)
  
  lm_call <- expr(lm(!!formula, data = resample_data))
  expr_print(lm_call)
  eval(lm_call, env)
}

df <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))
(resamp_lm1 <- resample_lm0(y ~ x, data = df))
#> lm(y ~ x, data = resample_data)
#> 
#> Call:
#> lm(formula = y ~ x, data = resample_data)
#> 
#> Coefficients:
#> (Intercept)            x  
#>        4.85         3.02
resamp_lm1$call
```

# 21 Translating R code

## 21.2 HTML

Tags: coding structure, nested, intermingled with text.

Ex. body, h1, p, b, img

Attributes: 'id', 'class' for control visual appearance with CSS

Void tags: No children, no content, attributes >>> img: src, width, height

< >: Escape via `&gt`, `&lt`

&: `&amp;`

### 21.2.1: Goal


Generate HTML from R.

```{html}
<body>
  <h1 id='first'>A heading</h1>
  <p>Some text &amp; <b>some bold text.</b></p>
  <img src='myimg.png' width='100' height='100' />
</body>
```

```{r}
with_html(
  body(
    h1("A heading", id = "first"),
    p("Some text &", b("some bold text.")),
    img(src = "myimg.png", width = 100, height = 100)
  )
)
```

* Nesting of function calls match nesting of tags
* Unnamed args become content of tag, named args become arguments
* Auto escape `&` and other special characters

### 21.2.2: Escaping

Need to automatically escape user input for `&`, `<`, `>`.

Generated special characters are not double-escaped.

Create S3 class distinguishing regular text vs. HTML.

```{r}
html <- function(x) structure(x, class = "advr_html")

print.advr_html <- function(x, ...) {
  out <- paste0("<HTML> ", x)
  cat(paste(strwrap(out), collapse = "\n"), "\n", sep = "")
}
```

Escape generic function:
* `escape.character()`: regular char vec and return HTML vec with special char escaped.
* `escape.adv_html()`: leaves already escaped HTML alone.

```{r}
escape <- function(x) UseMethod("escape")

escape.character <- function(x) {
  x <- gsub("&", "&amp;", x)
  x <- gsub("<", "&lt;", x)
  x <- gsub(">", "&gt;", x)

  html(x)
}

escape.advr_html <- function(x) x
```


```{r}
escape("This is some text.")
#> <HTML> This is some text.
escape("x > 1 & y < 2")
#> <HTML> x &gt; 1 &amp; y &lt; 2

# Double escaping is not a problem
escape(escape("This is some text. 1 > 2"))
#> <HTML> This is some text. 1 &gt; 2

# And text we know is HTML doesn't get escaped.
escape(html("<hr />"))
#> <HTML> <hr />
```

### 21.2.3: Basic tag functions

HTML tags can have attributes and children. For function call, need to separate. Use named vs. unnamed args to separate.

```{r}
p("Some text. ", b(i("some bold italic text")), class = "mypara")
```

Separate using `...`, whether they are /not named.

```{r}
dots_partition <- function(...) {
  dots <- list2(...)
  
 if (is.null(names(dots))) {
  is_named <- rep(FALSE, length(dots))
} else {
  is_named <- names(dots) != ""
}
  
  list(
    named = dots[is_named],
    unnamed = dots[!is_named]
  )
}

str(dots_partition(a = 1, 2, b = 3, 4))
#> List of 2
#>  $ named  :List of 2
#>   ..$ a: num 1
#>   ..$ b: num 3
#>  $ unnamed:List of 2
#>   ..$ : num 2
#>   ..$ : num 4
```

Create `p()` function. 

`html_attributes()`: takes named list and returns HTML attribute specification as string. 


```{r}
source("dsl-html-attributes.r")
p <- function(...) {
  dots <- dots_partition(...)
  attribs <- html_attributes(dots$named)
  children <- map_chr(dots$unnamed, escape)

  html(paste0(
    "<p", attribs, ">",
    paste(children, collapse = ""),
    "</p>"
  ))
}

p("Some text")
#> <HTML> <p>Some text</p>
p("Some text", id = "myid")
#> <HTML> <p id='myid'>Some text</p>
p("Some text", class = "important", `data-value` = 10)
#> <HTML> <p class='important' data-value='10'>Some text</p>
```

### 21.2.4: Tag functions

Adapt `p()` to other tags. Replace "p" with name. Create function with `rlang::new_function()`. Use unquoting and `paste0()` to generate start/end tags.

```{r}
tag <- function(tag) {
  new_function(
    exprs(... = ),
    expr({
      dots <- dots_partition(...)
      attribs <- html_attributes(dots$named)
      children <- map_chr(dots$unnamed, escape)

      html(paste0(
        !!paste0("<", tag), attribs, ">",
        paste(children, collapse = ""),
        !!paste0("</", tag, ">")
      ))
    }),
    caller_env()
  )
}
tag("b")
#> function (...) 
#> {
#>     dots <- dots_partition(...)
#>     attribs <- html_attributes(dots$named)
#>     children <- map_chr(dots$unnamed, escape)
#>     html(paste0("<b", attribs, ">", paste(children, collapse = ""), 
#>         "</b>"))
#> }

p <- tag("p")
b <- tag("b")
i <- tag("i")
p("Some text. ", b(i("some bold italic text")), class = "mypara")
#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic
#> text</i></b></p>
```


Handler for void tags. `void_tag()`.

```{r}
void_tag <- function(tag) {
  new_function(
    exprs(... = ),
    expr({
      dots <- dots_partition(...)
      if (length(dots$unnamed) > 0) {
        abort(!!paste0("<", tag, "> must not have unnamed arguments"))
      }
      attribs <- html_attributes(dots$named)

      html(paste0(!!paste0("<", tag), attribs, " />"))
    }),
    caller_env()
  )
}

img <- void_tag("img")
img
#> function (...) 
#> {
#>     dots <- dots_partition(...)
#>     if (length(dots$unnamed) > 0) {
#>         abort("<img> must not have unnamed arguments")
#>     }
#>     attribs <- html_attributes(dots$named)
#>     html(paste0("<img", attribs, " />"))
#> }
img(src = "myimage.png", width = 100, height = 100)
#> <HTML> <img src='myimage.png' width='100' height='100' />
```

### 21.2.5: Processing all tags

```{r}
tags <- c("a", "abbr", "address", "article", "aside", "audio",
  "b","bdi", "bdo", "blockquote", "body", "button", "canvas",
  "caption","cite", "code", "colgroup", "data", "datalist",
  "dd", "del","details", "dfn", "div", "dl", "dt", "em",
  "eventsource","fieldset", "figcaption", "figure", "footer",
  "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header",
  "hgroup", "html", "i","iframe", "ins", "kbd", "label",
  "legend", "li", "mark", "map","menu", "meter", "nav",
  "noscript", "object", "ol", "optgroup", "option", "output",
  "p", "pre", "progress", "q", "ruby", "rp","rt", "s", "samp",
  "script", "section", "select", "small", "span", "strong",
  "style", "sub", "summary", "sup", "table", "tbody", "td",
  "textarea", "tfoot", "th", "thead", "time", "title", "tr",
  "u", "ul", "var", "video"
)

void_tags <- c("area", "base", "br", "col", "command", "embed",
  "hr", "img", "input", "keygen", "link", "meta", "param",
  "source", "track", "wbr"
)
```

Some tags have similar names to base R functions. Place inside list and provide helper function to access them only when needed.

```{r}
html_tags <- c(
  tags %>% set_names() %>% map(tag),
  void_tags %>% set_names() %>% map(void_tag)
)

html_tags$p(
  "Some text. ",
  html_tags$b(html_tags$i("some bold italic text")),
  class = "mypara"
)
#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic
#> text</i></b></p>
```

```{r}
with_html <- function(code) {
  code <- enquo(code)
  eval_tidy(code, html_tags)
}

with_html(
  body(
    h1("A heading", id = "first"),
    p("Some text &", b("some bold text.")),
    img(src = "myimg.png", width = 100, height = 100)
  )
)
#> <HTML> <body><h1 id='first'>A heading</h1><p>Some text &amp;<b>some
#> bold text.</b></p><img src='myimg.png' width='100' height='100'
#> /></body>
```

### exercise

1.



2.


3.



4.










# V. Techniques


# 22 Debugging

1. Google
2. Reproducible/Repeatable
3. Where?
4. Fix & Test

## 22.3 Locating errors

`traceback()`: show sequence of calls that lead to error.

```{r}
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) {
  if (!is.numeric(d)) {
    stop("`d` must be numeric", call. = FALSE)
  }
  d + 10
}

f("A")
traceback()
```


### 22.3.1: Lazy evaluation

`traceback()`: linearises call tree, can be confusing if lazy evaluation involved.

```{r}
j <- function() k()
k <- function() stop("Oops!", call. = FALSE)
f(j())
#> Error: Oops!

traceback()
```

Try `rlang::with_abort()`, `rlang::last_trace()` instead.

```{r}
rlang::with_abort(f(j()))
rlang::last_trace()
```

## 22.4 Interactive debugger

Pause function and explore state.

`browser()`

### 22.4.1: `browser()` commands

`Next`/`n`: executes next step in function

`Step into`/`s`: step inside function

`Finish`/`f`: finish execution of current loop/function

`Continue`/`c`: Leave interactive debugging and continue regular execution of function

`Stop`/`Q`: stop debugging, terminate function, return to global workspace.

`Enter`: repeat previous command

`where`: print stack trace of active calls

### 22.4.2: Alternatives

Breakpoints: left of line number or `Shift + F9`. 

`recover()`: If error, prompt displaying traceback with `options(error = recover)`.

`debug()`: insert browser statement in first line of specified function. `undebug()` removes. `debugonce()` to browse ONLY for next run. 

`utils::setBreakpoint()`: input file name and line number.

Call stack: differ between `traceback()`, `browser()`, `where`, `recover()`.

## 22.5: Non-interactive debugging

`callr::(function)`: run function in fresh session.

Different global env? Different package load? Objects from previous session cause differences? 

Working directory? 

PATH environment variable? R_LIBS environment variable?

`dump.frames()`: Saves `last.dump.rda` file. Debug code for non-interactive code.

Print debugging: Insert numerous print statements to locate problem. See values of important variables. 

RMarkdown:

Switch to `rmarkdown::render("path/to/file.Rmd")` instead of button. 

Use `sink()` to capture output in console. 

```{r}
options(error = function() {
  sink()
  recover()
})
```


FOr traceback:

```{r}
options(rlang_trace_top_env = rlang::current_env())
options(error = function() {
  sink()
  print(rlang::trace_back(bottom = sys.frame(-1)), simplify = "none")
})
```

## 22.6: Non-error failures

Function may generate unexpected warning. 

Track down warnings by convert to errors `options(warn = 2)` and use call stack.

Function may generate unexpected message. Use `rlang::with_abort()` to turn messages into errors.

Function may niever return. 

Code crash R >>> look at C / C++ code.

# 23 Measuring Performance

Profile: measure run-time of each line of code with realistic inputs

```{r}
library(bench)
library(profvis)
```


## 23.2 Profiling

Accuracy vs. performance. Sampling profiler has minimal impact on performance but there's variability on acccuracy of timer and time taken by each operation.


`profvis::profvis()`: Code in separate file then "source" in.

## 23.3 Microbenchmarking

Measure performance of a small piece of code >>> ms, microseconds, nanoseconds

Useful for comparing smal snippets of code for specific tasks. 

`bench::mark()`: return as tibble, one row for each input expression. 


# 24 Improving Performance























