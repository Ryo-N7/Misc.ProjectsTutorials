---
title: "Untitled"
author: "RN7"
date: "9/7/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r}
pacman::p_load(lobstr, rlang, dplyr)
```


# 2. Names & Values

```{r}
set.seed(1014)
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)

str(df)

df$`3` <- df$`1`+ df$`2`

str(df)
```

```{r}
x <- runif(1e6)
y <- list(x, x, x)

# object.size(y) WRONG
lobstr::obj_size(y)
```




```{r}
a <- c(1, 5, 3, 2)
a

b <- a
b
a

b[[1]] <- 10

b

## a is copied when b is modified at line 3
```







```{r}
lobstr::obj_addr(mean)
lobstr::obj_addr(base::mean)
lobstr::obj_addr(get("mean"))
lobstr::obj_addr(evalq(mean))
lobstr::obj_addr(match.fun("mean"))
```


```{r}
read.csv(check.names = FALSE)
```




```{r}
x <- c(1L, 2L, 3L)
x
tracemem(x)

x[[3]] <- 4
untracemem(x)
```





# 3. Vectors

## 3.2: Atomic Vectors

4 common types of vectors: double, character, logical, integer
2 rare types of vectors: complex, raw

Attributes: associate arbitrary additional metadata to object

```{r}
attr()
attributes()
```

List vs. atomic vector: elements of LIST can be ANY type, elements of atomic vector must be the same

Matrix vs. data frame:  element of matrix must be same, element of data frame can be ANY type

List as matrix? Assign dimension to list
Data frame have column == matrix? Assign matrix to column of df with `<- matrix()` or `I()`

Difference between tibbles vs. data frame: tibbles have enhanced print method, NEVER coerces string to factors, provide stricter subsetting methods

### 3.2.1: Scalars

Scalar: individual value for the primary types of vectors
- Logical: TRUE / FALSE, T / F
- Doubles: decimal, scientific, hexadecimal forms. Special values (Inf, -Inf, NaN)
- Integers: no fractional values, use of `L` at end
- Strings: `"blah"`, special characters escaped with `\`



### 3.2.2: Longer vectors with `c()`

`c()`: combine

```{r}
lgl_var <- c(TRUE, FALSE)
lgl_var

int_var <- c(1L, 6L, 104L)
int_var

dbl_var <- c(1, 2.5, 6.45)
dbl_var

chr_var <- c("these are", "some strings")
chr_var
```
If inputs == atomic vectors >> `c()` creates another atomic vector >> flattens

```{r}
c(c(1, 2), c(3, 4))
```
`type_of()`: determine type of vector 



### 3.2.3: Missing Values

Missing/unknown: `NA`, most computations with missing value return missing value!

```{r}
NA > 5
10 * NA
!NA
```

Exceptions: when identity holds for all possible inputs

```{r}
NA ^ 0
NA | TRUE
NA & FALSE
```
Common mistake: 

```{r}
x <- c(NA, 5, NA, 10)
x == NA

## use is.na() instead for testing presence of missingness!
is.na(x)
```
NA types: `NA`, `NA_integer_`, `NA_real_`, `NA_character_`
- `NA` usually coerced to correct type

### 3.2.4: Testing and coercion

`is.*()`: test for type of vector. 
- AVOID: `is.vector()` + `is.atomic()` + `is.numeric()`
- When attempt to combine different vector types >>> coercion
- Coercion order: character >>> double >>> integer >>> logical
Ex. combine character + integet == character

```{r}
str(c("A", 1))
```
- Most mathematical functions coerc to numeric (`+`, `log()`, `abs()`, etc.)
- `TRUE` == `1` & `FALSE` == `0` 

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

## total number of TRUE
sum(x)

## proportion that are TRUE
mean(x)
```

`as.*()`: directly coerce vector type: `as.logical()`, `as.integer()`, `as.double()`, `as.character()`.

Ex. failed coercion:

```{r}
as.integer(c("1", "1.5", "a"))
```

### exercise

1. 
scalars == represented as vectors of length == 1
scalars of type raw:

```{r}
raw(1)
as.raw(42)
```

scalars of type complex:

```{r}
complex(1)
complex(length.out = 1, real = 1, imaginary = 1)
```

2. Vector coercion rules:

```{r}
c(1, FALSE)  ## double
c("a", 1)    ## character
c(TRUE, 1L)  ## integer
```

3. 

```{r}
1 == "1"    ## coerces to character
## TRUE because `1` is coerced to "1"

-1 < FALSE  ## coerces to double
## TRUE because `FALSE` coerces to double >> `0`

"one" < 2   ## coerces to character
## FALSE because `2` coerces to character "2"
## numerals precede letters but depends on locale
```
4. 

DEFAULT missing NA == logical vector: due to hierarchy of type coercion, when combining `NA` with other atomic vector types then will be coerced in order integer, numeric, character. IF `NA` was character than all other values in set would be coerced to characters as well which would be problematic.

5. 

`is.atomic()`: test if atomic vector or NULL
`is.numeric()`: test if object has type "integer"/"double" and NOT "factor", "Date", "POSIXt", "difftime"
`is.vector()`: test if object is vector and NO attributes besides names

## 3.3 Attributes

Atomic vectors != `matrices`, `arrays`, `factors`, `date-times`
- Built on top of atomic vectors by adding ATTRIBUTES

### 3.3.1: Getting & Setting

Attributes: name-value pairs >>> attach metadata on object
- `attr()`: retrieve/modify individual attributes
- `attributes()`: retrieve en masse
- `structure()`: set en masse

```{r}
a <- 1:3
attr(a, "asd49824-blahblah") <- "abcdef23blargh-attribute"
attr(a, "asd49824-blahblah")
```

```{r}
attr(a, "y") <- 4:6
str(attributes(a))
```

```{r}
a <- structure(
  1:3,
  x = "abcdef",
  y = 4:6
)

str(attributes(a))
```

Most attributes lost by operations:

```{r}
attributes(a[1])
attributes(sum(a))
```

Two attributes usually preserved:
- `names`: character vector giving each element a name
- `dim`: dimensions, integer vector used to turn vectors into matrices/arrays

To preserve others, need to create S3 class.

### 3.3.2: Names

```{r}
## Upon creation
x <- c(a = 1, b = 2, c = 3)
x

## Assigning character vector to `names()`
x <- 1:3
names(x) <- c("a", "b", "c")
x

## Inline via `setNames()`
x <- setNames(1:3, c("a", "b", "c"))
x
```

```{r}
unname(x)
names(x) <- NULL
```

Missing names either "" or `NA_character_`. If all names missing == `NULL`

### 3.3.3: Dimensions

`dim`: Add to vector for it to behave like 2D matrix or multi-D array. 

```{r}
## 2 scalar arguments specifying row + column size
a <- matrix(1:6, nrow = 2, ncol = 3)
a

## 1 vector argument to describe all dimensions
b <- array(1:6, c(2, 3, 1))
b

## modify object in palce with `dim()`
c <- 1:6
dim(c) <- c(2, 3)
c
```

- Vector with no `dim` attributes == NULL dimensions


### exercise

1. How are `setNames()` and `unname()` implemented?

- `setNames()`: uses `names()` and assigns input to the object
- `unname()`: removes existing names and sets to `NULL`

2. `dim()` to 1d vector? When use `NROW()` and `NCOL()`?

- `dim()`: returns NULL when applied to 1d vector

```{r}
x <- 1:10
nrow(x)
ncol(x)

## use for when handle atomic vectors, lists, NULLs similar to 1 column matrices/data frames
NROW(x)
NCOL(x)
```

3. 

```{r}
x1 <- array(1:5, c(1, 1, 5)) ## 1 row 1 col 5 z
x2 <- array(1:5, c(1, 5, 1)) ## 1 row 5 col 1 z
x3 <- array(1:5, c(5, 1, 1)) ## 5 rows 1 col 1 z
```

4. `structure()`

```{r}
foo <- structure(1:5, comment = "my attribute")

attributes(foo)

attr(foo, which = "comment")
```


## 3.4: S3 Atomic vectors

Class: vector attribute >>> S3 object system
S3 object: Object with a class attribute, behaves differently from regular ector when passed to a generic function. Every S3 object is built on top of a base type, stores additional info about other attributes.

### 3.4.1: Factors

Factor: Vector containing only pre-defined values for storing categorical data. Built on top of integer vector with 2 attributes
- Class "factor": behave differently from regular integer vectors
- levels: Defines the set of allowed values

```{r}
x <- factor(c("a", "b", "b", "a"))
x

typeof(x)
attributes(x)
```

Tabulating factors: Get counts of all categories, even if unobserved

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_factor)
```
Ordered: Order of levels is meaningful (ex. low, medium, high)

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
```

Careful when using string methods on factors, as they are built on integer vectors NOT character.

### 3.4.2: Dates

Date: Built on top of double vectors. 
- Class "Date", no other attributes

```{r}
today <- Sys.Date()

today

typeof(today)

attributes(today)

## value of double represents # of days since 1970-01-01
date <- as.Date("1970-02-01")
unclass(date)
```

### 3.4.3: Date-times


POSIXct: calendar time >> atomic vector, appropriate for data frames
POSIXlt: local time

```{r}
now_ct_DLT <- as.POSIXct("2018-07-22 09:00", tz = "America/New_York")
now_ct <- as.POSIXct("2018-11-22 09:00", tz = "America/New_York")

now_ct

typeof(now_ct)

attributes(now_ct)

structure(now_ct_DLT, tzone = "Asia/Tokyo")
structure(now_ct, tzone = "Asia/Tokyo")
```

### 3.4.4: Durations

Durations: Amount of time between pairs of dates or date-times. >>> `difftimes`
- Built on top of doubles, `units` attribute for how integer is interpreted

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

### exercise 

1. `table()` object? Type? Attributes? Dimension changes as add more variables?

Class: `table`
array of integers with attributes `dim` and `dimnames`
Dimensions correspond to # of unique values in each variable

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

tabobj <- table(sex_char)

typeof(tabobj)
attributes(tabobj)


```

2. What happens to factor when modify its levels?

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

levels(f1)
as.integer(f1)
```
Underlying integer values remain same but levels change!





### exercise 

`table()` returns type integer, class "table", with "dim" and "dimnames" attributes, represented internally as array of integers

```{r}
typeof(table(cars))
```


2. What happens to factor when you modify levels?

```{r}
f1 <- factor(letters)
levels(f1)
as.integer(f1)

levels(f1) <- rev(levels(f1))
levels(f1)
as.integer(f1)
```

underlying integer values stay the same but levels == changed!

3. How do `f2` and `f3` differ from `f1`?

```{r}
f2 <- rev(factor(letters))

f3 <- factor(letters, levels = rev(letters))

f1
f2
f3
```
f1: BOTH order of factor elements AND order of levels reversed!
f2: order of factor elements reversed
f3: order of levels reversed


## 3.5: Lists

- Each element can be ANY type, not just ectors. 

### 3.5.1: Creating

```{r}
l1 <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9)
)

typeof(l1)
str(l1)
```

Elements of list are references >>> Creating a list does NOT involve copying components INTO the list!

```{r}
lobstr::obj_size(mtcars)
l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
```


Lists: recursive vectors as list can contain other lists

```{r}
l3 <- list(list(list(1)))
str(l3)
```

`c()` combines several lists into 1. If combo of atomic vectors and lists, coerce vectors to lists before combining.

```{r}
l4 <- list(list(1, 2), c(3, 4))
l5 <- c(list(1, 2), c(3, 4))

str(l4)
str(l5)
```


### 3.5.2: Testing & coercion

`is.list()`, `as.list()`, `unlist()` for list >> atomic vector

```{r}
list(1:3)
as.list(1:3)
```

### 3.5.3: Matrices & arrays

- For atomic vectors, dimension attribute used for creating matrices
-- Lists: dimension attribute to create list-matrices and list-arrays

```{r}
l <- list(1:3, "a", TRUE, 1.0)
l

dim(l) <- c(2, 2)
l

l[1]
l[[1, 1]]
```

### exercise

1. List all ways list different from atomic vector

List: Can be heterogenous (elements of different types allowed), contain separate references for each element, subsetting out-of-bound values or NAs == `NULL`

Atomic vector: Always homogenous (all elements == same type), point to one address in memory, subsetting out-of-bound values or NAs == `NA`

```{r}
lobstr::ref(1:2)

lobstr::ref(list(1:2, 2))
```



2. Why use `unlist()` to convert list to atomic vector? Why `as.vector()` NOT work?

- List is already a vector (but not an atomic vector)
- `as.vector()` != `is.vector()`


3. Compare/contrast `c()` and `unlist()` when combining date and date-time into a single vector.

Date + date-time built on doubles. Dates == days, date-time (POSIXct) == seconds.

Generic function dispatches based on class of its first argument.

`c()` coerces types >> errors occur due to inappropriate method dispatch (avoid by explicit conversion of classes)
`unlist()` strips attributes

## 3.6 Data Frames and Tibbles

Data frame: Named list of vectors with attributes for column names, `row.names`, class: "data.frame"

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])

typeof(df1)

attributes(df1)
```

Dataframe additional constraint vs. regular list: Length of each vector must be the same >>> rectangular structure, reason why share properties of matrices + lists
- df: `rownames()` + `colnames()`. `names()` of df == column names
- df: `nrow()` + `ncol()`. `length()` of df == # of columns

Tibbles: modern re-imagining of data frames.

```{r}
library(tibble)

df2 <- tibble(x = 1:3, y = letters[1:3])
typeof(df2)
attributes(df2)
```

### 3.6.1: Creating

Supply name-vector pairs to `data.frame(0`)
- default conversion of strings to factors >> `stringsAsFactors = FALSE`

```{r}
df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c")
)

str(df)
```

Tibble: never coerces input

Data farames: automatically transform non-syntactic names (unless `check.names = FALSE`)

Tibble: NOT auto-transform non-syntactic names

```{r}
names(data.frame(`1` = 1))

names(tibble(`1` = 1))
```
- Every element must have same length, can recycle shorter inputs.
- df: recycle cols that are integer multiple of longest column
- tibble: only recycle vectors of length one

```{r}
data.frame(x = 1:4, y = 1:2)

data.frame(x = 1:4, y = 1:3)

tibble(x = 1:4, y = 1)

tibble(x = 1:4, y = 1:2)
```

tibbles: allow referencing variables created during construction (inputs evaluated left-to-right)

```{r}
tibble(x = 1:3,
       y = x * 2)
```



### 3.6.2: Row names

Label each row with character vector of unique values >>> `rownames()`

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)

df3
df3["Bob", ]
```

Can NOT transpose data frame as you would a matrix.

- Metadata == still data. 
- Row names are bad abstraction for labelling rows as only ID by single string (what about time or multiple vectors?).
- Unique: duplication of rows will create new row names. Matching rows == complicated regex

```{r}
df3[c(1, 1, 1), ]
```

Tibbles: NO row names >> convert row names to regular columns
- `rownames_to_column()` or specify in `rownames` argument in `as_tibble()`

### 3.6.3: Printing

Tibbles: First 10 rows and al columns that can fit on screen.
- Each column labelled with type
- Wide cols truncated

### 3.6.4: Subsetting

Data frames: Subset with `[` will return vector if only 1 variable selected, otherwise data frame
- Extract single column >>> if none then select any that starts with letter, then NULL

Tibble: `[` always returns tibble, `$` not do any partial matching + warning if none

### 3.6.5: Testing and coercing

`is.data.frame()` + `as.data.frame()` <> `is_tibble()` + `as_tibble()`

### 3.6.6: List columns

Data frames: Only created added after creation or wrap list with `I()`
Tibble: Directly included inside tibble creation

### 3.6.7: Matrix and data frame columns 

- Most functions assume data frame columns are vectors 



### exercise

1. Data frame with 0 rows? 0 columns?

```{r}
iris[0, ]
iris[, 0]
iris[0, 0]

data.frame()
```


2. Set rownames that are NOT unique?

- error if `row.names()`
- if subsetting with `[`, automatically de-duplicates


3. Transpose data frame?

returns matrix! output columns coerced to same type!

```{r}
class( t(t(data.frame(mtcars)))  )
```

4. `as.matrix()` to a data frame with different type columns? `data.matrix()`?

`as.matrix()` will coerce column types based on type hierarchy

`data.matrix()` converts to numeric >>> replace characters/factors with internal codes


## 3.7: NULL

NULL: Unique type, always length == 0, no attributes
- `is.null()`



# 4. Subsetting

- 6 ways to subset atomic vectors
- 3 subsetting operators: `[[`, `[`, `$`, interact differently with vector types
- Subsetting can be combined with assignment


## 4.2 Selecting multiple elements

`[`: Select any number of elements from a vector.

### 4.2.1: Atomic vectors

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

Postiive integers: return elements at specified positions:

```{r}
x[c(3, 1)]

x[order(x)]

x[c(1, 1)] ## duplicate indcies == duplicate values

x[c(2.1, 2.9)] ## real numbers truncated to integers
```

Negative integers: exclude elements at specified positions

```{r}
x[-c(3, 1)]
```


Can NOT mix pos and neg in single subset

Logical vectors: Select elements where corresponding logical value == TRUE

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]

x[x > 3]
```

IF `x[y]`, x & y are different lengths >>> recycling rules: shorter of two is recycled to the length of longer

```{r}
x[c(TRUE, FALSE)]
x[c(TRUE, FALSE, TRUE, FALSE)]
```

Missing value >>> NA in output


Nothing: returns original vector

Zero: returns zero-length vector

If named vector >>> character vectors: return elements with matching names


```{r}
(y <- setNames(x, letters[1:4]))

y[c("d", "c", "a")]

y[c("a", "a", "a")]

## names must be matched exactly:
z <- c(abc = 1, def = 2)
z[c("a", "d")]
```

Avoid subsetting with factors as use underlying integer vector and NOT the character levels.


### 4.2.2: Lists

`[`: always returns list
`[[` & `$`: pull elements from list

### 4.2.3: Matrices and arrays

Subset matrices & arrays:

- Multiple vectors
- Single vector
- Matrix

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ]

a[c(TRUE, FALSE, TRUE), c("B", "A")]
```
`[` simplifies results to lowest possible dimension. 

```{r}
a[1, ]
a[1, 1]
```

Single vector subsetting: Matrices + arrays are just vectors with special attributes

Arrays in R: column-major order ![](https://en.wikipedia.org/wiki/Row-_and_column-major_order#/media/File:Row_and_column_major_order.svg)

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals

vals[c(4, 15)]
```

Subset with integer matrix or character matrix (if named)" Each row in matrix  = location of one value, each column = dimension in array

```{r}
select <- matrix(ncol = 2, byrow = TRUE,
                 c(1, 1,
                   3, 1,
                   2, 4))

vals[select]
```

### 4.2.4: Data frames and tibbles

Single index: behave as lists >> index columns `df[1:2]` selects first two cols
Two indices: behave as matrices >> `df[1:3, ]` selects first three rows + all cols

Matrix subsetting simplifies by default, list does NOT.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2,]
df[c(1, 3), ]

df[c("x", "z")] ## list
df[, c("x", "z")] ## matrix

str(df["x"]) ## list
str(df[, "x"]) ## matrix

```

Subsetting tibble with `[` always returns tibble:

```{r}
df <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])

str(df["x"])
str(df[, "x"])
```

### 4.2.5: Preserving dimensionality

Preserve original dimensions >>> set `drop = FALSE`

Matrices + arrays: any dimensions with length 1 will be dropped

```{r}
a <- matrix(1:4, nrow = 2)
str(a[1, ])

str(a[1, , drop = FALSE])
```

Data frames with single column: return single column

```{r}
df <- data.frame(a = 1:2, b = 1:2)
str(df[, "a"])

str(df[, "a", drop = FALSE])
```

Tibble: defaults to using `drop = FALSE`

Factors: `drop` argument controls for levels (NOT dimensions) preserved, defaulting to `FALSE`. 

```{r}
z <- factor(c("a", "b"))

z[1]
z[1, drop = TRUE]
```

### exercise

1. Fix errors

```{r}
mtcars[mtcars$cyl = 4, ]
## need double ==
mtcars[mtcars$cyl == 4, ]

mtcars[-1:4, ]
## need to concatenate multiple selection
mtcars[-c(1:4), ]

mtcars[mtcars$cyl <= 5]
## need comma for all cols
mtcars[mtcars$cyl <= 5, ]

mtcars[mtcars$cyl == 4 | 6, ]
## separate filters need to be concatenated
mtcars[mtcars$cyl %in% c(4, 6), ]
```

2. 

```{r}
x <- 1:5
x[NA]

x[NA_real_] # returns single NA
```

`NA` is type: logical, logical vectors are recycled to the same length as vector being subsetted, so 5 `NA` returned.










